*******************************************************************

  Package   [pango_schm_funcs]

  Author    [XIAWEI]

  Abstract  [Schematic description common to pango architecture]

  Revision History:

********************************************************************************/
library work;
USE pango_defs;

package pango_schm_funcs
{

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw logic_sa tile]
  
  ---------|---------|---------|---------
  
    V[0,1]    A[1,1]   S[2,1]

    G[0,0]    R[1,0]   I[2,0] 
  ---------|---------|---------|---------  

  Revision History:

*****************************************************************************************/
function draw_logic_sa_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef, mRef, s0Ref, s1Ref, nRef, kRef;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device SRB  @[lsx+1,lsy]     of ARCHITECTURE>;
    mRef  = <device SIB  @[lsx+2,lsy]     of ARCHITECTURE>;
    s1Ref = <device CLMS @[lsx+2,lsy+1]   of ARCHITECTURE>;
    s0Ref = <device CLMA @[lsx+1,lsy+1]   of ARCHITECTURE>;
    nRef  = <device VCC  @[lsx,lsy+1]     of ARCHITECTURE>;
    kRef  = <device GND  @[lsx,lsy]       of ARCHITECTURE>;
    
    // Instantiate the schematic. 
    device LOGIC_SA_TILE ( schematic logic_sa_tile_schm ) 
        instance map
            (
                <symbol SRB  @[200,300]>  => xRef,
                <symbol SIB  @[640,336]>  => mRef,
                <symbol CLMS @[870,640]>  => s1Ref,
                <symbol CLMA @[740,380]>  => s0Ref,
                <symbol VCC  @[610,795]>  => nRef,
                <symbol GND  @[610,395]>  => kRef
            )
        @[gsx,gsy];


}; // end of function draw_logic_sa_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw logic_aa tile]

  ---------|---------|---------|---------
  
    V[0,1]    A0[1,1]  A1[2,1]

    G[0,0]    R[1,0]   I[2,0] 
  ---------|---------|---------|---------

  Revision History:

*****************************************************************************************/
function draw_logic_aa_tile
( 
    unsigned int tx,
    unsigned int ty
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef, mRef, s0Ref, s1Ref, nRef, kRef;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device SRB  @[lsx+1,lsy]     of ARCHITECTURE>;
    mRef  = <device SIB  @[lsx+2,lsy]     of ARCHITECTURE>;
    s1Ref = <device CLMA @[lsx+2,lsy+1]   of ARCHITECTURE>;
    s0Ref = <device CLMA @[lsx+1,lsy+1]   of ARCHITECTURE>;
    nRef  = <device VCC  @[lsx,lsy+1]     of ARCHITECTURE>;
    kRef  = <device GND  @[lsx,lsy]       of ARCHITECTURE>;
    
    // Instantiate the schematic. 
    device LOGIC_AA_TILE ( schematic logic_aa_tile_schm ) 
        instance map
            (
                <symbol SRB  @[200,300]>  => xRef,
                <symbol SIB  @[640,336]>  => mRef,
                <symbol CLMA @[870,640]>  => s1Ref,
                <symbol CLMA @[740,380]>  => s0Ref,
                <symbol VCC  @[610,795]>  => nRef,
                <symbol GND  @[610,395]>  => kRef
            )
        @[gsx,gsy];


}; // end of function draw_logic_aa_tile

/**VFunction******************************************************************************

  Author    [xiawei]

  Abstract  [Draw logic_hsst tile]
  
  ---------|---------|---------|---------
           CKN[0,1]  CKP[1,1]
  
                                         TILE 4 
  ---------|---------|---------|---------
           TXN[0,1]  TXP[1,1]  RXN[2,1]  RXP[3,1]
  
                                         TILE 3 
  ---------|---------|---------|---------
           TXN[0,1]  TXP[1,1]  RXN[2,1]  RXP[3,1]
  
                                         TILE 2 
  ---------|---------|---------|---------
           TXN[0,1]  TXP[1,1]  RXN[2,1]  RXP[3,1]
  
                                         TILE 1 
  ---------|---------|---------|---------
           TXN[0,1]  TXP[1,1]  RXN[2,1]  RXP[3,1]
  
           HSST[1,0]                TILE 0 
  ---------|---------|---------|---------

  Revision History:

*****************************************************************************************/
function draw_hsst_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy0,lsy1,lsy2,lsy3,lsy4, gsy;

    // device reference variables
    &device xRef,L0_TXN,L0_TXP,L0_RXN,L0_RXP,L1_TXN,L1_TXP,L1_RXN,L1_RXP,L2_TXN,L2_TXP,L2_RXN,L2_RXP,L3_TXN,L3_TXP,L3_RXN,L3_RXP,CKN,CKP;              
    string strVar;   
                                
    lsx = tx * TILE_NUM_SITE_X;
    lsy0 = ty * TILE_NUM_SITE_Y;
    lsy1 = (ty+1) * TILE_NUM_SITE_Y;
    lsy2 = (ty+2) * TILE_NUM_SITE_Y;
    lsy3 = (ty+3) * TILE_NUM_SITE_Y;
    lsy4 = (ty+4) * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    xRef  = <device HSST  @[lsx+1,lsy0]     of ARCHITECTURE>;
    sprintf(strVar, "HSST_%d_%d", lsx+1, lsy0);            
    device HSST   ( symbol logsym ) *strVar  @[gsx+1000,gsy+300];
    map 
    ( 
        <instance *strVar>   => xRef
    );                
    
    // Pull out the device instances from logic structure
    L0_TXN  = <device HSST_PAD_T  @[lsx,lsy0+1]     of ARCHITECTURE>;
    sprintf(strVar, "TXN_%d_%d", lsx,lsy0+1);            
    device HSST_PAD_T   ( symbol logsym ) *strVar  @[gsx+200,gsy+600+20000];
    map 
    ( 
        <instance *strVar>   => L0_TXN
    );                
    
    // Pull out the device instances from logic structure
    L0_TXP  = <device HSST_PAD_T  @[lsx+1,lsy0+1]     of ARCHITECTURE>;
    sprintf(strVar, "TXP_%d_%d", lsx+1,lsy0+1);            
    device HSST_PAD_T   ( symbol logsym ) *strVar  @[gsx+200,gsy+700+20000];
    map 
    ( 
        <instance *strVar>   => L0_TXP
    );                
    
    // Pull out the device instances from logic structure
    L0_RXN  = <device HSST_PAD_R  @[lsx+2,lsy0+1]     of ARCHITECTURE>;
    sprintf(strVar, "RXN_%d_%d", lsx+2,lsy0+1);            
    device HSST_PAD_R   ( symbol logsym ) *strVar  @[gsx+200,gsy+800+20000];
    map 
    ( 
        <instance *strVar>   => L0_RXN
    );                
    
    // Pull out the device instances from logic structure
    L0_RXP  = <device HSST_PAD_R  @[lsx+3,lsy0+1]     of ARCHITECTURE>;
    sprintf(strVar, "RXP_%d_%d", lsx+3,lsy0+1);            
    device HSST_PAD_R   ( symbol logsym ) *strVar  @[gsx+200,gsy+900+20000];
    map 
    ( 
        <instance *strVar>   => L0_RXP
    );                

    // Pull out the device instances from logic structure
    L1_TXN  = <device HSST_PAD_T  @[lsx,lsy1+1]     of ARCHITECTURE>;
    sprintf(strVar, "TXN_%d_%d", lsx,lsy1+1);            
    device HSST_PAD_T   ( symbol logsym ) *strVar  @[gsx+200,gsy+1600+20000];
    map 
    ( 
        <instance *strVar>   => L1_TXN
    );                

    // Pull out the device instances from logic structure
    L1_TXP  = <device HSST_PAD_T  @[lsx+1,lsy1+1]     of ARCHITECTURE>;
    sprintf(strVar, "TXP_%d_%d", lsx+1,lsy1+1);            
    device HSST_PAD_T   ( symbol logsym ) *strVar  @[gsx+200,gsy+1700+20000];
    map 
    ( 
        <instance *strVar>   => L1_TXP
    );                

    // Pull out the device instances from logic structure
    L1_RXN  = <device HSST_PAD_R  @[lsx+2,lsy1+1]     of ARCHITECTURE>;
    sprintf(strVar, "RXN_%d_%d", lsx+2,lsy1+1);            
    device HSST_PAD_R   ( symbol logsym ) *strVar  @[gsx+200,gsy+1800+20000];
    map 
    ( 
        <instance *strVar>   => L1_RXN
    );                

    // Pull out the device instances from logic structure
    L1_RXP  = <device HSST_PAD_R  @[lsx+3,lsy1+1]     of ARCHITECTURE>;
    sprintf(strVar, "RXP_%d_%d", lsx+3,lsy1+1);            
    device HSST_PAD_R   ( symbol logsym ) *strVar  @[gsx+200,gsy+1900+20000];
    map 
    ( 
        <instance *strVar>   => L1_RXP
    );                

    // Pull out the device instances from logic structure
    L2_TXN  = <device HSST_PAD_T  @[lsx,lsy2+1]     of ARCHITECTURE>;
    sprintf(strVar, "TXN_%d_%d", lsx,lsy2+1);            
    device HSST_PAD_T   ( symbol logsym ) *strVar  @[gsx+200,gsy+2600+20000];
    map 
    ( 
        <instance *strVar>   => L2_TXN
    );                

    // Pull out the device instances from logic structure
    L2_TXP  = <device HSST_PAD_T  @[lsx+1,lsy2+1]     of ARCHITECTURE>;
    sprintf(strVar, "TXP_%d_%d", lsx+1,lsy2+1);            
    device HSST_PAD_T   ( symbol logsym ) *strVar  @[gsx+200,gsy+2700+20000];
    map 
    ( 
        <instance *strVar>   => L2_TXP
    );                

    // Pull out the device instances from logic structure
    L2_RXN  = <device HSST_PAD_R  @[lsx+2,lsy2+1]     of ARCHITECTURE>;
    sprintf(strVar, "RXN_%d_%d", lsx+2,lsy2+1);            
    device HSST_PAD_R   ( symbol logsym ) *strVar  @[gsx+200,gsy+2800+20000];
    map 
    ( 
        <instance *strVar>   => L2_RXN
    );                

    // Pull out the device instances from logic structure
    L2_RXP  = <device HSST_PAD_R  @[lsx+3,lsy2+1]     of ARCHITECTURE>;
    sprintf(strVar, "RXP_%d_%d", lsx+3,lsy2+1);            
    device HSST_PAD_R   ( symbol logsym ) *strVar  @[gsx+200,gsy+2900+20000];
    map 
    ( 
        <instance *strVar>   => L2_RXP
    );                

    // Pull out the device instances from logic structure
    L3_TXN  = <device HSST_PAD_T  @[lsx,lsy3+1]     of ARCHITECTURE>;
    sprintf(strVar, "TXN_%d_%d", lsx,lsy3+1);            
    device HSST_PAD_T   ( symbol logsym ) *strVar  @[gsx+200,gsy+3600+20000];
    map 
    ( 
        <instance *strVar>   => L3_TXN
    );                

    // Pull out the device instances from logic structure
    L3_TXP  = <device HSST_PAD_T  @[lsx+1,lsy3+1]     of ARCHITECTURE>;
    sprintf(strVar, "TXP_%d_%d", lsx+1,lsy3+1);            
    device HSST_PAD_T   ( symbol logsym ) *strVar  @[gsx+200,gsy+3700+20000];
    map 
    ( 
        <instance *strVar>   => L3_TXP
    );                

    // Pull out the device instances from logic structure
    L3_RXN  = <device HSST_PAD_R  @[lsx+2,lsy3+1]     of ARCHITECTURE>;
    sprintf(strVar, "RXN_%d_%d", lsx+2,lsy3+1);            
    device HSST_PAD_R   ( symbol logsym ) *strVar  @[gsx+200,gsy+3800+20000];
    map 
    ( 
        <instance *strVar>   => L3_RXN
    );                

    // Pull out the device instances from logic structure
    L3_RXP  = <device HSST_PAD_R  @[lsx+3,lsy3+1]     of ARCHITECTURE>;
    sprintf(strVar, "RXP_%d_%d", lsx+3,lsy3+1);            
    device HSST_PAD_R   ( symbol logsym ) *strVar  @[gsx+200,gsy+3900+20000];
    map 
    ( 
        <instance *strVar>   => L3_RXP
    );              
    
    // Pull out the device instances from logic structure
    CKN  = <device HSST_PAD_R  @[lsx,lsy4+1]     of ARCHITECTURE>;
    sprintf(strVar, "CKN_%d_%d", lsx,lsy4+1);            
    device HSST_PAD_R   ( symbol logsym ) *strVar  @[gsx+200,gsy+4600+20000];
    map 
    ( 
        <instance *strVar>   => CKN
    );                

    // Pull out the device instances from logic structure
    CKP  = <device HSST_PAD_R  @[lsx+1,lsy4+1]     of ARCHITECTURE>;
    sprintf(strVar, "CKP_%d_%d", lsx+1,lsy4+1);            
    device HSST_PAD_R   ( symbol logsym ) *strVar  @[gsx+200,gsy+4700+20000];
    map 
    ( 
        <instance *strVar>   => CKP
    );                

}; // end of function draw_hsst_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw logic_base tile]
  
  ---------|---------|---------|---------
                                C[3,2]
    V[0,1]            
    G[0,0]    R[1,0]   I[2,0] 
  ---------|---------|---------|---------

  Revision History:

*****************************************************************************************/
function draw_base_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef, mRef, nRef, kRef,yRef;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device SRB  @[lsx+1,lsy]     of ARCHITECTURE>;
    mRef  = <device SIB  @[lsx+2,lsy]     of ARCHITECTURE>;
    yRef  = <device CIM  @[lsx+3,lsy+2]   of ARCHITECTURE>;
    nRef  = <device VCC  @[lsx,lsy+1]     of ARCHITECTURE>;
    kRef  = <device GND  @[lsx,lsy]       of ARCHITECTURE>;
    
    // Instantiate the schematic. 
    device LOGIC_BASE_TILE ( schematic logic_base_tile_schm ) 
        instance map
            (
                <symbol SRB  @[200,300]>  => xRef,
                <symbol SIB  @[640,336]>  => mRef,
                <symbol CIM  @[720,300]>  => yRef,                
                <symbol VCC  @[610,795]>  => nRef,
                <symbol GND  @[610,395]>  => kRef
            )
        @[gsx,gsy];


}; // end of function draw_base_tile

/**VFunction******************************************************************************

  Author    [xiawei]

  Abstract  [Draw PLL_CLKFB_MUX tile]
  
  ---------|---------|---------|---------   

        
                                PLL_CLKFB_MUX[0,2]
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function draw_pll_clkfb_mux_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;
    string strVar;

    // device reference variables
    &device xRef;              
                                
    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device PLL_CLKFB_MUX  @[lsx,lsy+2]     of ARCHITECTURE>;
    sprintf(strVar, "PLL_CLKFB_MUX_%d_%d", lsx, lsy+2);
    device PLL_CLKFB_MUX   ( symbol logsym ) *strVar  @[gsx+600,gsy+80];

    map 
    ( 
        <instance *strVar>   => xRef
    );                
                                                         
}; // end of function draw_pll_clkfb_mux_tile

/**VFunction******************************************************************************

  Author    [xiawei]

  Abstract  [Draw PLL_CLKIN_MUX tile]
  
  ---------|---------|---------|---------   

        
                  PLL_CLKIN_MUX[1,2],[2,2]
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function draw_pll_clkin_mux_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;
    string strVar0,strVar1;

    // device reference variables
    &device xRef,yRef;              
                                
    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device PLL_CLKIN_MUX  @[lsx+1,lsy+2]     of ARCHITECTURE>;
    sprintf(strVar0, "PLL_CLKIN_MUX_%d_%d", lsx+1, lsy+2);            
    device PLL_CLKIN_MUX   ( symbol logsym) *strVar0  @[gsx+730,gsy+10];

    yRef  = <device PLL_CLKIN_MUX  @[lsx+2,lsy+2]     of ARCHITECTURE>;
    sprintf(strVar1, "PLL_CLKIN_MUX_%d_%d", lsx+2, lsy+2);
    device PLL_CLKIN_MUX   ( symbol logsym ) *strVar1  @[gsx+730,gsy+150];
    map 
    ( 
        <instance *strVar0>   => xRef,
        <instance *strVar1>   => yRef
    );                

}; // end of function draw_pll_clkin_mux_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw apm tile]

  ---------|---------|---------|---------
  
                
              R[1,0]   I[2,0]                TILE 3
  ---------|---------|---------|---------
  
                
              R[1,0]   I[2,0]                TILE 2
  ---------|---------|---------|---------
  
                
              R[1,0]   I[2,0]                TILE 1
  ---------|---------|---------|---------
  
                       A[2,1]
              R[1,0]   I[2,0]                TILE 0
  ---------|---------|---------|---------


  Revision History:

*****************************************************************************************/
function draw_apm_tile
( 
    unsigned int apm_tile_x[],
    unsigned int apm_tile_y[]
)
{ 
    // Tile index variable
    unsigned int tx, ty;

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef;

    foreach tx ( apm_tile_x )
    {
        foreach ty ( apm_tile_y )
        {
            string strVar;
            
            draw_base_tile (tx, ty); 
            draw_base_tile (tx, ty+1);
            draw_base_tile (tx, ty+2);
            draw_base_tile (tx, ty+3);               
                                
            lsx = tx * TILE_NUM_SITE_X;
            lsy = ty * TILE_NUM_SITE_Y;
            gsx = tx * TILE_NUM_GUI_GRID_X;
            gsy = ty * TILE_NUM_GUI_GRID_Y;

            // Pull out the device instances from logic structure
            //
            xRef  = <device APM  @[lsx+2,lsy+1]     of ARCHITECTURE>;
            sprintf(strVar, "APM_%d_%d", lsx+2, lsy+1);
            device APM   ( symbol logsym )  *strVar  @[gsx+840,gsy+300];

            map 
            ( 
                <instance *strVar>   => xRef
            );                
                                                         
        }
    }

}; // end of function draw_apm_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw drm tile]
  
  ---------|---------|---------
                       
              R[1,0]   I[2,0]           TILE 4
  ---------|---------|---------
                       D[2,1]
              R[1,0]   I[2,0]           TILE 3
  ---------|---------|---------
                
              R[1,0]   I[2,0]           TILE 2
  ---------|---------|---------
                       D[2,1]
              R[1,0]   I[2,0]           TILE 1
  ---------|---------|---------
                       
              R[1,0]   I[2,0]           TILE 0
  ---------|---------|---------  
  
  

  Revision History:

*****************************************************************************************/
function draw_drm_tile
( 
    unsigned int drm_tile_x[],
    unsigned int drm_tile_y[]
)
{ 
    // Tile index variable
    unsigned int tx, ty;

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy0, lsy1, gsy;

    // device reference variables
    &device xRef,nRef;

    foreach tx ( drm_tile_x )
    {
        foreach ty ( drm_tile_y )
        {
            string strVar0,strVar1;
            
            draw_base_tile (tx, ty); 
            draw_base_tile (tx, ty+1);
            draw_base_tile (tx, ty+2);
            draw_base_tile (tx, ty+3);               
            draw_base_tile (tx, ty+4); 
                                            
            lsx = tx * TILE_NUM_SITE_X;
            lsy0 = (ty+1) * TILE_NUM_SITE_Y;
            lsy1 = (ty+3) * TILE_NUM_SITE_Y;
            gsx = tx * TILE_NUM_GUI_GRID_X;
            gsy = ty * TILE_NUM_GUI_GRID_Y;

            // Pull out the device instances from logic structure
            //
            xRef  = <device DRM  @[lsx+2,lsy0+1]     of ARCHITECTURE>;
            sprintf(strVar0, "DRM_%d_%d", lsx+2, lsy0+1);            
            device DRM   ( symbol logsym_0) *strVar0  @[gsx+840,gsy+300];
           
            nRef  = <device DRM  @[lsx+2,lsy1+1]     of ARCHITECTURE>;
            sprintf(strVar1, "DRM_%d_%d", lsx+2, lsy1+1);
            device DRM   ( symbol logsym_1 ) *strVar1  @[gsx+840,gsy+3050];
            map 
            ( 
                <instance *strVar0>   => xRef,
                <instance *strVar1>   => nRef
            );                
                                                         
        }
    }

}; // end of function draw_drm_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw drm0 tile]
  
  ---------|---------|---------|---------
                                 C[3,2]
  
              R[1,0]   I[2,0]                 TILE 2
  ---------|---------|---------|---------
                                 C[3,2]
                       D[2,1]
              R[1,0]   I[2,0]                 TILE 1
  ---------|---------|---------|---------
                                 C[3,2]
                                 
              R[1,0]   I[2,0]                 TILE 0
  ---------|---------|---------|---------
      
  Revision History:

*****************************************************************************************/

function draw_drm0_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy0, gsy;

    // device reference variables
    &device xRef ;
    string strVar0;   
          
    lsx = tx * TILE_NUM_SITE_X;
    lsy0 = (ty+1) * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

   // Pull out the device instances from logic structure
   //
   xRef  = <device DRM  @[lsx+2,lsy0+1]     of ARCHITECTURE>;
   sprintf(strVar0, "DRM_%d_%d", lsx+2, lsy0+1);            
   device DRM   ( symbol logsym_0) *strVar0  @[gsx+840,gsy+300];
           
    map 
    ( 
        <instance *strVar0>   => xRef
    );                
                                                         


}; // end of function draw_drm0_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw drm1 tile]
  
  ---------|---------|---------|---------
                                 C[3,2]
  
              R[1,0]   I[2,0]                 TILE 2
  ---------|---------|---------|---------
                                 C[3,2]
                       D[2,1]
              R[1,0]   I[2,0]                 TILE 1
  ---------|---------|---------|---------
                                 C[3,2]
                                 
              R[1,0]   I[2,0]                 TILE 0
  ---------|---------|---------|---------
      
  Revision History:

*****************************************************************************************/

function draw_drm1_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy1, gsy;

    // device reference variables
    &device xRef ;   
    string  strVar1;    
    
    lsx = tx * TILE_NUM_SITE_X;
    lsy1 = (ty+3) * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

   // Pull out the device instances from logic structure
   //
   xRef  = <device DRM  @[lsx+2,lsy1+1]     of ARCHITECTURE>;
   sprintf(strVar1, "DRM_%d_%d", lsx+2, lsy1+1);            
   device DRM   ( symbol logsym_1) *strVar1  @[gsx+840,gsy+3050];
           
    map 
    ( 
        <instance *strVar1>   => xRef
    );                
                                                         


}; // end of function draw_drm1_tile



/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw dll tile]

  ---------|---------|----------------|---------   
                      DLL_CLKMUX2[2,2]
   V[0,1]             DLL_CLKMUX1[2,1]  DLL1[3,1]
   G[0,0]   R[1,0]    I[2,0]            DLL0[3,0]
  ---------|---------|----------------|---------  

  Revision History:

*****************************************************************************************/
function draw_dll_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef, mRef, s0Ref, s1Ref, nRef, kRef, yRef, s2Ref, s3Ref;              
                                
     lsx = tx * TILE_NUM_SITE_X;
     lsy = ty * TILE_NUM_SITE_Y;
     gsx = tx * TILE_NUM_GUI_GRID_X;
     gsy = ty * TILE_NUM_GUI_GRID_Y;

      // Pull out the device instances from logic structure
      //
      xRef  = <device SRB         @[lsx+1,lsy]     of ARCHITECTURE>;
      mRef  = <device SIB         @[lsx+2,lsy]     of ARCHITECTURE>;
      yRef  = <device CIM         @[lsx+3,lsy+2]   of ARCHITECTURE>;      
      s1Ref = <device DLL         @[lsx+3,lsy+1]   of ARCHITECTURE>;
      s0Ref = <device DLL         @[lsx+3,lsy+0]   of ARCHITECTURE>;
      s3Ref = <device DLL_CLKMUX  @[lsx+2,lsy+2]   of ARCHITECTURE>;
      s2Ref = <device DLL_CLKMUX  @[lsx+2,lsy+1]   of ARCHITECTURE>;      
      nRef  = <device VCC         @[lsx,lsy+1]     of ARCHITECTURE>;
      kRef  = <device GND         @[lsx,lsy]       of ARCHITECTURE>;
      
      // Instantiate the schematic. 
      device DLL_TILE ( schematic dll_tile_schm ) 
          instance map
              (
                 <symbol SRB         @[200,300]>  => xRef,
                 <symbol SIB         @[640,336]>  => mRef,
                 <symbol CIM         @[720,300]>  => yRef,                  
                 <symbol DLL         @[1000,640]> => s1Ref,
                 <symbol DLL         @[880,360]>  => s0Ref,
                 <symbol DLL_CLKMUX  @[1090,687]> => s3Ref,
                 <symbol DLL_CLKMUX  @[970,407]>  => s2Ref,                 
                 <symbol VCC         @[610,795]>  => nRef,
                 <symbol GND         @[610,395]>  => kRef
              )
          @[gsx,gsy];                                               


}; // end of function draw_dll_tile

/**VFunction******************************************************************************

  Author    [xiawei]

  Abstract  [Draw dll withmux tile]

  ---------|---------|-----------------|---------   
               DLL_MUX1[1,2]        DLL_CLKMUX2[2,2]   C[3,2]
   V[0,1]   DLL_MUX0[1,1]          DLL_CLKMUX1[2,1]   DLL1[3,1]
   G[0,0]   R[1,0]    I[2,0]             DLL0[3,0]
  ---------|---------|-----------------|---------  

  Revision History:

*****************************************************************************************/
function draw_dll_withmux_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef, mRef, s0Ref, s1Ref, nRef, kRef, yRef, s2Ref, s3Ref, s4Ref, s5Ref;              
                                
     lsx = tx * TILE_NUM_SITE_X;
     lsy = ty * TILE_NUM_SITE_Y;
     gsx = tx * TILE_NUM_GUI_GRID_X;
     gsy = ty * TILE_NUM_GUI_GRID_Y;

      // Pull out the device instances from logic structure
      //
      xRef  = <device SRB         @[lsx+1,lsy]     of ARCHITECTURE>;
      mRef  = <device SIB         @[lsx+2,lsy]     of ARCHITECTURE>;
      yRef  = <device CIM         @[lsx+3,lsy+2]   of ARCHITECTURE>;      
      s1Ref = <device DLL         @[lsx+3,lsy+1]   of ARCHITECTURE>;
      s0Ref = <device DLL         @[lsx+3,lsy+0]   of ARCHITECTURE>;      
      s5Ref = <device DLL_MUX  @[lsx+1,lsy+2]   of ARCHITECTURE>;
      s4Ref = <device DLL_MUX  @[lsx+1,lsy+1]   of ARCHITECTURE>;      
      s3Ref = <device DLL_CLKMUX  @[lsx+2,lsy+2]   of ARCHITECTURE>;
      s2Ref = <device DLL_CLKMUX  @[lsx+2,lsy+1]   of ARCHITECTURE>;      
      nRef  = <device VCC         @[lsx,lsy+1]     of ARCHITECTURE>;
      kRef  = <device GND         @[lsx,lsy]       of ARCHITECTURE>;
      
      // Instantiate the schematic. 
      device DLL_TILE ( schematic dll_tile_withmux_schm ) 
          instance map
              (
                 <symbol SRB         @[200,300]>  => xRef,
                 <symbol SIB         @[640,336]>  => mRef,
                 <symbol CIM         @[720,300]>  => yRef,                  
                 <symbol DLL         @[1000,640]> => s1Ref,
                 <symbol DLL         @[880,360]>  => s0Ref,                 
                 <symbol DLL_MUX       @[1120,560]> => s5Ref,
                 <symbol DLL_MUX       @[1120,500]>  => s4Ref,
                 <symbol DLL_CLKMUX  @[1090,687]> => s3Ref,
                 <symbol DLL_CLKMUX  @[970,407]>  => s2Ref,                 
                 <symbol VCC         @[610,795]>  => nRef,
                 <symbol GND         @[610,395]>  => kRef
              )
          @[gsx,gsy];                                               

}; // end of function draw_dll_withmux_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw pll tile]

  IF dir == -1, PLL in top
  ---------|---------|---------|---------   
                                 C[3,2]
   V[0,1]                                    Tile 0
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 1
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 2
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 3
   G[0,0]   R[1,0]    I[2,0]        
  ---------|---------|---------|---------   
                                 C[3,2]
   V[0,1]                                    Tile 4
   G[0,0]   R[1,0]    I[2,0]     PLL[3,0]
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 5
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 6
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------     
                                 C[3,2]
   V[0,1]                                    Tile 7
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------   
  
  //
  IF dir == 1, PLL in bottom
  ---------|---------|---------|---------   
                                 C[3,2]
   V[0,1]                                    Tile 7
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 6
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 5
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 4
   G[0,0]   R[1,0]    I[2,0]     PLL[3,0]   
  ---------|---------|---------|---------   
                                 C[3,2]
   V[0,1]                                    Tile 3
   G[0,0]   R[1,0]    I[2,0]     
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 2
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 1
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------     
                                 C[3,2]
   V[0,1]                                    Tile 0
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------   

  Revision History:

*****************************************************************************************/
function draw_pll_tile
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int dir 
)
{ 

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef;
   
    string strVar;
    
    draw_base_tile (tx, ty); 
    draw_base_tile (tx, ty+dir);
    draw_base_tile (tx, ty+2*dir);            
    draw_base_tile (tx, ty+3*dir); 
    draw_base_tile (tx, ty+4*dir);
    draw_base_tile (tx, ty+5*dir);
    draw_base_tile (tx, ty+6*dir);
    draw_base_tile (tx, ty+7*dir);
    
    draw_pll_clkfb_mux_tile(tx, ty+4*dir);
    draw_pll_clkin_mux_tile(tx, ty+4*dir);
                        
    lsx = tx * TILE_NUM_SITE_X;
    lsy = (ty + 4*dir) * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    if(dir == 1)
    {
        gsy = ty * TILE_NUM_GUI_GRID_Y;
        xRef  = <device PLL  @[lsx+3,lsy]     of ARCHITECTURE>;
        sprintf(strVar, "PLL_%d_%d", lsx+3, lsy);
        device PLL   ( symbol logsym_0 ) *strVar  @[gsx+840,gsy+300];        
    }
    else
    {
        gsy = (ty+7*dir) * TILE_NUM_GUI_GRID_Y;  
        xRef  = <device PLL  @[lsx+3,lsy]     of ARCHITECTURE>;
        sprintf(strVar, "PLL_%d_%d", lsx+3, lsy);
        device PLL   ( symbol logsym_1 ) *strVar  @[gsx+840,gsy+300];
    }

    map 
    ( 
        <instance *strVar>   => xRef
    );                
                                                         


}; // end of function draw_pll_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw dqs_tb tile]
  
  ---------|---------|---------|--------- 
                     IOMUX5[2,2] C[3,2]         
   V[0,1]            IOMUX4[2,1] DQSMUX[3,1]
   G[0,0]  R[1,0]    I[2,0]      DQS[3,0] 
  ---------|---------|---------|--------- 
  
  Revision History:

*****************************************************************************************/
function draw_dqs_tb_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef, mRef, hRef, nRef, kRef, yRef, qRef, s2Ref, s3Ref;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device SRB     @[lsx+1,lsy]     of ARCHITECTURE>;
    mRef  = <device SIB     @[lsx+2,lsy]     of ARCHITECTURE>; 
    yRef  = <device CIM     @[lsx+3,lsy+2]   of ARCHITECTURE>;      
    hRef  = <device DQS     @[lsx+3,lsy]     of ARCHITECTURE>;
    s3Ref = <device IOMUX   @[lsx+2,lsy+2]   of ARCHITECTURE>; 
    s2Ref = <device IOMUX   @[lsx+2,lsy+1]   of ARCHITECTURE>;       
    qRef  = <device DQS_MUX @[lsx+3,lsy+1]   of ARCHITECTURE>;       
    nRef  = <device VCC     @[lsx,lsy+1]     of ARCHITECTURE>;
    kRef  = <device GND     @[lsx,lsy]       of ARCHITECTURE>;
    
    // Instantiate the schematic. 
    device DQS_TILE ( schematic dqs_0_tile_schm ) 
        instance map
            (
                <symbol SRB      @[200,300]>  => xRef,
                <symbol SIB      @[640,336]>  => mRef,
                <symbol CIM      @[720,300]>  => yRef,                              
                <symbol DQS      @[920,370]>  => hRef, 
                <symbol IOMUX    @[1040,639]> => s3Ref,
                <symbol IOMUX    @[1040,621]> => s2Ref,                 
                <symbol DQS_MUX  @[1050,370]> => qRef,                               
                <symbol VCC      @[610,795]>  => nRef,
                <symbol GND      @[610,395]>  => kRef
            )
        @[gsx,gsy];


}; // end of function draw_dqs_tb_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw dqs_r tile]
  
  ---------|---------|---------|--------- 
                     IOMUX5[2,2] C[3,2]         
   V[0,1]            IOMUX4[2,1] DQSMUX[3,1]
   G[0,0]  R[1,0]    I[2,0]      DQS[3,0] 
  ---------|---------|---------|--------- 
  
  Revision History:

*****************************************************************************************/
function draw_dqs_r_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef, mRef, hRef, nRef, kRef, yRef, qRef, s2Ref, s3Ref;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device SRB     @[lsx+1,lsy]     of ARCHITECTURE>;
    mRef  = <device SIB     @[lsx+2,lsy]     of ARCHITECTURE>; 
    yRef  = <device CIM     @[lsx+3,lsy+2]   of ARCHITECTURE>;      
    hRef  = <device DQS     @[lsx+3,lsy]     of ARCHITECTURE>;
    s3Ref = <device IOMUX   @[lsx+2,lsy+2]   of ARCHITECTURE>; 
    s2Ref = <device IOMUX   @[lsx+2,lsy+1]   of ARCHITECTURE>;     
    qRef  = <device DQS_MUX @[lsx+3,lsy+1]   of ARCHITECTURE>;     
    nRef  = <device VCC     @[lsx,lsy+1]     of ARCHITECTURE>;
    kRef  = <device GND     @[lsx,lsy]       of ARCHITECTURE>;
    
    // Instantiate the schematic. 
    device DQS_TILE ( schematic dqs_1_tile_schm ) 
        instance map
            (
                <symbol SRB      @[200,300]>  => xRef,
                <symbol SIB      @[640,336]>  => mRef,
                <symbol CIM      @[720,300]>  => yRef,                              
                <symbol DQS      @[920,370]>  => hRef,
                <symbol IOMUX    @[1040,639]> => s3Ref,
                <symbol IOMUX    @[1040,621]> => s2Ref,                 
                <symbol DQS_MUX  @[1050,370]> => qRef,                                
                <symbol VCC      @[610,795]>  => nRef,
                <symbol GND      @[610,395]>  => kRef
            )
        @[gsx,gsy];


}; // end of function draw_dqs_r_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io tile]

---------|---------|---------|--------- 
          IOL[1,2]  IOB_B[2,2] C[3,2]                            
  V[0,1]  IOL[1,1]  IOB_A[2,1] IOMUX2[3,1]
  G[0,0]  R[1,0]    I[2,0]     IOMUX1[3,0] 
---------|---------|---------|---------   

  Revision History:

*****************************************************************************************/
function draw_io_tile
( 
    unsigned int tx,
    unsigned int ty
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef, mRef, s0Ref, s1Ref, s3Ref, s4Ref, s5Ref, s6Ref, nRef, kRef, yRef;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device SRB    @[lsx+1,lsy]     of ARCHITECTURE>;
    mRef  = <device SIB    @[lsx+2,lsy]     of ARCHITECTURE>;
    yRef  = <device CIM    @[lsx+3,lsy+2]   of ARCHITECTURE>;     
    s1Ref = <device IOL    @[lsx+1,lsy+2]   of ARCHITECTURE>;
    s0Ref = <device IOL    @[lsx+1,lsy+1]   of ARCHITECTURE>;
    s4Ref = <device IOB_B  @[lsx+2,lsy+2]   of ARCHITECTURE>; 
    s3Ref = <device IOB_A  @[lsx+2,lsy+1]   of ARCHITECTURE>;    
    s6Ref = <device IOMUX  @[lsx+3,lsy+1]   of ARCHITECTURE>;
    s5Ref = <device IOMUX  @[lsx+3,lsy+0]   of ARCHITECTURE>;                
    nRef  = <device VCC    @[lsx+0,lsy+1]   of ARCHITECTURE>;
    kRef  = <device GND    @[lsx,lsy]       of ARCHITECTURE>;
    
    // Instantiate the schematic. 
    device IOL_TILE ( schematic iol_tile_schm ) 
        instance map
            (
                <symbol SRB    @[200,300]>  => xRef,
                <symbol SIB    @[640,336]>  => mRef,
                <symbol CIM    @[720,300]>  => yRef,                
                <symbol IOL    @[880,640]>  => s1Ref,
                <symbol IOL    @[880,360]>  => s0Ref,
                <symbol IOB_B  @[1040,710]> => s4Ref,
                <symbol IOB_A  @[1040,430]> => s3Ref,
                <symbol IOMUX  @[1040,780]> => s6Ref,
                <symbol IOMUX  @[1040,500]> => s5Ref,                
                <symbol VCC    @[610,795]>  => nRef,
                <symbol GND    @[610,395]>  => kRef
            )
        @[gsx,gsy];

}; // end of function draw_io_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_l tile]
  
  ---------|---------|---------|--------- 
            IOL_L[1,2]  IOB_LB[2,2] C[3,2]                           
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1] 
    G[0,0]  R[1,0]      I[2,0]       
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function draw_io_l_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef, mRef, s0Ref, s1Ref, s3Ref, s4Ref, nRef, kRef, yRef;  

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device SRB      @[lsx+1,lsy]     of ARCHITECTURE>;
    mRef  = <device SIB      @[lsx+2,lsy]     of ARCHITECTURE>;
    yRef  = <device CIM      @[lsx+3,lsy+2]   of ARCHITECTURE>;    
    s1Ref = <device IOL_L    @[lsx+1,lsy+2]   of ARCHITECTURE>;
    s0Ref = <device IOL_L    @[lsx+1,lsy+1]   of ARCHITECTURE>;
    s4Ref = <device IOB_LB   @[lsx+2,lsy+2]   of ARCHITECTURE>;    
    s3Ref = <device IOB_LA   @[lsx+2,lsy+1]   of ARCHITECTURE>;            
    nRef  = <device VCC      @[lsx+0,lsy+1]   of ARCHITECTURE>;
    kRef  = <device GND      @[lsx,lsy]       of ARCHITECTURE>;
    
    // Instantiate the schematic. 
    device IOL_L_TILE ( schematic iol_l_tile_schm ) 
        instance map
            (
                <symbol SRB      @[200,300]>  => xRef,
                <symbol SIB      @[640,336]>  => mRef,
                <symbol CIM      @[720,300]>  => yRef,                
                <symbol IOL_L    @[880,640]>  => s1Ref,
                <symbol IOL_L    @[880,360]>  => s0Ref,
                <symbol IOB_LB   @[1040,710]> => s4Ref,
                <symbol IOB_LA   @[1040,430]> => s3Ref,
                <symbol VCC      @[610,795]>  => nRef,
                <symbol GND      @[610,395]>  => kRef
            )
        @[gsx,gsy];

}; // end of function draw_io_l_tile

/**VFunction******************************************************************************

  Author    [xiawei]

  Abstract  [draw io_1cim_v_b_tile tile]
  
  ---------|---------|---------|--------- 
            IOL[1,2]  IOB_LB[2,2] C[3,2]                           
    V[0,1]  
    G[0,0]  R[1,0]      I[2,0]       
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function draw_io_1cim_v_b_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef, mRef, s1Ref, s4Ref, s6Ref, nRef, kRef, yRef;  

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device SRB      @[lsx+1,lsy]     of ARCHITECTURE>;
    mRef  = <device SIB      @[lsx+2,lsy]     of ARCHITECTURE>;
    yRef  = <device CIM      @[lsx+3,lsy+2]   of ARCHITECTURE>;    
    s1Ref = <device IOL     @[lsx+1,lsy+2]   of ARCHITECTURE>;
    s4Ref = <device IOB_LB   @[lsx+2,lsy+2]   of ARCHITECTURE>;            
    s6Ref = <device IOMUX  @[lsx+3,lsy+1]   of ARCHITECTURE>;
    nRef  = <device VCC      @[lsx+0,lsy+1]   of ARCHITECTURE>;
    kRef  = <device GND      @[lsx,lsy]       of ARCHITECTURE>;
    
    // Instantiate the schematic. 
    device IOL_1B_TILE ( schematic iol_1b_tile_schm ) 
        instance map
            (
                <symbol SRB      @[200,300]>  => xRef,
                <symbol SIB      @[640,336]>  => mRef,
                <symbol CIM      @[720,300]>  => yRef,                
                <symbol IOL    @[880,640]>  => s1Ref,
                <symbol IOB_LB   @[1040,710]> => s4Ref,
                <symbol IOMUX  @[1040,780]> => s6Ref,
                <symbol VCC      @[610,795]>  => nRef,
                <symbol GND      @[610,395]>  => kRef
            )
        @[gsx,gsy];

}; // end of function draw_io_1cim_v_b_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_l_1b tile]
  
  ---------|---------|---------|--------- 
            IOL_L[1,2]  IOB_LB[2,2] C[3,2]                           
    V[0,1]  
    G[0,0]  R[1,0]      I[2,0]       
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function draw_io_l_1b_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef, mRef, s1Ref, s4Ref, nRef, kRef, yRef;  

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device SRB      @[lsx+1,lsy]     of ARCHITECTURE>;
    mRef  = <device SIB      @[lsx+2,lsy]     of ARCHITECTURE>;
    yRef  = <device CIM      @[lsx+3,lsy+2]   of ARCHITECTURE>;    
    s1Ref = <device IOL_L    @[lsx+1,lsy+2]   of ARCHITECTURE>;
    s4Ref = <device IOB_LB   @[lsx+2,lsy+2]   of ARCHITECTURE>;            
    nRef  = <device VCC      @[lsx+0,lsy+1]   of ARCHITECTURE>;
    kRef  = <device GND      @[lsx,lsy]       of ARCHITECTURE>;
    
    // Instantiate the schematic. 
    device IOL_L_1B_TILE ( schematic iol_l_1b_tile_schm ) 
        instance map
            (
                <symbol SRB      @[200,300]>  => xRef,
                <symbol SIB      @[640,336]>  => mRef,
                <symbol CIM      @[720,300]>  => yRef,                
                <symbol IOL_L    @[880,640]>  => s1Ref,
                <symbol IOB_LB   @[1040,710]> => s4Ref,
                <symbol VCC      @[610,795]>  => nRef,
                <symbol GND      @[610,395]>  => kRef
            )
        @[gsx,gsy];

}; // end of function draw_io_l_1b_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_f tile]

---------|---------|---------|--------- 
          IOL[1,2]  IOB_LB[2,2] C[3,2]                            
  V[0,1]  IOL[1,1]  IOB_LA[2,1] IOMUX2[3,1]
  G[0,0]  R[1,0]    I[2,0]      IOMUX1[3,0]
---------|---------|---------|---------   

  Revision History:

*****************************************************************************************/
function draw_io_f_tile
( 
    unsigned int tx,
    unsigned int ty
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef, mRef, s0Ref, s1Ref, s3Ref, s4Ref, s5Ref, s6Ref, nRef, kRef, yRef;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device SRB    @[lsx+1,lsy]     of ARCHITECTURE>;
    mRef  = <device SIB    @[lsx+2,lsy]     of ARCHITECTURE>;
    yRef  = <device CIM    @[lsx+3,lsy+2]   of ARCHITECTURE>;     
    s1Ref = <device IOL    @[lsx+1,lsy+2]   of ARCHITECTURE>;
    s0Ref = <device IOL    @[lsx+1,lsy+1]   of ARCHITECTURE>;
    s4Ref = <device IOB_LB @[lsx+2,lsy+2]   of ARCHITECTURE>; 
    s3Ref = <device IOB_LA @[lsx+2,lsy+1]   of ARCHITECTURE>; 
    s6Ref = <device IOMUX  @[lsx+3,lsy+1]   of ARCHITECTURE>;
    s5Ref = <device IOMUX  @[lsx+3,lsy+0]   of ARCHITECTURE>;                  
    nRef  = <device VCC    @[lsx+0,lsy+1]   of ARCHITECTURE>;
    kRef  = <device GND    @[lsx,lsy]       of ARCHITECTURE>;
    
    // Instantiate the schematic. 
    device IOL_F_TILE ( schematic iol_f_tile_schm ) 
        instance map
            (
                <symbol SRB    @[200,300]>  => xRef,
                <symbol SIB    @[640,336]>  => mRef,
                <symbol CIM    @[720,300]>  => yRef,                
                <symbol IOL    @[880,640]>  => s1Ref,
                <symbol IOL    @[880,360]>  => s0Ref,
                <symbol IOB_LB @[1040,710]> => s4Ref,
                <symbol IOB_LA @[1040,430]> => s3Ref,
                <symbol IOMUX  @[1040,780]> => s6Ref,
                <symbol IOMUX  @[1040,500]> => s5Ref,                
                <symbol VCC    @[610,795]>  => nRef,
                <symbol GND    @[610,395]>  => kRef
            )
        @[gsx,gsy];

}; // end of function draw_io_f_tile



/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_4cim_6io_ttfftt_h tile]

  ---------|---------|---------|---------   ---------|---------|---------|---------    ---------|---------|---------|---------  ---------|---------|---------|---------   
            IOL[1,2]  IOB_B[2,2]                      IOL[1,2]  IOB_LB[2,2]                                                               IOL[1,2]  IOB_B[2,2]       
    V[0,1]  IOL[1,1]  IOB_A[2,1]            V[0,1]    IOL[1,1]  IOB_LA[2,1]            V[0,1]                                   V[0,1]    IOL[1,1]  IOB_A[2,1]       
    G[0,0]  R[1,0]    I[2,0]                G[0,0]    R[1,0]    I[2,0]                 G[0,0]    R[1,0]    I[2,0]               G[0,0]    R[1,0]    I[2,0]            
  ---------|---------|---------|---------   ---------|---------|---------|---------    ---------|---------|---------|---------  ---------|---------|---------|---------    
  
  Revision History:

*****************************************************************************************/
function draw_io_4cim_6io_ttfftt_h_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    draw_io_tile(tx , ty);
    draw_io_f_tile(tx + 1 , ty);
    draw_base_tile(tx + 2 , ty);
    draw_io_tile(tx + 3 , ty);    

};// end of function draw_io_4cim_6io_ttfftt_h_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_4cim_6io_ffttff_h tile]

  ---------|---------|---------|---------   ---------|---------|---------|---------    ---------|---------|---------|---------  ---------|---------|---------|---------   
            IOL[1,2]  IOB_LB[2,2]                     IOL[1,2]  IOB_B[2,2]                                                                IOL[1,2]  IOB_LB[2,2]       
    V[0,1]  IOL[1,1]  IOB_LA[2,1]           V[0,1]    IOL[1,1]  IOB_A[2,1]             V[0,1]                                   V[0,1]    IOL[1,1]  IOB_LA[2,1]       
    G[0,0]  R[1,0]    I[2,0]                G[0,0]    R[1,0]    I[2,0]                 G[0,0]    R[1,0]    I[2,0]               G[0,0]    R[1,0]    I[2,0]            
  ---------|---------|---------|---------   ---------|---------|---------|---------    ---------|---------|---------|---------  ---------|---------|---------|---------    
  
  Revision History:

*****************************************************************************************/
function draw_io_4cim_6io_ffttff_h_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    draw_io_f_tile(tx , ty);
    draw_io_tile(tx + 1 , ty);
    draw_base_tile(tx + 2 , ty);
    draw_io_f_tile(tx + 3 , ty);    

};// end of function draw_io_4cim_6io_ffttff_h_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_4cim_6io_dqs_h tile]

  ---------|---------|---------|---------   ---------|---------|---------|---------    ---------|---------|---------|---------  ---------|---------|---------|---------   
            IOL[1,2]  IOB_B[2,2]                      IOL[1,2]  IOB_LB[2,2]                                                               IOL[1,2]  IOB_B[2,2]       
    V[0,1]  IOL[1,1]  IOB_A[2,1]            V[0,1]    IOL[1,1]  IOB_LA[2,1]            V[0,1]                                   V[0,1]    IOL[1,1]  IOB_A[2,1]       
    G[0,0]  R[1,0]    I[2,0]                G[0,0]    R[1,0]    I[2,0]                 G[0,0]    R[1,0]    I[2,0]    DQS[3,0]   G[0,0]    R[1,0]    I[2,0]            
  ---------|---------|---------|---------   ---------|---------|---------|---------    ---------|---------|---------|---------  ---------|---------|---------|---------    
  
                TILE 0                                  TILE 1                                      TILE 2                                  TILE 3


  Revision History:

*****************************************************************************************/
function draw_io_4cim_6io_dqs_h_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    draw_io_tile(tx , ty);
    draw_io_f_tile(tx + 1 , ty);
    draw_dqs_tb_tile(tx + 2 , ty);
    draw_io_tile(tx + 3 , ty);    

};// end of function draw_io_4cim_6io_dqs_h_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_8cim_h tile]


  Revision History:

*****************************************************************************************/
function draw_io_8cim_h_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    draw_io_4cim_6io_ffttff_h_tile(tx, ty);
    draw_io_4cim_6io_dqs_h_tile(tx+4, ty);   

};// end of function draw_io_8cim_h_tile



/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_dqs_tt_2cim_v tile]

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_B[2,2]        
    V[0,1]  IOL[1,1]  IOB_A[2,1]             TILE 0
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 1
    G[0,0]  R[1,0]    I[2,0]    DQS[3,0] 
  ---------|---------|---------|---------
    
  Revision History:

*****************************************************************************************/
function draw_io_dqs_tt_2cim_v_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    draw_io_tile(tx , ty);
    draw_dqs_r_tile(tx  , ty - 1);    

};// end of function draw_io_dqs_tt_2cim_v_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_dqs_ff_2cim_v tile]

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL[1,1]  IOB_LA[2,1]            TILE 0
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 1
    G[0,0]  R[1,0]    I[2,0]    DQS[3,0] 
  ---------|---------|---------|---------
    
  Revision History:

*****************************************************************************************/
function draw_io_dqs_ff_2cim_v_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    draw_io_f_tile(tx , ty);
    draw_dqs_r_tile(tx  , ty - 1);    

};// end of function draw_io_dqs_ff_2cim_v_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_3cim_4io_v_u tile]

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_B[2,2]        
    V[0,1]  IOL[1,1]  IOB_A[2,1]             TILE 0
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 1
    G[0,0]  R[1,0]    I[2,0]     
  ---------|---------|---------|---------
  
  ---------|---------|---------|---------
            IOL[1,2]  IOB_LB[2,2]      
    V[0,1]  IOL[1,1]  IOB_LA[2,1]            TILE 2
    G[0,0]  R[1,0]    I[2,0]           
  ---------|---------|---------|---------

  
  Revision History:

*****************************************************************************************/
function draw_io_3cim_4io_v_u_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    draw_io_tile(tx , ty);
    draw_base_tile(tx , ty - 1);
    draw_io_f_tile(tx , ty - 2);    

};// end of function draw_io_3cim_4io_v_u_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_4cim_6io_ttfftt_v tile]

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_B[2,2]        
    V[0,1]  IOL[1,1]  IOB_A[2,1]             TILE 0
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL[1,1]  IOB_LA[2,1]            TILE 1
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------    
  
  ---------|---------|---------|---------
                  
    V[0,1]                                   TILE 2
    G[0,0]  R[1,0]    I[2,0]           
  ---------|---------|---------|---------

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_B[2,2]        
    V[0,1]  IOL[1,1]  IOB_A[2,1]             TILE 3
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------    


  Revision History:

*****************************************************************************************/
function draw_io_4cim_6io_ttfftt_v_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    draw_io_tile(tx , ty);
    draw_io_f_tile(tx , ty - 1);
    draw_base_tile(tx , ty - 2);    
    draw_io_tile(tx , ty - 3);    

};// end of function draw_io_4cim_6io_ttfftt_v_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_4cim_6io_ffttff_v tile]

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL[1,1]  IOB_LA[2,1]            TILE 0
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL[1,1]  IOB_LA[2,1]            TILE 1
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------    
  
  ---------|---------|---------|---------
                  
    V[0,1]                                   TILE 2
    G[0,0]  R[1,0]    I[2,0]           
  ---------|---------|---------|---------

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL[1,1]  IOB_LA[2,1]            TILE 3
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------    

 
  Revision History:

*****************************************************************************************/
function draw_io_4cim_6io_ffttff_v_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    draw_io_f_tile(tx , ty);
    draw_io_tile(tx , ty - 1);
    draw_base_tile(tx , ty - 2);    
    draw_io_f_tile(tx , ty - 3);    

};// end of function draw_io_4cim_6io_ffttff_v_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_3cim_4io_v_d tile]

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_B[2,2]        
    V[0,1]  IOL[1,1]  IOB_A[2,1]             TILE 0
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------     
  
  ---------|---------|---------|---------
            IOL[1,2]  IOB_LB[2,2]      
    V[0,1]  IOL[1,1]  IOB_LA[2,1]            TILE 1
    G[0,0]  R[1,0]    I[2,0]           
  ---------|---------|---------|---------

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 2
    G[0,0]  R[1,0]    I[2,0]     
  ---------|---------|---------|---------

  
  Revision History:

*****************************************************************************************/
function draw_io_3cim_4io_v_d_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    draw_io_tile(tx , ty);
    draw_io_f_tile(tx , ty - 1); 
    draw_base_tile(tx , ty - 2);   

};// end of function draw_io_3cim_4io_v_d_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_9cim_v_u tile]

  Revision History:

*****************************************************************************************/
function draw_io_9cim_v_u_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    draw_io_3cim_4io_v_u_tile(tx,ty);
    draw_io_dqs_tt_2cim_v_tile(tx, ty-3);
    draw_io_4cim_6io_ffttff_v_tile(tx, ty-5);

};// end of function draw_io_9cim_v_u_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_9cim_v_d tile]

  Revision History:

*****************************************************************************************/
function draw_io_9cim_v_d_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    draw_io_4cim_6io_ttfftt_v_tile(tx, ty);
    draw_io_dqs_ff_2cim_v_tile (tx, ty-4);
    draw_io_3cim_4io_v_d_tile(tx, ty-6);

};// end of function draw_io_9cim_v_d_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_10cim_v tile]

  Revision History:

*****************************************************************************************/
function draw_io_10cim_v_tile
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int false_true_flag    
)
{
   if(false_true_flag == 0)
   {   
       draw_io_4cim_6io_ttfftt_v_tile(tx, ty);
       draw_io_dqs_ff_2cim_v_tile(tx, ty-4);
       draw_io_4cim_6io_ttfftt_v_tile(tx, ty-6);       
   } 
   else
   {
       draw_io_4cim_6io_ffttff_v_tile(tx, ty);
       draw_io_dqs_tt_2cim_v_tile(tx, ty-4);
       draw_io_4cim_6io_ffttff_v_tile(tx, ty-6);     
   } 
           
};// end of function draw_io_10cim_v_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_l_3cim_4io_v_u tile]

  ---------|---------|---------|---------    
            IOL_L[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 0
    G[0,0]  R[1,0]      I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 1
    G[0,0]  R[1,0]      I[2,0]     
  ---------|---------|---------|---------
  
  ---------|---------|---------|---------
            IOL_L[1,2]  IOB_LB[2,2]      
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 2
    G[0,0]  R[1,0]      I[2,0]           
  ---------|---------|---------|---------

  
  Revision History:

*****************************************************************************************/
function draw_io_l_3cim_4io_v_u_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    draw_io_l_tile(tx , ty);
    draw_base_tile(tx , ty - 1);
    draw_io_l_tile(tx , ty - 2);    

};// end of function draw_io_l_3cim_4io_v_u_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_l_4cim_6io_v tile]

  ---------|---------|---------|---------    
            IOL_L[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 0
    G[0,0]  R[1,0]      I[2,0]             
  ---------|---------|---------|---------   
  
  ---------|---------|---------|---------    
            IOL_L[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 1
    G[0,0]  R[1,0]      I[2,0]             
  ---------|---------|---------|---------       

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 2
    G[0,0]  R[1,0]      I[2,0]     
  ---------|---------|---------|---------
  
  ---------|---------|---------|---------
            IOL_L[1,2]  IOB_LB[2,2]      
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 3
    G[0,0]  R[1,0]      I[2,0]           
  ---------|---------|---------|---------

  
  Revision History:

*****************************************************************************************/
function draw_io_l_4cim_6io_v_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    draw_io_l_tile(tx , ty);
    draw_io_l_tile(tx , ty - 1);    
    draw_base_tile(tx , ty - 2);
    draw_io_l_tile(tx , ty - 3);    

};// end of function draw_io_l_4cim_6io_v_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_l_3cim_4io_v_d tile]

  ---------|---------|---------|---------    
            IOL_L[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 0
    G[0,0]  R[1,0]      I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------
            IOL_L[1,2]  IOB_LB[2,2]      
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 1
    G[0,0]  R[1,0]      I[2,0]           
  ---------|---------|---------|---------

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 2
    G[0,0]  R[1,0]      I[2,0]     
  ---------|---------|---------|---------
  
 
  Revision History:

*****************************************************************************************/
function draw_io_l_3cim_4io_v_d_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    draw_io_l_tile(tx , ty);
    draw_io_l_tile(tx , ty - 1);      
    draw_base_tile(tx , ty - 2);
  
};// end of function draw_io_l_3cim_4io_v_d_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_l_b_2cim_v tile]

  ---------|---------|---------|--------- 
            IOL_L[1,2]  IOB_LB[2,2] C[3,2]                           
    V[0,1]  
    G[0,0]  R[1,0]      I[2,0]       
  ---------|---------|---------|--------- 
  
 
  Revision History:

*****************************************************************************************/
function draw_io_l_b_2cim_v_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    
    draw_io_l_1b_tile(tx , ty);
      
};// end of function draw_io_l_b_2cim_v_tile

/**VFunction******************************************************************************

  Author    [xiawei]

  Abstract  [Draw pre_gmux_lr tile]
  
  ---------|---------|---------|---------   

        
                                GMUX_LR[3,0]
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function draw_pre_gmux_lr_tile
( 
    unsigned int tx0,
    unsigned int ty0,
    unsigned int tx1,
    unsigned int ty1
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef,yRef;              
                                
    lsx = tx0 * TILE_NUM_SITE_X;
    lsy = ty0 * TILE_NUM_SITE_Y;
    gsx = tx0 * TILE_NUM_GUI_GRID_X;
    gsy = ty0 * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    xRef  = <device PREGMUX_LR  @[lsx+3,lsy]     of ARCHITECTURE>;
    device PREGMUX_LR   ( symbol logsym_w ) PREGMUX_LR_w  @[gsx+250,gsy+1100];

    map 
    ( 
        <instance PREGMUX_LR_w>   => xRef
    );                

    lsx = tx1 * TILE_NUM_SITE_X;
    lsy = ty1 * TILE_NUM_SITE_Y;
    gsx = tx1 * TILE_NUM_GUI_GRID_X;
    gsy = ty1 * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    yRef  = <device PREGMUX_LR  @[lsx+3,lsy]     of ARCHITECTURE>;
    device PREGMUX_LR   ( symbol logsym_e ) PREGMUX_LR_e  @[gsx+830,gsy+1100];

    map 
    ( 
        <instance PREGMUX_LR_e>   => yRef
    );                
}; // end of function draw_pre_gmux_lr_tile

/**VFunction******************************************************************************

  Author    [xiawei]

  Abstract  [Draw pre_gmux_t tile]
  
  ---------|---------|---------|---------   

       
                                 GMUX_T[3,0]
  ---------|---------|---------|---------   

  Revision History:

*****************************************************************************************/
function draw_pre_gmux_t_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef;              
    string pregmux_t, pclkmux_t;
    
    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device PREGMUX_TB  @[lsx+3,lsy]     of ARCHITECTURE>;    
    sprintf(pregmux_t, "PREGMUX_TB_%d_%d", lsx+3, lsy);  
    device PREGMUX_TB   ( symbol logsym_n ) pregmux_t  @[gsx+450,gsy+400];

    map 
    ( 
        <instance pregmux_t>   => xRef
    ); 

    xRef  = <device PCLKMUX  @[lsx+3,lsy]     of ARCHITECTURE>;    
    sprintf(pclkmux_t, "PCLKMUX_%d_%d", lsx+3, lsy);  
    device PCLKMUX   ( symbol logsym_t ) pclkmux_t  @[gsx+520,gsy+600];

    map 
    ( 
        <instance pclkmux_t>   => xRef
    ); 
}; // end of function draw_pre_gmux_t_tile

/**VFunction******************************************************************************

  Author    [xiawei]

  Abstract  [Draw pre_gmux_b tile]
  
  ---------|---------|---------|---------   

       
                                 GMUX_B[3,0]
  ---------|---------|---------|---------   

  Revision History:

*****************************************************************************************/
function draw_pre_gmux_b_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef;              
    string pregmux_b, pclkmux_b;
                   
    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    xRef  = <device PREGMUX_TB  @[lsx+3,lsy]     of ARCHITECTURE>;    
    sprintf(pregmux_b, "PREGMUX_TB_%d_%d", lsx+3, lsy);  
    device PREGMUX_TB   ( symbol logsym_s ) pregmux_b  @[gsx+450,gsy+600];

    map 
    ( 
        <instance pregmux_b>   => xRef
    );    

    xRef  = <device PCLKMUX  @[lsx+3,lsy]     of ARCHITECTURE>;    
    sprintf(pclkmux_b, "PCLKMUX_%d_%d", lsx+3, lsy);  
    device PCLKMUX   ( symbol logsym_b ) pclkmux_b  @[gsx+520,gsy+470];

    map 
    ( 
        <instance pclkmux_b>   => xRef
    );    
}; // end of function draw_pre_gmux_b_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw post_gmux tile]
  
  ---------|---------|---------|---------   
  
           
                                POST_GMUX[3,0]
  ---------|---------|---------|---------  
  Revision History:

*****************************************************************************************/
function draw_post_gmux_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef;              
                                
    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device POST_GMUX  @[lsx+3,lsy]     of ARCHITECTURE>;
    device POST_GMUX   ( symbol logsym ) POSTGMUX  @[gsx+200,gsy+1050];

    map 
    ( 
        <instance POSTGMUX>   => xRef
    );                
                                                         
}; // end of function draw_post_gmux_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw reg_hmux tile]

  ---------|---------|---------|---------   

                                REG_HMUX_B[3,1]
                                REG_HMUX_A[3,0]
  ---------|---------|---------|---------  

  Revision History:

*****************************************************************************************/
function draw_reg_hmux_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef,yRef;              
    string strVar_w,strVar_e;                           
    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device REG_HMUX  @[lsx+3,lsy]     of ARCHITECTURE>;
    sprintf(strVar_w, "REG_HMUX_W_%d_%d", lsx+3, lsy);  
    device REG_HMUX   ( symbol logsym_w ) *strVar_w  @[gsx-10,gsy+400];

    yRef  = <device REG_HMUX  @[lsx+3,lsy+1]     of ARCHITECTURE>;
    sprintf(strVar_e, "REG_HMUX_E_%d_%d", lsx+3, lsy); 
    device REG_HMUX   ( symbol logsym_e ) *strVar_e  @[gsx+1050,gsy+400];

    map 
    ( 
        <instance *strVar_w>   => xRef,
        <instance *strVar_e>   => yRef
    ); 
                                                                                  
}; // end of function draw_reg_hmux_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw reg_vmux_w tile]
  
  ---------|---------|---------|---------   
                                RCLK_BUF1[3,2]
                                RCLK_BUF0[3,1]
                                REG_VMUX[3,0]
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function draw_reg_vmux_w_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef, yRef, zRef;              
    string strVar0, strVar1, strVar2;
                               
    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device REG_VMUX  @[lsx+3,lsy]     of ARCHITECTURE>;
    sprintf(strVar0, "REG_VMUX_W_%d_%d", lsx+3, lsy);    
    device REG_VMUX   ( symbol logsym_w ) *strVar0  @[gsx+1190,gsy+800];
    
    yRef  = <device RCLK_BUF  @[lsx+3,lsy+1]     of ARCHITECTURE>;
    sprintf(strVar1, "RCLK_BUF_W0_%d_%d", lsx+3, lsy+1);    
    device RCLK_BUF ( symbol logsym_w ) *strVar1  @[gsx+1175,gsy+875]; 
    
    zRef  = <device RCLK_BUF  @[lsx+3,lsy+2]     of ARCHITECTURE>;
    sprintf(strVar2, "RCLK_BUF_W1_%d_%d", lsx+3, lsy+2);    
    device RCLK_BUF ( symbol logsym_w ) *strVar2  @[gsx+1175,gsy+915];         

    map 
    ( 
        <instance *strVar0>   => xRef,
        <instance *strVar1>   => yRef,
        <instance *strVar2>   => zRef                
    );                            
                                                         
}; // end of function draw_reg_vmux_w_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw reg_vmux_e tile]
  
  ---------|---------|---------|---------   
                                RCLK_BUF1[3,2]
                                RCLK_BUF0[3,1]
                                REG_VMUX[3,0]
  ---------|---------|---------|---------    
  

  Revision History:

*****************************************************************************************/
function draw_reg_vmux_e_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef, yRef, zRef;              
    string strVar0, strVar1, strVar2;     
                                
    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device REG_VMUX  @[lsx+3,lsy]     of ARCHITECTURE>;
    sprintf(strVar0, "REG_VMUX_E_%d_%d", lsx+3, lsy);        
    device REG_VMUX   ( symbol logsym_e ) *strVar0  @[gsx-150,gsy+800];

    yRef  = <device RCLK_BUF  @[lsx+3,lsy+1]     of ARCHITECTURE>;
    sprintf(strVar1, "RCLK_BUF_E0_%d_%d", lsx+3, lsy+1);    
    device RCLK_BUF ( symbol logsym_e ) *strVar1  @[gsx-90,gsy+875];   

    zRef  = <device RCLK_BUF  @[lsx+3,lsy+2]     of ARCHITECTURE>;
    sprintf(strVar2, "RCLK_BUF_E1_%d_%d", lsx+3, lsy+2);    
    device RCLK_BUF ( symbol logsym_e ) *strVar2  @[gsx-90,gsy+915]; 

    map 
    ( 
        <instance *strVar0>   => xRef,
        <instance *strVar1>   => yRef,
        <instance *strVar2>   => zRef 
    ); 
                                                                                    
}; // end of function draw_reg_vmux_e_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw ioclkgen_b tile]
  
  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
  IOCLKGATE4[0,2]  IOCLKGATE5[1,2]       
  IOCLKGATE0[0,1]  IOCLKGATE1[1,1]  IOCLKGATE2[2,1]  IOCLKGATE3[3,1]   USCMMUX2TO1[0,1] USCMMUX2TO1[1,1] USCMMUX2TO1[2,1] USCMMUX2TO1[3,1]
                   IOCLKMUX[1,0]                                       IOCLKDIV[0,0]   IOCLKDIV[1,0]   IOCLKDIV[2,0]   IOCLKDIV[3,0]
  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
                                      Tile 0                                                               Tile 1

  Revision History:

*****************************************************************************************/
function draw_ioclkgen_b_tile
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int flg
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsx1, gsx, lsy, gsy;

    // device reference variables
    &device xRef, g0Ref, g1Ref, g2Ref, g3Ref, g4Ref, g5Ref, 
            d0Ref, d1Ref, d2Ref, d3Ref, n0Ref, n1Ref, n2Ref, n3Ref;

    lsx = tx * TILE_NUM_SITE_X;
    lsx1 = (tx+1) * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;

    if(flg)
    {
        gsx = tx * TILE_NUM_GUI_GRID_X + 600;
        gsy = (ty-1) * TILE_NUM_GUI_GRID_Y;//right
    }
    else
    {
        gsx = tx * TILE_NUM_GUI_GRID_X + 300;
        gsy = ty * TILE_NUM_GUI_GRID_Y; //left
    }

    // Pull out the device instances from logic structure
    //
    xRef   = <device IOCLKMUX   @[lsx+1,lsy]      of ARCHITECTURE>;
    g0Ref  = <device IOCLKGATE  @[lsx,lsy+1]      of ARCHITECTURE>;
    g1Ref  = <device IOCLKGATE  @[lsx+1,lsy+1]    of ARCHITECTURE>;
    g2Ref  = <device IOCLKGATE  @[lsx+2,lsy+1]    of ARCHITECTURE>;
    g3Ref  = <device IOCLKGATE  @[lsx+3,lsy+1]    of ARCHITECTURE>;
    g4Ref  = <device IOCLKGATE  @[lsx,lsy+2]      of ARCHITECTURE>;
    g5Ref  = <device IOCLKGATE  @[lsx+1,lsy+2]    of ARCHITECTURE>;
 
    d0Ref  = <device IOCLKDIV   @[lsx1,lsy]       of ARCHITECTURE>;
    d1Ref  = <device IOCLKDIV   @[lsx1+1,lsy]     of ARCHITECTURE>;
    d2Ref  = <device IOCLKDIV   @[lsx1+2,lsy]     of ARCHITECTURE>;
    d3Ref  = <device IOCLKDIV   @[lsx1+3,lsy]     of ARCHITECTURE>;

    n0Ref  = <device USCMMUX2TO1 @[lsx1,lsy+1]     of ARCHITECTURE>;
    n1Ref  = <device USCMMUX2TO1 @[lsx1+1,lsy+1]   of ARCHITECTURE>;
    n2Ref  = <device USCMMUX2TO1 @[lsx1+2,lsy+1]   of ARCHITECTURE>;
    n3Ref  = <device USCMMUX2TO1 @[lsx1+3,lsy+1]   of ARCHITECTURE>;
    
    // Instantiate the schematic. 
    device IOCLKGEN_TILE ( schematic ioclkgen_n_schm ) 
        instance map
            (
                <symbol IOCLKMUX   @[50,10]>  => xRef,
                
                <symbol IOCLKGATE  @[70,60]>  => g0Ref,
                <symbol IOCLKGATE  @[78,60]>  => g1Ref,
                <symbol IOCLKGATE  @[86,60]>  => g2Ref,
                <symbol IOCLKGATE  @[94,60]>  => g3Ref,
                <symbol IOCLKGATE  @[102,60]>  => g4Ref,
                <symbol IOCLKGATE  @[110,60]>  => g5Ref,                
                               
                <symbol IOCLKDIV   @[102,80]>  => d0Ref,
                <symbol IOCLKDIV   @[110,80]>  => d1Ref,
                <symbol IOCLKDIV   @[118,80]>  => d2Ref,
                <symbol IOCLKDIV   @[126,80]>  => d3Ref,
                
                <symbol USCMMUX2TO1 @[70,80]>  => n0Ref,
                <symbol USCMMUX2TO1 @[78,80]>  => n1Ref,
                <symbol USCMMUX2TO1 @[86,80]>  => n2Ref,
                <symbol USCMMUX2TO1 @[94,80]>  => n3Ref             
            )
        @[gsx,gsy+500];

}; // end of function draw_ioclkgen_b_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw ioclkgen_t tile]

  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
  IOCLKGATE4[0,2]  IOCLKGATE5[1,2]        
  IOCLKGATE0[0,1]  IOCLKGATE1[1,1]  IOCLKGATE2[2,1]  IOCLKGATE3[3,1]   USCMMUX2TO1[0,1] USCMMUX2TO1[1,1] USCMMUX2TO1[2,1] USCMMUX2TO1[3,1]
                   IOCLKMUX[1,0]                                       IOCLKDIV[0,0]   IOCLKDIV[1,0]   IOCLKDIV[2,0]   IOCLKDIV[3,0]
  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
                                      Tile 0                                                               Tile 1

  Revision History:

*****************************************************************************************/
function draw_ioclkgen_t_tile
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int flg
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsx1, gsx, lsy, gsy;

    // device reference variables
    &device xRef, g0Ref, g1Ref, g2Ref, g3Ref, g4Ref, g5Ref, 
            d0Ref, d1Ref, d2Ref, d3Ref, n0Ref, n1Ref, n2Ref, n3Ref;

    lsx = tx * TILE_NUM_SITE_X;
    lsx1 = (tx+1) * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;

    if(flg)
    {
        gsx = tx * TILE_NUM_GUI_GRID_X + 600;
        gsy = (ty+1) * TILE_NUM_GUI_GRID_Y;//right
    }
    else
    {
        gsx = tx * TILE_NUM_GUI_GRID_X + 300;
        gsy = ty * TILE_NUM_GUI_GRID_Y; //left
    }
    
    // Pull out the device instances from logic structure
    //
    xRef   = <device IOCLKMUX   @[lsx+1,lsy]      of ARCHITECTURE>;
    g0Ref  = <device IOCLKGATE  @[lsx,lsy+1]      of ARCHITECTURE>;
    g1Ref  = <device IOCLKGATE  @[lsx+1,lsy+1]    of ARCHITECTURE>;
    g2Ref  = <device IOCLKGATE  @[lsx+2,lsy+1]    of ARCHITECTURE>;
    g3Ref  = <device IOCLKGATE  @[lsx+3,lsy+1]    of ARCHITECTURE>;
    g4Ref  = <device IOCLKGATE  @[lsx,lsy+2]      of ARCHITECTURE>;
    g5Ref  = <device IOCLKGATE  @[lsx+1,lsy+2]    of ARCHITECTURE>;
      
    
    d0Ref  = <device IOCLKDIV   @[lsx1,lsy]       of ARCHITECTURE>;
    d1Ref  = <device IOCLKDIV   @[lsx1+1,lsy]     of ARCHITECTURE>;
    d2Ref  = <device IOCLKDIV   @[lsx1+2,lsy]     of ARCHITECTURE>;
    d3Ref  = <device IOCLKDIV   @[lsx1+3,lsy]     of ARCHITECTURE>;
                                                  
    n0Ref  = <device USCMMUX2TO1 @[lsx1,lsy+1]     of ARCHITECTURE>;
    n1Ref  = <device USCMMUX2TO1 @[lsx1+1,lsy+1]   of ARCHITECTURE>;
    n2Ref  = <device USCMMUX2TO1 @[lsx1+2,lsy+1]   of ARCHITECTURE>;
    n3Ref  = <device USCMMUX2TO1 @[lsx1+3,lsy+1]   of ARCHITECTURE>;   
    
    // Instantiate the schematic. 
    device IOCLKGEN_TILE ( schematic ioclkgen_s_schm ) 
        instance map
            (
                <symbol IOCLKMUX   @[50,160]>  => xRef,
                
                <symbol IOCLKGATE  @[70,140]>  => g0Ref,
                <symbol IOCLKGATE  @[78,140]>  => g1Ref,
                <symbol IOCLKGATE  @[86,140]>  => g2Ref,
                <symbol IOCLKGATE  @[94,140]>  => g3Ref,
                <symbol IOCLKGATE  @[102,140]>  => g4Ref,
                <symbol IOCLKGATE  @[110,140]>  => g5Ref,
                               
                <symbol IOCLKDIV   @[102,120]>  => d0Ref,
                <symbol IOCLKDIV   @[110,120]>  => d1Ref,
                <symbol IOCLKDIV   @[118,120]>  => d2Ref,
                <symbol IOCLKDIV   @[126,120]>  => d3Ref,
                
                <symbol USCMMUX2TO1 @[70,120]>  => n0Ref,
                <symbol USCMMUX2TO1 @[78,120]>  => n1Ref,
                <symbol USCMMUX2TO1 @[86,120]>  => n2Ref,
                <symbol USCMMUX2TO1 @[94,120]>  => n3Ref    
            )
        @[gsx,gsy+400];

}; // end of function draw_ioclkgen_t_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw ioclkgen_r tile]
  
  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
  IOCLKGATE4[0,2]  IOCLKGATE5[1,2]  IOCLKGATE6[2,2]  IOCLKGATE7[3,2]      
  IOCLKGATE0[0,1]  IOCLKGATE1[1,1]  IOCLKGATE2[2,1]  IOCLKGATE3[3,1]   USCMMUX2TO1[0,1] USCMMUX2TO1[1,1] USCMMUX2TO1[2,1] USCMMUX2TO1[3,1]
                   IOCLKMUX[1,0]                                       IOCLKDIV[0,0]   IOCLKDIV[1,0]   IOCLKDIV[2,0]   IOCLKDIV[3,0]
  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
                                      Tile 0                                                               Tile 1 
  

  Revision History:

*****************************************************************************************/
function draw_ioclkgen_r_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsx1, gsx, lsy, gsy;

    // device reference variables
    &device xRef, g0Ref, g1Ref, g2Ref, g3Ref, g4Ref, g5Ref, g6Ref, g7Ref,
            d0Ref, d1Ref, d2Ref, d3Ref, n0Ref, n1Ref, n2Ref, n3Ref;

    lsx = tx * TILE_NUM_SITE_X;
    lsx1 = (tx+1) * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef   = <device IOCLKMUX   @[lsx+1,lsy]      of ARCHITECTURE>;
    g0Ref  = <device IOCLKGATE  @[lsx,lsy+1]      of ARCHITECTURE>;
    g1Ref  = <device IOCLKGATE  @[lsx+1,lsy+1]    of ARCHITECTURE>;
    g2Ref  = <device IOCLKGATE  @[lsx+2,lsy+1]    of ARCHITECTURE>;
    g3Ref  = <device IOCLKGATE  @[lsx+3,lsy+1]    of ARCHITECTURE>;
    g4Ref  = <device IOCLKGATE  @[lsx,lsy+2]      of ARCHITECTURE>;
    g5Ref  = <device IOCLKGATE  @[lsx+1,lsy+2]    of ARCHITECTURE>;
    g6Ref  = <device IOCLKGATE  @[lsx+2,lsy+2]    of ARCHITECTURE>;
    g7Ref  = <device IOCLKGATE  @[lsx+3,lsy+2]    of ARCHITECTURE>;    
    
    d0Ref  = <device IOCLKDIV   @[lsx1,lsy]       of ARCHITECTURE>;
    d1Ref  = <device IOCLKDIV   @[lsx1+1,lsy]     of ARCHITECTURE>;
    d2Ref  = <device IOCLKDIV   @[lsx1+2,lsy]     of ARCHITECTURE>;
    d3Ref  = <device IOCLKDIV   @[lsx1+3,lsy]     of ARCHITECTURE>;
                                                  
    n0Ref  = <device USCMMUX2TO1 @[lsx1,lsy+1]     of ARCHITECTURE>;
    n1Ref  = <device USCMMUX2TO1 @[lsx1+1,lsy+1]   of ARCHITECTURE>;
    n2Ref  = <device USCMMUX2TO1 @[lsx1+2,lsy+1]   of ARCHITECTURE>;
    n3Ref  = <device USCMMUX2TO1 @[lsx1+3,lsy+1]   of ARCHITECTURE>;   
    
    
    // Instantiate the schematic. 
    device IOCLKGEN_TILE ( schematic ioclkgen_w_schm ) 
        instance map
            (
                <symbol IOCLKMUX   @[160,50]>  => xRef,
                
                <symbol IOCLKGATE  @[140,70]>  => g0Ref,
                <symbol IOCLKGATE  @[140,78]>  => g1Ref,
                <symbol IOCLKGATE  @[140,86]>  => g2Ref,
                <symbol IOCLKGATE  @[140,94]>  => g3Ref,
                <symbol IOCLKGATE  @[140,102]>  => g4Ref,
                <symbol IOCLKGATE  @[140,110]>  => g5Ref,
                <symbol IOCLKGATE  @[140,118]>  => g6Ref,
                <symbol IOCLKGATE  @[140,126]>  => g7Ref, 
                               
                <symbol IOCLKDIV   @[120,102]>  => d0Ref,
                <symbol IOCLKDIV   @[120,110]>  => d1Ref,
                <symbol IOCLKDIV   @[120,118]>  => d2Ref,
                <symbol IOCLKDIV   @[120,126]>  => d3Ref,
                                     
                <symbol USCMMUX2TO1 @[120,70]>  => n0Ref,
                <symbol USCMMUX2TO1 @[120,78]>  => n1Ref,
                <symbol USCMMUX2TO1 @[120,86]>  => n2Ref,
                <symbol USCMMUX2TO1 @[120,94]>  => n3Ref               
            )
        @[gsx+850,gsy+1050];
    


}; // end of function draw_ioclkgen_r_tile

/**VFunction******************************************************************************

  Author    [xiawei]

  Abstract  [Draw ioclkgen_l tile]
  
  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
        
  IOCLKGATE0[0,1]  IOCLKGATE1[1,1]  IOCLKGATE2[2,1]  IOCLKGATE3[3,1]   USCMMUX2TO1[0,1] USCMMUX2TO1[1,1] USCMMUX2TO1[2,1] USCMMUX2TO1[3,1]
                   IOCLKMUX[1,0]                                       IOCLKDIV[0,0]   IOCLKDIV[1,0]   IOCLKDIV[2,0]   IOCLKDIV[3,0]
  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
                                      Tile 0                                                               Tile 1 
  

  Revision History:

*****************************************************************************************/
function draw_ioclkgen_l_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsx1, gsx, lsy, gsy;

    // device reference variables
    &device xRef, g0Ref, g1Ref, g2Ref, g3Ref, 
            d0Ref, d1Ref, d2Ref, d3Ref, n0Ref, n1Ref, n2Ref, n3Ref;

    lsx = tx * TILE_NUM_SITE_X;
    lsx1 = (tx+1) * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef   = <device IOCLKMUX   @[lsx+1,lsy]      of ARCHITECTURE>;
    g0Ref  = <device IOCLKGATE  @[lsx,lsy+1]      of ARCHITECTURE>;
    g1Ref  = <device IOCLKGATE  @[lsx+1,lsy+1]    of ARCHITECTURE>;
    g2Ref  = <device IOCLKGATE  @[lsx+2,lsy+1]    of ARCHITECTURE>;
    g3Ref  = <device IOCLKGATE  @[lsx+3,lsy+1]    of ARCHITECTURE>;
    
    d0Ref  = <device IOCLKDIV   @[lsx1,lsy]       of ARCHITECTURE>;
    d1Ref  = <device IOCLKDIV   @[lsx1+1,lsy]     of ARCHITECTURE>;
    d2Ref  = <device IOCLKDIV   @[lsx1+2,lsy]     of ARCHITECTURE>;
    d3Ref  = <device IOCLKDIV   @[lsx1+3,lsy]     of ARCHITECTURE>;
                                                  
    n0Ref  = <device USCMMUX2TO1 @[lsx1,lsy+1]     of ARCHITECTURE>;
    n1Ref  = <device USCMMUX2TO1 @[lsx1+1,lsy+1]   of ARCHITECTURE>;
    n2Ref  = <device USCMMUX2TO1 @[lsx1+2,lsy+1]   of ARCHITECTURE>;
    n3Ref  = <device USCMMUX2TO1 @[lsx1+3,lsy+1]   of ARCHITECTURE>;   
    
    
    // Instantiate the schematic. 
    device IOCLKGEN_TILE ( schematic ioclkgen_e_schm ) 
        instance map
            (
                <symbol IOCLKMUX   @[40,50]>  => xRef,
                
                <symbol IOCLKGATE  @[90,70]>  => g0Ref,
                <symbol IOCLKGATE  @[90,78]>  => g1Ref,
                <symbol IOCLKGATE  @[90,86]>  => g2Ref,
                <symbol IOCLKGATE  @[90,94]>  => g3Ref,
                
                               
                <symbol IOCLKDIV   @[110,102]>  => d0Ref,
                <symbol IOCLKDIV   @[110,110]>  => d1Ref,
                <symbol IOCLKDIV   @[110,118]>  => d2Ref,
                <symbol IOCLKDIV   @[110,126]>  => d3Ref,
                                     
                <symbol USCMMUX2TO1 @[110,70]>  => n0Ref,
                <symbol USCMMUX2TO1 @[110,78]>  => n1Ref,
                <symbol USCMMUX2TO1 @[110,86]>  => n2Ref,
                <symbol USCMMUX2TO1 @[110,94]>  => n3Ref               
            )
        @[gsx,gsy+900];
    


}; // end of function draw_ioclkgen_l_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw ioclk_bridge tile]

  ------------|---------------|---------------|-------------   
 
 
  IOCLK_BRI[0,0]
  ------------|---------------|---------------|-------------  

  Revision History:

*****************************************************************************************/
function draw_ioclk_bridge_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef;              
                                
    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device IOCLK_BRIDGE  @[lsx,lsy]     of ARCHITECTURE>;
    device IOCLK_BRIDGE   ( symbol logsym ) IOCLK_BRIDGE  @[gsx-40,gsy+1060];

    map 
    ( 
        <instance IOCLK_BRIDGE>   => xRef
    ); 
                                                                                   
}; // end of function draw_ioclk_bridge_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw uscm_w tile]
  
  ------------|---------------|---------------|-------------   

    USCM[0,1]      USCM[1,1]       USCM[2,1]       
    USCM[0,0]      USCM[1,0]       USCM[2,0]        USCM[3,0]
  ------------|---------------|---------------|-------------    

  Revision History:

*****************************************************************************************/
function draw_uscm_w_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, lsy1, gsy;

    // device reference variables
    &device d0Ref, d1Ref, d2Ref, d3Ref, d4Ref, d5Ref, d6Ref, d7Ref, d8Ref, d9Ref, d10Ref, d11Ref, d12Ref, d13Ref;

    lsx = tx * TILE_NUM_SITE_X;  
    lsy = ty * TILE_NUM_SITE_Y;
    lsy1 = (ty+1) * TILE_NUM_SITE_Y;  
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    d0Ref   = <device  USCM  @[lsx,lsy]        of ARCHITECTURE>;
    d1Ref   = <device  USCM  @[lsx+1,lsy]      of ARCHITECTURE>;
    d2Ref   = <device  USCM  @[lsx+2,lsy]      of ARCHITECTURE>;
    d3Ref   = <device  USCM  @[lsx+3,lsy]      of ARCHITECTURE>;
    d4Ref   = <device  USCM  @[lsx,lsy+1]      of ARCHITECTURE>;
    d5Ref   = <device  USCM  @[lsx+1,lsy+1]    of ARCHITECTURE>;
    d6Ref   = <device  USCM  @[lsx+2,lsy+1]    of ARCHITECTURE>;
    d7Ref   = <device  USCM  @[lsx,lsy1]       of ARCHITECTURE>;
    d8Ref   = <device  USCM  @[lsx+1,lsy1]     of ARCHITECTURE>;
    d9Ref   = <device  USCM  @[lsx+2,lsy1]     of ARCHITECTURE>;
    d10Ref  = <device  USCM  @[lsx+3,lsy1]     of ARCHITECTURE>;
    d11Ref  = <device  USCM  @[lsx,lsy1+1]     of ARCHITECTURE>;
    d12Ref  = <device  USCM  @[lsx+1,lsy1+1]   of ARCHITECTURE>;
    d13Ref  = <device  USCM  @[lsx+2,lsy1+1]   of ARCHITECTURE>;    
    
    
    

    
    // Instantiate the schematic. 
    device USCM_TILE ( schematic uscm_schm_w ) 
        instance map
            (
                <symbol USCM  @[300,10]>   => d7Ref,
                <symbol USCM  @[300,40]>   => d8Ref,
                <symbol USCM  @[300,70]>   => d9Ref,
                <symbol USCM  @[300,100]>  => d10Ref,
                <symbol USCM  @[300,130]>  => d11Ref,
                <symbol USCM  @[300,160]>  => d12Ref,
                <symbol USCM  @[300,190]>  => d13Ref,
                <symbol USCM  @[300,220]>  => d0Ref,
                <symbol USCM  @[300,250]>  => d1Ref,
                <symbol USCM  @[300,280]>  => d2Ref,
                <symbol USCM  @[300,310]>  => d3Ref,
                <symbol USCM  @[300,340]>  => d4Ref,
                <symbol USCM  @[300,370]>  => d5Ref,
                <symbol USCM  @[300,400]>  => d6Ref                                
            )
        @[gsx-120,gsy+400];

}; // end of function draw_uscm_w_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw uscm_e tile]
  
  ------------|---------------|---------------|-------------   
  
    USCM[0,1]      USCM[1,1]       USCM[2,1]       
    USCM[0,0]      USCM[1,0]       USCM[2,0]        USCM[3,0]
  ------------|---------------|---------------|-------------  

  Revision History:

*****************************************************************************************/
function draw_uscm_e_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, lsy1, gsy;

    // device reference variables
    &device d0Ref, d1Ref, d2Ref, d3Ref, d4Ref, d5Ref, d6Ref, d7Ref, d8Ref, d9Ref, d10Ref, d11Ref, d12Ref, d13Ref;

    lsx = tx * TILE_NUM_SITE_X;  
    lsy = ty * TILE_NUM_SITE_Y;
    lsy1 = (ty+1) * TILE_NUM_SITE_Y;  
    gsx = tx * TILE_NUM_GUI_GRID_X;
   gsy = (ty+2) * TILE_NUM_GUI_GRID_Y;
   //  gsy = ty * TILE_NUM_GUI_GRID_Y;
    // Pull out the device instances from logic structure
    //
    d0Ref   = <device  USCM  @[lsx,lsy]        of ARCHITECTURE>;
    d1Ref   = <device  USCM  @[lsx+1,lsy]      of ARCHITECTURE>;
    d2Ref   = <device  USCM  @[lsx+2,lsy]      of ARCHITECTURE>;
    d3Ref   = <device  USCM  @[lsx+3,lsy]      of ARCHITECTURE>;
    d4Ref   = <device  USCM  @[lsx,lsy+1]      of ARCHITECTURE>;
    d5Ref   = <device  USCM  @[lsx+1,lsy+1]    of ARCHITECTURE>;
    d6Ref   = <device  USCM  @[lsx+2,lsy+1]    of ARCHITECTURE>;
    d7Ref   = <device  USCM  @[lsx,lsy1]       of ARCHITECTURE>;
    d8Ref   = <device  USCM  @[lsx+1,lsy1]     of ARCHITECTURE>;
    d9Ref   = <device  USCM  @[lsx+2,lsy1]     of ARCHITECTURE>;
    d10Ref  = <device  USCM  @[lsx+3,lsy1]     of ARCHITECTURE>;
    d11Ref  = <device  USCM  @[lsx,lsy1+1]     of ARCHITECTURE>;
    d12Ref  = <device  USCM  @[lsx+1,lsy1+1]   of ARCHITECTURE>;
    d13Ref  = <device  USCM  @[lsx+2,lsy1+1]   of ARCHITECTURE>;    
    
    // Instantiate the schematic. 
    device USCM_TILE ( schematic uscm_schm_e ) 
        instance map
            (
                <symbol USCM  @[300,10]>   => d7Ref, 
                <symbol USCM  @[300,40]>   => d8Ref, 
                <symbol USCM  @[300,70]>   => d9Ref, 
                <symbol USCM  @[300,100]>  => d10Ref,
                <symbol USCM  @[300,130]>  => d11Ref,
                <symbol USCM  @[300,160]>  => d12Ref,
                <symbol USCM  @[300,190]>  => d13Ref,
                <symbol USCM  @[300,220]>  => d0Ref, 
                <symbol USCM  @[300,250]>  => d1Ref, 
                <symbol USCM  @[300,280]>  => d2Ref, 
                <symbol USCM  @[300,310]>  => d3Ref, 
                <symbol USCM  @[300,340]>  => d4Ref, 
                <symbol USCM  @[300,370]>  => d5Ref, 
                <symbol USCM  @[300,400]>  => d6Ref               
            )
        @[gsx+600,gsy+400];

}; // end of function draw_uscm_e_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw start tile]

  ------------|---------------|---------------|-------------   
 
 
                                                START[3,0]
  ------------|---------------|---------------|-------------  

  Revision History:

*****************************************************************************************/
function draw_start_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef;              
                                
    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device START  @[lsx+3,lsy]     of ARCHITECTURE>;
    device START   ( symbol logsym ) START  @[gsx+900,gsy+390];

    map 
    ( 
        <instance START>   => xRef
    ); 
                                                                                   
}; // end of function draw_start_tile



/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw grs tile]
                                                 GRS[3,1]
  ------------|---------------|---------------|-------------   
 
 
                                                
  ------------|---------------|---------------|-------------  

  Revision History:

*****************************************************************************************/
function draw_grs_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef;              
                                
    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device GRS  @[lsx+3,lsy+1] of ARCHITECTURE>;
    device GRS ( symbol logsym ) GRS  @[gsx+900,gsy+600];

    map 
    ( 
        <instance GRS>   => xRef
    ); 
                                                                                   
}; // end of function draw_grs_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw osc tile]
                                                 
  ------------|---------------|---------------|-------------   
 
 
                                                OSC[3,0]
  ------------|---------------|---------------|-------------  

  Revision History:

*****************************************************************************************/
function draw_osc_tile
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef;              
                                
    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device OSC  @[lsx+3,lsy] of ARCHITECTURE>;
    device OSC ( symbol logsym ) OSC  @[gsx+900,gsy+400];

    map 
    ( 
        <instance OSC>   => xRef
    ); 
                                                                                   
}; // end of function draw_osc_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw efusecode tile]

  ------------|---------------|---------------|-------------   
 
 
                                               EFUSECODE[3,0]
  ------------|---------------|---------------|-------------  

  Revision History:

*****************************************************************************************/
function draw_efusecode_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef;              
                                
    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device EFUSECODE  @[lsx+3,lsy]     of ARCHITECTURE>;
    device EFUSECODE   ( symbol logsym ) EFUSECODE  @[gsx+900,gsy+300];

    map 
    ( 
        <instance EFUSECODE>   => xRef
    ); 
                                                                                   
}; // end of function draw_efusecode_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw scanchain0 tile]

  ------------|---------------|---------------|-------------   
 
 
                                               SCANCHAIN1[3,1]
                                               SCANCHAIN0[3,0]
  ------------|---------------|---------------|-------------  

  Revision History:

*****************************************************************************************/
function draw_scanchain0_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef, yRef;              
                                
    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device SCANCHAIN  @[lsx+3,lsy]     of ARCHITECTURE>;
    device SCANCHAIN   ( symbol logsym_0 ) SCANCHAIN_0  @[gsx+900,gsy+300];
    
    yRef  = <device SCANCHAIN  @[lsx+3,lsy+1]     of ARCHITECTURE>;
    device SCANCHAIN   ( symbol logsym_1 ) SCANCHAIN_1  @[gsx+900,gsy+700];    

    map 
    ( 
        <instance SCANCHAIN_0>   => xRef,
        <instance SCANCHAIN_1>   => yRef        
    ); 
                                                                                   
}; // end of function draw_scanchain0_tile

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw scanchain1 tile]

  ------------|---------------|---------------|-------------   
 
 
                                               SCANCHAIN3[3,1]
                                               SCANCHAIN2[3,0]
  ------------|---------------|---------------|-------------  

  Revision History:

*****************************************************************************************/
function draw_scanchain1_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef, yRef;              
                                
    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device SCANCHAIN  @[lsx+3,lsy]     of ARCHITECTURE>;
    device SCANCHAIN   ( symbol logsym_0 ) SCANCHAIN_2  @[gsx+900,gsy+300];
    
    yRef  = <device SCANCHAIN  @[lsx+3,lsy+1]     of ARCHITECTURE>;
    device SCANCHAIN   ( symbol logsym_1 ) SCANCHAIN_3  @[gsx+900,gsy+700];    

    map 
    ( 
        <instance SCANCHAIN_2>   => xRef,
        <instance SCANCHAIN_3>   => yRef        
    ); 
                                                                                   
}; // end of function draw_scanchain1_tile



/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw ipal tile]

  ------------|---------------|---------------|-------------   
 
 
                                               IPAL[3,0]
  ------------|---------------|---------------|-------------  

  Revision History:

*****************************************************************************************/
function draw_ipal_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef;              
                                
    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device IPAL  @[lsx+3,lsy]     of ARCHITECTURE>;
    device IPAL   ( symbol logsym ) IPAL  @[gsx+900,gsy+1500];

    map 
    ( 
        <instance IPAL>   => xRef
    ); 
                                                                                   
}; // end of function draw_ipal_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw clk_delay tile]

  ------------|---------------|---------------|-------------   
 
                                               DELAYCODEMUX[3,2]
                                               CLKDELAY[3,1]
                                               CLKDELAYMUX[3,0]
  ------------|---------------|---------------|-------------  

  Revision History:

*****************************************************************************************/
function draw_clk_delay_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device xRef, yRef, zRef;              
    string clkdelaymux,clkdelay,delaycodemux;                                 
    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
    //
    xRef  = <device CLKDELAYMUX  @[lsx+3,lsy]     of ARCHITECTURE>;
    sprintf(clkdelaymux, "clkdelaymux_%d_%d", lsx+3, lsy);  
    device CLKDELAYMUX   ( symbol logsym ) *clkdelaymux  @[gsx+976,gsy+308];
    
    yRef  = <device CLKDELAY  @[lsx+3,lsy+1]     of ARCHITECTURE>; 
    sprintf(clkdelay, "clkdelay_%d_%d", lsx+3, lsy+1);      
    device CLKDELAY   ( symbol logsym ) *clkdelay  @[gsx+984,gsy+328];  
    
    zRef  = <device DELAYCODEMUX  @[lsx+3,lsy+2]     of ARCHITECTURE>;     
    sprintf(delaycodemux, "delaycodemux_%d_%d", lsx+3, lsy+2);                 
    device DELAYCODEMUX   ( symbol logsym ) *delaycodemux  @[gsx+1040,gsy+338]; 
      

    map 
    ( 
        <instance *clkdelaymux>       => xRef,
        <instance *clkdelay>          => yRef,
        <instance *delaycodemux>      => zRef         
    ); 
                                                                                   
}; // end of function draw_clk_delay_tile


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw clk_buf tile]

  ------------|---------------|---------------|-------------   
 
 
                CLK_BUF[1,1]    
  ------------|---------------|---------------|-------------  

  Revision History:

*****************************************************************************************/
function draw_clk_buf_tile
( 
    unsigned int tx,
    unsigned int ty
)
{ 
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device yRef;              
    string clkbuf;                                
    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_GUI_GRID_X;
    gsy = ty * TILE_NUM_GUI_GRID_Y;

    // Pull out the device instances from logic structure
        
    yRef  = <device CLK_BUF  @[lsx+1,lsy+1]     of ARCHITECTURE>;   
    sprintf(clkbuf, "clkbuf_%d_%d", lsx+1, lsy+1);       
    device CLK_BUF   ( symbol logsym ) *clkbuf  @[gsx+680,gsy+750];    

    map 
    ( 
        <instance *clkbuf>   => yRef        
    ); 
                                                                                   
}; // end of function draw_clk_buf_tile


}; // end of package pango_schm_funcs


