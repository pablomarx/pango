USE pango_defs;
package pgh_funcs
{

/**VFunction******************************************************************************

  Author    [XiaWei]

  Abstract  [This function places HSST within a logic tile @[tx,ty].
             The logic tile include HSST.
             The logic layout inside of a tile is as followings,

              ---------|---------|---------|---------
                       CKN[0,1]  CKP[1,1]

                                                     TILE 4 
              ---------|---------|---------|---------
                       TXN[0,1]  TXP[1,1]  RXN[2,1]  RXP[3,1]

                                                     TILE 3 
              ---------|---------|---------|---------
                       TXN[0,1]  TXP[1,1]  RXN[2,1]  RXP[3,1]

                                                     TILE 2 
              ---------|---------|---------|---------
                       TXN[0,1]  TXP[1,1]  RXN[2,1]  RXP[3,1]

                                                     TILE 1 
              ---------|---------|---------|---------
                       TXN[0,1]  TXP[1,1]  RXN[2,1]  RXP[3,1]

                       HSST[1,0]                TILE 0 
              ---------|---------|---------|---------

  Revision History:

*****************************************************************************************/
function place_hsst_tile ( unsigned int tx, ty )
{

    string strVar;

    // Site index variable
    unsigned int sx, sy;

    // Calculate the site coordinate of the lower-left corner
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;        

    // TO CIM
    sprintf(strVar, "ntL0TXN_%d_%d", sx+1, sy);
    &wire ntRef_ntL0TXN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntL0TXP_%d_%d", sx+1, sy);
    &wire ntRef_ntL0TXP = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRDATA_0_%d_%d", sx+1, sy);
    &wire ntRef_ntRDATA_0[46:0] = wire *strVar[46:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_ALOS_STA_0_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_ALOS_STA_0 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_CDR_ALIGN_0_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_CDR_ALIGN_0 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_LFO_0_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_LFO_0 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_OOB_STA_0_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_OOB_STA_0 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_RXDCT_DONE_0_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_RXDCT_DONE_0 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_RXDCT_OUT_0_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_RXDCT_OUT_0 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntL1TXN_%d_%d", sx+1, sy);
    &wire ntRef_ntL1TXN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntL1TXP_%d_%d", sx+1, sy);
    &wire ntRef_ntL1TXP = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRDATA_1_%d_%d", sx+1, sy);
    &wire ntRef_ntRDATA_1[46:0] = wire *strVar[46:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_ALOS_STA_1_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_ALOS_STA_1 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_CDR_ALIGN_1_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_CDR_ALIGN_1 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_LFO_1_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_LFO_1 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_OOB_STA_1_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_OOB_STA_1 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_RXDCT_DONE_1_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_RXDCT_DONE_1 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_RXDCT_OUT_1_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_RXDCT_OUT_1 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntL2TXN_%d_%d", sx+1, sy);
    &wire ntRef_ntL2TXN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntL2TXP_%d_%d", sx+1, sy);
    &wire ntRef_ntL2TXP = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRDATA_2_%d_%d", sx+1, sy);
    &wire ntRef_ntRDATA_2[46:0] = wire *strVar[46:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_ALOS_STA_2_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_ALOS_STA_2 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_CDR_ALIGN_2_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_CDR_ALIGN_2 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_LFO_2_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_LFO_2 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_OOB_STA_2_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_OOB_STA_2 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_RXDCT_DONE_2_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_RXDCT_DONE_2 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_RXDCT_OUT_2_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_RXDCT_OUT_2 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntL3TXN_%d_%d", sx+1, sy);
    &wire ntRef_ntL3TXN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntL3TXP_%d_%d", sx+1, sy);
    &wire ntRef_ntL3TXP = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRDATA_3_%d_%d", sx+1, sy);
    &wire ntRef_ntRDATA_3[46:0] = wire *strVar[46:0];
    
    sprintf(strVar, "ntLX_ALOS_STA_3_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_ALOS_STA_3 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_CDR_ALIGN_3_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_CDR_ALIGN_3 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_LFO_3_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_LFO_3 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_OOB_STA_3_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_OOB_STA_3 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_RXDCT_DONE_3_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_RXDCT_DONE_3 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntLX_RXDCT_OUT_3_%d_%d", sx+1, sy);
    &wire ntRef_ntLX_RXDCT_OUT_3 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntCLK2CORE_RX_%d_%d", sx+1, sy);
    &wire ntRef_ntCLK2CORE_RX[3:0] = wire *strVar[3:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntALIGN_TX_%d_%d", sx+1, sy);
    &wire ntRef_ntALIGN_TX[3:0] = wire *strVar[3:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntALIGN_RX_%d_%d", sx+1, sy);
    &wire ntRef_ntALIGN_RX[3:0] = wire *strVar[3:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntCLK2CORE_TX_%d_%d", sx+1, sy);
    &wire ntRef_ntCLK2CORE_TX[3:0] = wire *strVar[3:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntPCS_RX_MCB_STATUS_%d_%d", sx+1, sy);
    &wire ntRef_ntPCS_RX_MCB_STATUS[3:0] = wire *strVar[3:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntPCS_LSM_SYNCED_%d_%d", sx+1, sy);
    &wire ntRef_ntPCS_LSM_SYNCED[3:0] = wire *strVar[3:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntREXT_%d_%d", sx+1, sy);
    &wire ntRef_ntREXT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTEST_SO0_%d_%d", sx+1, sy);
    &wire ntRef_ntTEST_SO0 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTEST_SO1_%d_%d", sx+1, sy);
    &wire ntRef_ntTEST_SO1 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTEST_SO2_%d_%d", sx+1, sy);
    &wire ntRef_ntTEST_SO2 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTEST_SO3_%d_%d", sx+1, sy);
    &wire ntRef_ntTEST_SO3 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTEST_SO4_%d_%d", sx+1, sy);
    &wire ntRef_ntTEST_SO4 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTEST_SO5_%d_%d", sx+1, sy);
    &wire ntRef_ntTEST_SO5 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTEST_SO6_%d_%d", sx+1, sy);
    &wire ntRef_ntTEST_SO6 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTEST_SO7_%d_%d", sx+1, sy);
    &wire ntRef_ntTEST_SO7 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntCFG_INT_%d_%d", sx+1, sy);
    &wire ntRef_ntCFG_INT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntCFG_READY_%d_%d", sx+1, sy);
    &wire ntRef_ntCFG_READY = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntCFG_RDATA_%d_%d", sx+1, sy);
    &wire ntRef_ntCFG_RDATA[7:0] = wire *strVar[7:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntAFTER_CTC_RCLK_EN_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntAFTER_CTC_RCLK_EN_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntAFTER_CTC_RCLK_EN_GB_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntAFTER_CTC_RCLK_EN_GB_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntAPATTERN_MATCH_LSB_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntAPATTERN_MATCH_LSB_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntAPATTERN_MATCH_MSB_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntAPATTERN_MATCH_MSB_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntAPATTERN_SEACHING_PROC_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntAPATTERN_SEACHING_PROC_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntAPATTERN_STATUS_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntAPATTERN_STATUS_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntBRIDGE_RCLK_EN_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntBRIDGE_RCLK_EN_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntBRIDGE_TCLK_EN_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntBRIDGE_TCLK_EN_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntCB_RCLK_EN_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntCB_RCLK_EN_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntPCS_TCLK_EN_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntPCS_TCLK_EN_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRFIFO_EN_AFTER_CTC_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntRFIFO_EN_AFTER_CTC_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRFIFO_EN_AFTER_CTC_GB_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntRFIFO_EN_AFTER_CTC_GB_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRFIFO_EN_BRIDGE_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntRFIFO_EN_BRIDGE_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRFIFO_EN_CB_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntRFIFO_EN_CB_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntSKIP_ADD_LSB_MCB_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntSKIP_ADD_LSB_MCB_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntSKIP_ADD_MCB_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntSKIP_ADD_MCB_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntSKIP_DEL_LCB_MCB_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntSKIP_DEL_LCB_MCB_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntSKIP_DEL_MCB_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntSKIP_DEL_MCB_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntCTC_RD_FIFO_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntCTC_RD_FIFO_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTFIFO_EN_BRIDGE_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntTFIFO_EN_BRIDGE_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTFIFO_EN_PCS_TX_COUT_%d_%d", sx+1, sy);
    &wire ntRef_ntTFIFO_EN_PCS_TX_COUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntPLL_LOCK_%d_%d", sx+1, sy);
    &wire ntRef_ntPLL_LOCK = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntREFCK2CORE_%d_%d", sx+1, sy);
    &wire ntRef_ntREFCK2CORE = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntTSO_LS_OUT_%d_%d", sx+1, sy);
    &wire ntRef_ntTSO_LS_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntREFCK_2NMQ_%d_%d", sx+1, sy);
    &wire ntRef_ntREFCK_2NMQ = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntREFCK_2NPQ_%d_%d", sx+1, sy);
    &wire ntRef_ntREFCK_2NPQ = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    unsigned int tile_sx    = (tx + 8) * TILE_NUM_SITE_X;

    unsigned int tile_1_sy = (ty + 1) * TILE_NUM_SITE_Y;
    unsigned int tile_2_sy = (ty + 2) * TILE_NUM_SITE_Y;
    unsigned int tile_3_sy = (ty + 3) * TILE_NUM_SITE_Y;
    unsigned int tile_4_sy = (ty + 4) * TILE_NUM_SITE_Y;
    unsigned int tile_5_sy = (ty + 5) * TILE_NUM_SITE_Y;
    unsigned int tile_6_sy = (ty + 6) * TILE_NUM_SITE_Y;
    unsigned int tile_7_sy = (ty + 7) * TILE_NUM_SITE_Y;
    unsigned int tile_8_sy = (ty + 8) * TILE_NUM_SITE_Y;
    unsigned int tile_9_sy = (ty + 9) * TILE_NUM_SITE_Y;
    unsigned int tile_10_sy = (ty + 10) * TILE_NUM_SITE_Y;
    unsigned int tile_11_sy = (ty + 11) * TILE_NUM_SITE_Y;
    unsigned int tile_12_sy = (ty + 12) * TILE_NUM_SITE_Y;
    unsigned int tile_13_sy = (ty + 13) * TILE_NUM_SITE_Y;
    unsigned int tile_14_sy = (ty + 14) * TILE_NUM_SITE_Y;
    unsigned int tile_15_sy = (ty + 15) * TILE_NUM_SITE_Y;
    unsigned int tile_16_sy = (ty + 16) * TILE_NUM_SITE_Y;
    unsigned int tile_17_sy = (ty + 17) * TILE_NUM_SITE_Y;
    unsigned int tile_18_sy = (ty + 18) * TILE_NUM_SITE_Y;
    unsigned int tile_19_sy = (ty + 19) * TILE_NUM_SITE_Y;
    unsigned int tile_20_sy = (ty + 21) * TILE_NUM_SITE_Y;
    unsigned int tile_21_sy = (ty + 22) * TILE_NUM_SITE_Y;
    unsigned int tile_22_sy = (ty + 23) * TILE_NUM_SITE_Y;
    unsigned int tile_23_sy = (ty + 24) * TILE_NUM_SITE_Y;
    unsigned int tile_24_sy = (ty + 25) * TILE_NUM_SITE_Y;
    unsigned int tile_25_sy = (ty + 26) * TILE_NUM_SITE_Y;
    unsigned int tile_26_sy = (ty + 27) * TILE_NUM_SITE_Y;
    unsigned int tile_27_sy = (ty + 28) * TILE_NUM_SITE_Y;
    unsigned int tile_28_sy = (ty + 29) * TILE_NUM_SITE_Y;
    unsigned int tile_29_sy = (ty + 30) * TILE_NUM_SITE_Y;
    unsigned int tile_30_sy = (ty + 31) * TILE_NUM_SITE_Y;
    unsigned int tile_31_sy = (ty + 32) * TILE_NUM_SITE_Y;
    unsigned int tile_32_sy = (ty + 33) * TILE_NUM_SITE_Y;
    unsigned int tile_33_sy = (ty + 34) * TILE_NUM_SITE_Y;
    unsigned int tile_34_sy = (ty + 35) * TILE_NUM_SITE_Y;
    unsigned int tile_35_sy = (ty + 36) * TILE_NUM_SITE_Y;
    unsigned int tile_36_sy = (ty + 37) * TILE_NUM_SITE_Y;
    unsigned int tile_37_sy = (ty + 38) * TILE_NUM_SITE_Y;
    unsigned int tile_38_sy = (ty + 39) * TILE_NUM_SITE_Y;
    unsigned int tile_39_sy = (ty + 40) * TILE_NUM_SITE_Y;

    
    sprintf(strVar, "ntTX_%d_%d", sx+2, sy+1);
    &wire ntRef_ntRXN0 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    sprintf(strVar, "RXN_%d_%d", sx+2, sy+1);
    device HSST_PAD_R *strVar
        port map (
                    TX   =>  ntRef_ntRXN0
                 )
        @([sx+2, sy+1]);
    
    sprintf(strVar, "ntTX_%d_%d", sx+3, sy+1);
    &wire ntRef_ntRXP0 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    sprintf(strVar, "RXP_%d_%d", sx+3, sy+1);
    device HSST_PAD_R *strVar
        port map (
                    TX   =>  ntRef_ntRXP0
                 )
        @([sx+3, sy+1]);

    sprintf(strVar, "ntTX_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntRXN1 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    sprintf(strVar, "RXN_%d_%d", sx+2, tile_1_sy+1);
    device HSST_PAD_R *strVar
        port map (
                    TX   =>  ntRef_ntRXN1
                 )
        @([sx+2, tile_1_sy+1]);
    
    sprintf(strVar, "ntTX_%d_%d", sx+3, tile_1_sy+1);
    &wire ntRef_ntRXP1 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    sprintf(strVar, "RXP_%d_%d", sx+3, tile_1_sy+1);
    device HSST_PAD_R *strVar
        port map (
                    TX   =>  ntRef_ntRXP1
                 )
        @([sx+3, tile_1_sy+1]);

    sprintf(strVar, "ntTX_%d_%d", sx+2, tile_2_sy+1);
    &wire ntRef_ntRXN2 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    sprintf(strVar, "RXN_%d_%d", sx+2, tile_2_sy+1);
    device HSST_PAD_R *strVar
        port map (
                    TX   =>  ntRef_ntRXN2
                 )
        @([sx+2, tile_2_sy+1]);
    
    sprintf(strVar, "ntTX_%d_%d", sx+3, tile_2_sy+1);
    &wire ntRef_ntRXP2 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    sprintf(strVar, "RXP_%d_%d", sx+3, tile_2_sy+1);
    device HSST_PAD_R *strVar
        port map (
                    TX   =>  ntRef_ntRXP2
                 )
        @([sx+3, tile_2_sy+1]);

    sprintf(strVar, "ntTX_%d_%d", sx+2, tile_3_sy+1);
    &wire ntRef_ntRXN3 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    sprintf(strVar, "RXN_%d_%d", sx+2, tile_3_sy+1);
    device HSST_PAD_R *strVar
        port map (
                    TX   =>  ntRef_ntRXN3
                 )
        @([sx+2, tile_3_sy+1]);
    
    sprintf(strVar, "ntTX_%d_%d", sx+3, tile_3_sy+1);
    &wire ntRef_ntRXP3 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    sprintf(strVar, "RXP_%d_%d", sx+3, tile_3_sy+1);
    device HSST_PAD_R *strVar
        port map (
                    TX   =>  ntRef_ntRXP3
                 )
        @([sx+3, tile_3_sy+1]);
    
    sprintf(strVar, "ntTX_%d_%d", sx, tile_4_sy+1);
    &wire ntRef_ntCKN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    sprintf(strVar, "CKN_%d_%d", sx, tile_4_sy+1);
    device HSST_PAD_R *strVar
        port map (
                    TX   =>  ntRef_ntCKN
                 )
        @([sx, tile_4_sy+1]);
    
    sprintf(strVar, "ntTX_%d_%d", sx+1, tile_4_sy+1);
    &wire ntRef_ntCKP = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    sprintf(strVar, "CKP_%d_%d", sx+1, tile_4_sy+1);
    device HSST_PAD_R *strVar
        port map (
                    TX   =>  ntRef_ntCKP
                 )
        @([sx+1, tile_4_sy+1]);

    // Layout HSST and connect wires and tracks driven by it
    sprintf(strVar, "HSST_%d_%d", sx+1, sy);
    device HSST *strVar
        port map (
                    //output of HSST
                    L0TXN                         =>    ntRef_ntL0TXN,
                    L0TXP                         =>    ntRef_ntL0TXP,
                    RDATA_0                       =>    ntRef_ntRDATA_0,
                    LX_ALOS_STA_0                 =>    ntRef_ntLX_ALOS_STA_0,
                    LX_CDR_ALIGN_0                =>    ntRef_ntLX_CDR_ALIGN_0,
                    LX_LFO_0                      =>    ntRef_ntLX_LFO_0,
                    LX_OOB_STA_0                  =>    ntRef_ntLX_OOB_STA_0,
                    LX_RXDCT_DONE_0               =>    ntRef_ntLX_RXDCT_DONE_0,
                    LX_RXDCT_OUT_0                =>    ntRef_ntLX_RXDCT_OUT_0,
                    L1TXN                         =>    ntRef_ntL1TXN,
                    L1TXP                         =>    ntRef_ntL1TXP,
                    RDATA_1                       =>    ntRef_ntRDATA_1,
                    LX_ALOS_STA_1                 =>    ntRef_ntLX_ALOS_STA_1,
                    LX_CDR_ALIGN_1                =>    ntRef_ntLX_CDR_ALIGN_1,
                    LX_LFO_1                      =>    ntRef_ntLX_LFO_1,
                    LX_OOB_STA_1                  =>    ntRef_ntLX_OOB_STA_1,
                    LX_RXDCT_DONE_1               =>    ntRef_ntLX_RXDCT_DONE_1,
                    LX_RXDCT_OUT_1                =>    ntRef_ntLX_RXDCT_OUT_1,
                    L2TXN                         =>    ntRef_ntL2TXN,
                    L2TXP                         =>    ntRef_ntL2TXP,
                    RDATA_2                       =>    ntRef_ntRDATA_2,
                    LX_ALOS_STA_2                 =>    ntRef_ntLX_ALOS_STA_2,
                    LX_CDR_ALIGN_2                =>    ntRef_ntLX_CDR_ALIGN_2,
                    LX_LFO_2                      =>    ntRef_ntLX_LFO_2,
                    LX_OOB_STA_2                  =>    ntRef_ntLX_OOB_STA_2,
                    LX_RXDCT_DONE_2               =>    ntRef_ntLX_RXDCT_DONE_2,
                    LX_RXDCT_OUT_2                =>    ntRef_ntLX_RXDCT_OUT_2,
                    L3TXN                         =>    ntRef_ntL3TXN,
                    L3TXP                         =>    ntRef_ntL3TXP,
                    RDATA_3                       =>    ntRef_ntRDATA_3,
                    LX_ALOS_STA_3                 =>    ntRef_ntLX_ALOS_STA_3,
                    LX_CDR_ALIGN_3                =>    ntRef_ntLX_CDR_ALIGN_3,
                    LX_LFO_3                      =>    ntRef_ntLX_LFO_3,
                    LX_OOB_STA_3                  =>    ntRef_ntLX_OOB_STA_3,
                    LX_RXDCT_DONE_3               =>    ntRef_ntLX_RXDCT_DONE_3,
                    LX_RXDCT_OUT_3                =>    ntRef_ntLX_RXDCT_OUT_3,
                    CLK2CORE_RX                   =>    ntRef_ntCLK2CORE_RX,
                    ALIGN_TX                      =>    ntRef_ntALIGN_TX,
                    ALIGN_RX                      =>    ntRef_ntALIGN_RX,
                    CLK2CORE_TX                   =>    ntRef_ntCLK2CORE_TX,
                    PCS_RX_MCB_STATUS             =>    ntRef_ntPCS_RX_MCB_STATUS,
                    PCS_LSM_SYNCED                =>    ntRef_ntPCS_LSM_SYNCED,
                    REXT                          =>    ntRef_ntREXT,
                    TEST_SO0                      =>    ntRef_ntTEST_SO0,
                    TEST_SO1                      =>    ntRef_ntTEST_SO1,
                    TEST_SO2                      =>    ntRef_ntTEST_SO2,
                    TEST_SO3                      =>    ntRef_ntTEST_SO3,
                    TEST_SO4                      =>    ntRef_ntTEST_SO4,
                    TEST_SO5                      =>    ntRef_ntTEST_SO5,
                    TEST_SO6                      =>    ntRef_ntTEST_SO6,
                    TEST_SO7                      =>    ntRef_ntTEST_SO7,
                    CFG_INT                       =>    ntRef_ntCFG_INT,
                    CFG_READY                     =>    ntRef_ntCFG_READY,
                    CFG_RDATA                     =>    ntRef_ntCFG_RDATA,
                    AFTER_CTC_RCLK_EN_COUT        =>    ntRef_ntAFTER_CTC_RCLK_EN_COUT,
                    AFTER_CTC_RCLK_EN_GB_COUT     =>    ntRef_ntAFTER_CTC_RCLK_EN_GB_COUT,
                    APATTERN_MATCH_LSB_COUT       =>    ntRef_ntAPATTERN_MATCH_LSB_COUT,
                    APATTERN_MATCH_MSB_COUT       =>    ntRef_ntAPATTERN_MATCH_MSB_COUT,
                    APATTERN_SEACHING_PROC_COUT   =>    ntRef_ntAPATTERN_SEACHING_PROC_COUT,
                    APATTERN_STATUS_COUT          =>    ntRef_ntAPATTERN_STATUS_COUT,
                    BRIDGE_RCLK_EN_COUT           =>    ntRef_ntBRIDGE_RCLK_EN_COUT,
                    BRIDGE_TCLK_EN_COUT           =>    ntRef_ntBRIDGE_TCLK_EN_COUT,
                    CB_RCLK_EN_COUT               =>    ntRef_ntCB_RCLK_EN_COUT,
                    PCS_TCLK_EN_COUT              =>    ntRef_ntPCS_TCLK_EN_COUT,
                    RFIFO_EN_AFTER_CTC_COUT       =>    ntRef_ntRFIFO_EN_AFTER_CTC_COUT,
                    RFIFO_EN_AFTER_CTC_GB_COUT    =>    ntRef_ntRFIFO_EN_AFTER_CTC_GB_COUT,
                    RFIFO_EN_BRIDGE_COUT          =>    ntRef_ntRFIFO_EN_BRIDGE_COUT,
                    RFIFO_EN_CB_COUT              =>    ntRef_ntRFIFO_EN_CB_COUT,
                    SKIP_ADD_LSB_MCB_COUT         =>    ntRef_ntSKIP_ADD_LSB_MCB_COUT,
                    SKIP_ADD_MCB_COUT             =>    ntRef_ntSKIP_ADD_MCB_COUT,
                    SKIP_DEL_LCB_MCB_COUT         =>    ntRef_ntSKIP_DEL_LCB_MCB_COUT,
                    SKIP_DEL_MCB_COUT             =>    ntRef_ntSKIP_DEL_MCB_COUT,
                    CTC_RD_FIFO_COUT              =>    ntRef_ntCTC_RD_FIFO_COUT,
                    TFIFO_EN_BRIDGE_COUT          =>    ntRef_ntTFIFO_EN_BRIDGE_COUT,
                    TFIFO_EN_PCS_TX_COUT          =>    ntRef_ntTFIFO_EN_PCS_TX_COUT,
                    PLL_LOCK                      =>    ntRef_ntPLL_LOCK,
                    REFCK2CORE                    =>    ntRef_ntREFCK2CORE,
                    TSO_LS_OUT                    =>    ntRef_ntTSO_LS_OUT,
                    REFCK_2NMQ                   =>   ntRef_ntREFCK_2NMQ,  
                    REFCK_2NPQ                    =>   ntRef_ntREFCK_2NPQ,  

                    //CIM to HSST
                    CEB_ADETECT_EN[3]             =>    <wire S_ID1    of <device CIM @[tile_sx+3, tile_1_sy+2]>>    ,
                    PCS_WORD_ALIGN_EN[3]          =>    <wire S_ID0    of <device CIM @[tile_sx+3, tile_1_sy+2]>>    ,
                    RX_POLARITY_INVERT[3]         =>    <wire S_ID2    of <device CIM @[tile_sx+3, tile_1_sy+2]>>    ,
                    PCS_MCB_EXT_EN[3]             =>    <wire S_ID3    of <device CIM @[tile_sx+3, tile_1_sy+2]>>    ,
                    PCS_NEAREND_LOOP[3]           =>    <wire A_ID2    of <device CIM @[tile_sx+3, tile_1_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX3[4]        =>    <wire S_IC1    of <device CIM @[tile_sx+3, tile_1_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX3[5]        =>    <wire S_IC0    of <device CIM @[tile_sx+3, tile_1_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX3[6]        =>    <wire S_IC2    of <device CIM @[tile_sx+3, tile_1_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX3[7]        =>    <wire S_IC4    of <device CIM @[tile_sx+3, tile_1_sy+2]>>    ,
                    CIM_CLK_DYN_DLY_SEL_RX[3]     =>    <wire S_IC3    of <device CIM @[tile_sx+3, tile_1_sy+2]>>    ,
                    LX_RX_CKDIV_3[1]              =>    <wire A_IC2    of <device CIM @[tile_sx+3, tile_1_sy+2]>>    ,
                    LX_RX_CKDIV_3[0]              =>    <wire A_IC0    of <device CIM @[tile_sx+3, tile_1_sy+2]>>    ,
                    LX_RX_CKDIV_DYNSEL_3          =>    <wire A_IC1    of <device CIM @[tile_sx+3, tile_1_sy+2]>>    ,
                    CIM_CLK_START_ALIGN_RX[3]     =>    <wire S_IB1    of <device CIM @[tile_sx+3, tile_1_sy+2]>>    ,
                    RX_REF_CLK_3                  =>    <wire S_ICLK   of <device CIM @[tile_sx+3, tile_1_sy+2]>>    ,
                    RX_PMA_RSTN_3                 =>    <wire S_IRS    of <device CIM @[tile_sx+3, tile_1_sy+2]>>    ,
                    RX_PLL_RSTN_3                 =>    <wire A_IRS    of <device CIM @[tile_sx+3, tile_1_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX3[0]        =>    <wire A_ID3    of <device CIM @[tile_sx+3, tile_2_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX3[1]        =>    <wire A_ID0    of <device CIM @[tile_sx+3, tile_2_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX3[2]        =>    <wire A_ID1    of <device CIM @[tile_sx+3, tile_2_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX3[3]        =>    <wire S_ICE    of <device CIM @[tile_sx+3, tile_2_sy+2]>>    ,
                    RX3_CLK_FR_CORE               =>    <wire A_ICLK   of <device CIM @[tile_sx+3, tile_2_sy+2]>>    ,
                    PCS_RX_RSTN_3                 =>    <wire A_IRS    of <device CIM @[tile_sx+3, tile_2_sy+2]>>    ,
                    LX_EXTLB_EN[3]                =>    <wire A_IC4    of <device CIM @[tile_sx+3, tile_3_sy+2]>>    ,
                    LX_BISTLB_EN[3]               =>    <wire A_IC3    of <device CIM @[tile_sx+3, tile_3_sy+2]>>    ,
                    RX_LANE_POWERUP[3]            =>    <wire S_IB0    of <device CIM @[tile_sx+3, tile_3_sy+2]>>    ,
                    LX_TX_LFMODE[3]               =>    <wire A_ID2    of <device CIM @[tile_sx+3, tile_5_sy+2]>>    ,
                    TX_LANE_POWERUP[3]            =>    <wire S_IC4    of <device CIM @[tile_sx+3, tile_5_sy+2]>>    ,
                    LX_RXDCT_EN[3]                =>    <wire S_IC3    of <device CIM @[tile_sx+3, tile_5_sy+2]>>    ,
                    LX_ELECIDLE_EN_MSB[3]         =>    <wire A_IB2    of <device CIM @[tile_sx+3, tile_5_sy+2]>>    ,
                    TDATA_3[13]                   =>    <wire S_ID1    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[14]                   =>    <wire S_ID0    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[15]                   =>    <wire S_ID2    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[16]                   =>    <wire S_ID3    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[17]                   =>    <wire A_ID2    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[18]                   =>    <wire A_ID3    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[19]                   =>    <wire A_ID0    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[20]                   =>    <wire A_ID1    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[21]                   =>    <wire S_ICE    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[22]                   =>    <wire S_IC1    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[23]                   =>    <wire S_IC0    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[24]                   =>    <wire S_IC2    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[25]                   =>    <wire S_IC4    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[26]                   =>    <wire S_IC3    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[27]                   =>    <wire A_IC4    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[28]                   =>    <wire A_IC3    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[29]                   =>    <wire A_IC2    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[30]                   =>    <wire A_IC0    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[31]                   =>    <wire A_IC1    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[32]                   =>    <wire S_IB0    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[33]                   =>    <wire S_IB1    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[34]                   =>    <wire S_IB2    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[35]                   =>    <wire S_IB3    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[36]                   =>    <wire A_IB4    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[37]                   =>    <wire A_IB3    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[38]                   =>    <wire A_IB2    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[39]                   =>    <wire S_IB4    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[40]                   =>    <wire A_IB1    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[41]                   =>    <wire A_IB0    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[42]                   =>    <wire A_ICE    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    TDATA_3[43]                   =>    <wire S_IA3    of <device CIM @[tile_sx+3, tile_7_sy+2]>>    ,
                    LX_AMP_CTL_3[3]               =>    <wire S_ID1    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    LX_AMP_CTL_3[2]               =>    <wire S_ID0    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    LX_AMP_CTL_3[1]               =>    <wire S_ID2    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    LX_AMP_CTL_3[0]               =>    <wire S_ID3    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    LX_LFD_FRCORE_3               =>    <wire A_ID3    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    TX_CKDIV_3[0]                 =>    <wire A_ID0    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    TX_CKDIV_3[1]                 =>    <wire A_ID1    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    LANE_SYNC_EN_3                =>    <wire S_ICE    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    LX_DEEMP_CTL_3[0]             =>    <wire S_IC1    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    LX_DEEMP_CTL_3[1]             =>    <wire S_IC0    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    LX_DEEMP_CTL_3[2]             =>    <wire S_IC2    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX3[0]        =>    <wire A_IC4    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX3[1]        =>    <wire A_IC3    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX3[2]        =>    <wire A_IC2    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX3[3]        =>    <wire A_IC0    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX3[4]        =>    <wire A_IC1    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX3[5]        =>    <wire S_IB0    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX3[6]        =>    <wire S_IB1    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX3[7]        =>    <wire S_IB2    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    CIM_CLK_DYN_DLY_SEL_TX[3]     =>    <wire S_IB3    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    LX_ELECIDLE_EN_3[0]           =>    <wire A_IB4    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    LX_ELECIDLE_EN_3[1]           =>    <wire A_IB3    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    PCS_FAREND_LOOP[3]            =>    <wire S_IB4    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    TDATA_3[0]                    =>    <wire A_IB1    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    TDATA_3[1]                    =>    <wire A_IB0    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    TDATA_3[2]                    =>    <wire A_ICE    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    TDATA_3[3]                    =>    <wire S_IA3    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    TDATA_3[4]                    =>    <wire S_IA1    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    TDATA_3[5]                    =>    <wire S_IA0    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    TDATA_3[6]                    =>    <wire S_IA2    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    TDATA_3[7]                    =>    <wire A_IA4    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    TDATA_3[8]                    =>    <wire S_IA4    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    TDATA_3[9]                    =>    <wire A_IA3    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    TDATA_3[10]                   =>    <wire A_IA2    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    TDATA_3[11]                   =>    <wire A_IA1    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    TDATA_3[12]                   =>    <wire A_IA0    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    CIM_CLK_START_ALIGN_TX[3]     =>    <wire S_ICLK   of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    TX_PMA_RSTN_3                 =>    <wire S_IRS    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    TX3_CLK_FR_CORE               =>    <wire A_ICLK   of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    PCS_TX_RSTN_3                 =>    <wire A_IRS    of <device CIM @[tile_sx+3, tile_8_sy+2]>>    ,
                    CEB_ADETECT_EN[2]             =>    <wire S_ID1    of <device CIM @[tile_sx+3, tile_11_sy+2]>>    ,
                    PCS_WORD_ALIGN_EN[2]          =>    <wire S_ID0    of <device CIM @[tile_sx+3, tile_11_sy+2]>>    ,
                    RX_POLARITY_INVERT[2]         =>    <wire S_ID2    of <device CIM @[tile_sx+3, tile_11_sy+2]>>    ,
                    PCS_MCB_EXT_EN[2]             =>    <wire S_ID3    of <device CIM @[tile_sx+3, tile_11_sy+2]>>    ,
                    PCS_NEAREND_LOOP[2]           =>    <wire A_ID2    of <device CIM @[tile_sx+3, tile_11_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX2[4]        =>    <wire S_IC1    of <device CIM @[tile_sx+3, tile_11_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX2[5]        =>    <wire S_IC0    of <device CIM @[tile_sx+3, tile_11_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX2[6]        =>    <wire S_IC2    of <device CIM @[tile_sx+3, tile_11_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX2[7]        =>    <wire S_IC4    of <device CIM @[tile_sx+3, tile_11_sy+2]>>    ,
                    CIM_CLK_DYN_DLY_SEL_RX[2]     =>    <wire S_IC3    of <device CIM @[tile_sx+3, tile_11_sy+2]>>    ,
                    LX_RX_CKDIV_2[1]              =>    <wire A_IC2    of <device CIM @[tile_sx+3, tile_11_sy+2]>>    ,
                    LX_RX_CKDIV_2[0]              =>    <wire A_IC0    of <device CIM @[tile_sx+3, tile_11_sy+2]>>    ,
                    LX_RX_CKDIV_DYNSEL_2          =>    <wire A_IC1    of <device CIM @[tile_sx+3, tile_11_sy+2]>>    ,
                    CIM_CLK_START_ALIGN_RX[2]     =>    <wire S_IB1    of <device CIM @[tile_sx+3, tile_11_sy+2]>>    ,
                    RX_REF_CLK_2                  =>    <wire S_ICLK   of <device CIM @[tile_sx+3, tile_11_sy+2]>>    ,
                    RX_PMA_RSTN_2                 =>    <wire S_IRS    of <device CIM @[tile_sx+3, tile_11_sy+2]>>    ,
                    RX_PLL_RSTN_2                 =>    <wire A_IRS    of <device CIM @[tile_sx+3, tile_11_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX2[0]        =>    <wire A_ID3    of <device CIM @[tile_sx+3, tile_12_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX2[1]        =>    <wire A_ID0    of <device CIM @[tile_sx+3, tile_12_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX2[2]        =>    <wire A_ID1    of <device CIM @[tile_sx+3, tile_12_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX2[3]        =>    <wire S_ICE    of <device CIM @[tile_sx+3, tile_12_sy+2]>>    ,
                    RX2_CLK_FR_CORE               =>    <wire A_ICLK   of <device CIM @[tile_sx+3, tile_12_sy+2]>>    ,
                    PCS_RX_RSTN_2                 =>    <wire A_IRS    of <device CIM @[tile_sx+3, tile_12_sy+2]>>    ,
                    LX_EXTLB_EN[2]                =>    <wire A_IC4    of <device CIM @[tile_sx+3, tile_13_sy+2]>>    ,
                    LX_BISTLB_EN[2]               =>    <wire A_IC3    of <device CIM @[tile_sx+3, tile_13_sy+2]>>    ,
                    RX_LANE_POWERUP[2]            =>    <wire S_IB0    of <device CIM @[tile_sx+3, tile_13_sy+2]>>    ,
                    LX_TX_LFMODE[2]               =>    <wire A_ID2    of <device CIM @[tile_sx+3, tile_15_sy+2]>>    ,
                    TX_LANE_POWERUP[2]            =>    <wire S_IC4    of <device CIM @[tile_sx+3, tile_15_sy+2]>>    ,
                    LX_RXDCT_EN[2]                =>    <wire S_IC3    of <device CIM @[tile_sx+3, tile_15_sy+2]>>    ,
                    LX_ELECIDLE_EN_MSB[2]         =>    <wire A_IB2    of <device CIM @[tile_sx+3, tile_15_sy+2]>>    ,
                    TDATA_2[13]                   =>    <wire S_ID1    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[14]                   =>    <wire S_ID0    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[15]                   =>    <wire S_ID2    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[16]                   =>    <wire S_ID3    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[17]                   =>    <wire A_ID2    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[18]                   =>    <wire A_ID3    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[19]                   =>    <wire A_ID0    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[20]                   =>    <wire A_ID1    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[21]                   =>    <wire S_ICE    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[22]                   =>    <wire S_IC1    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[23]                   =>    <wire S_IC0    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[24]                   =>    <wire S_IC2    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[25]                   =>    <wire S_IC4    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[26]                   =>    <wire S_IC3    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[27]                   =>    <wire A_IC4    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[28]                   =>    <wire A_IC3    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[29]                   =>    <wire A_IC2    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[30]                   =>    <wire A_IC0    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[31]                   =>    <wire A_IC1    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[32]                   =>    <wire S_IB0    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[33]                   =>    <wire S_IB1    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[34]                   =>    <wire S_IB2    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[35]                   =>    <wire S_IB3    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[36]                   =>    <wire A_IB4    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[37]                   =>    <wire A_IB3    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[38]                   =>    <wire A_IB2    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[39]                   =>    <wire S_IB4    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[40]                   =>    <wire A_IB1    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[41]                   =>    <wire A_IB0    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[42]                   =>    <wire A_ICE    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    TDATA_2[43]                   =>    <wire S_IA3    of <device CIM @[tile_sx+3, tile_17_sy+2]>>    ,
                    LX_AMP_CTL_2[3]               =>    <wire S_ID1    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    LX_AMP_CTL_2[2]               =>    <wire S_ID0    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    LX_AMP_CTL_2[1]               =>    <wire S_ID2    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    LX_AMP_CTL_2[0]               =>    <wire S_ID3    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    LX_LFD_FRCORE_2               =>    <wire A_ID3    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    TX_CKDIV_2[0]                 =>    <wire A_ID0    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    TX_CKDIV_2[1]                 =>    <wire A_ID1    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    LANE_SYNC_EN_2                =>    <wire S_ICE    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    LX_DEEMP_CTL_2[0]             =>    <wire S_IC1    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    LX_DEEMP_CTL_2[1]             =>    <wire S_IC0    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    LX_DEEMP_CTL_2[2]             =>    <wire S_IC2    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX2[0]        =>    <wire A_IC4    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX2[1]        =>    <wire A_IC3    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX2[2]        =>    <wire A_IC2    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX2[3]        =>    <wire A_IC0    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX2[4]        =>    <wire A_IC1    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX2[5]        =>    <wire S_IB0    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX2[6]        =>    <wire S_IB1    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX2[7]        =>    <wire S_IB2    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    CIM_CLK_DYN_DLY_SEL_TX[2]     =>    <wire S_IB3    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    LX_ELECIDLE_EN_2[0]           =>    <wire A_IB4    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    LX_ELECIDLE_EN_2[1]           =>    <wire A_IB3    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    PCS_FAREND_LOOP[2]            =>    <wire S_IB4    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    TDATA_2[0]                    =>    <wire A_IB1    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    TDATA_2[1]                    =>    <wire A_IB0    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    TDATA_2[2]                    =>    <wire A_ICE    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    TDATA_2[3]                    =>    <wire S_IA3    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    TDATA_2[4]                    =>    <wire S_IA1    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    TDATA_2[5]                    =>    <wire S_IA0    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    TDATA_2[6]                    =>    <wire S_IA2    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    TDATA_2[7]                    =>    <wire A_IA4    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    TDATA_2[8]                    =>    <wire S_IA4    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    TDATA_2[9]                    =>    <wire A_IA3    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    TDATA_2[10]                   =>    <wire A_IA2    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    TDATA_2[11]                   =>    <wire A_IA1    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    TDATA_2[12]                   =>    <wire A_IA0    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    CIM_CLK_START_ALIGN_TX[2]     =>    <wire S_ICLK   of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    TX_PMA_RSTN_2                 =>    <wire S_IRS    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    TX2_CLK_FR_CORE               =>    <wire A_ICLK   of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    PCS_TX_RSTN_2                 =>    <wire A_IRS    of <device CIM @[tile_sx+3, tile_18_sy+2]>>    ,
                    CFG_ADDR[0]                   =>    <wire S_ID1    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_ADDR[1]                   =>    <wire S_ID0    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_ADDR[2]                   =>    <wire S_ID2    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_ADDR[3]                   =>    <wire S_ID3    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_ADDR[4]                   =>    <wire A_ID2    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_ADDR[5]                   =>    <wire A_ID3    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_ADDR[6]                   =>    <wire A_ID0    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_ADDR[7]                   =>    <wire A_ID1    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_ADDR[8]                   =>    <wire S_ICE    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_ADDR[9]                   =>    <wire S_IC1    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_ADDR[10]                  =>    <wire S_IC0    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_ADDR[11]                  =>    <wire S_IC2    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_ADDR[12]                  =>    <wire S_IC4    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_ADDR[13]                  =>    <wire S_IC3    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_ADDR[14]                  =>    <wire A_IC4    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_ADDR[15]                  =>    <wire A_IC3    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_WDATA[0]                  =>    <wire A_IC2    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_WDATA[1]                  =>    <wire A_IC0    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_WDATA[2]                  =>    <wire A_IC1    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_WDATA[3]                  =>    <wire S_IB0    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_WDATA[4]                  =>    <wire S_IB1    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_WDATA[5]                  =>    <wire S_IB2    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_WDATA[6]                  =>    <wire S_IB3    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_WDATA[7]                  =>    <wire A_IB4    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_WRITE                     =>    <wire A_IB3    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_ENABLE                    =>    <wire A_IB2    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    SYNC_TOGGLE                   =>    <wire S_IB4    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    PLLPOWERDOWN                  =>    <wire A_IB1    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    QUAD_PWRUP                    =>    <wire A_IB0    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    TXCKDIV_DYNSEL                =>    <wire A_ICE    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    PLL_REF_CLK                   =>    <wire S_ICLK   of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    PLL_RSTN                      =>    <wire S_IRS    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_CLK                       =>    <wire A_ICLK   of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    CFG_RSTN                      =>    <wire A_IRS    of <device CIM @[tile_sx+3, tile_19_sy+2]>>    ,
                    TEST_MODE                     =>    <wire S_ID1    of <device CIM @[tile_sx+3, tile_20_sy+2]>>    ,
                    PLL_BYPASS                    =>    <wire S_ID0    of <device CIM @[tile_sx+3, tile_20_sy+2]>>    ,
                    PLL_RESET                     =>    <wire S_ID2    of <device CIM @[tile_sx+3, tile_20_sy+2]>>    ,
                    TEST_SE                       =>    <wire S_ID3    of <device CIM @[tile_sx+3, tile_20_sy+2]>>    ,
                    TEST_CLK                      =>    <wire A_ID2    of <device CIM @[tile_sx+3, tile_20_sy+2]>>    ,
                    TEST_RSTN                     =>    <wire A_ID3    of <device CIM @[tile_sx+3, tile_20_sy+2]>>    ,
                    TEST_SI0                      =>    <wire A_ID0    of <device CIM @[tile_sx+3, tile_20_sy+2]>>    ,
                    TEST_SI1                      =>    <wire A_ID1    of <device CIM @[tile_sx+3, tile_20_sy+2]>>    ,
                    TEST_SI2                      =>    <wire S_ICE    of <device CIM @[tile_sx+3, tile_20_sy+2]>>    ,
                    TEST_SI3                      =>    <wire S_IC1    of <device CIM @[tile_sx+3, tile_20_sy+2]>>    ,
                    TEST_SI4                      =>    <wire S_IC0    of <device CIM @[tile_sx+3, tile_20_sy+2]>>    ,
                    TEST_SI5                      =>    <wire S_IC2    of <device CIM @[tile_sx+3, tile_20_sy+2]>>    ,
                    TEST_SI6                      =>    <wire S_IC4    of <device CIM @[tile_sx+3, tile_20_sy+2]>>    ,
                    TEST_SI7                      =>    <wire S_IC3    of <device CIM @[tile_sx+3, tile_20_sy+2]>>    ,
                    COMPRESSION_MODE              =>    <wire A_IC4    of <device CIM @[tile_sx+3, tile_20_sy+2]>>    ,
                    HSST_RSTN                     =>    <wire S_IRS    of <device CIM @[tile_sx+3, tile_20_sy+2]>>    ,
                    CEB_ADETECT_EN[1]             =>    <wire S_ID1    of <device CIM @[tile_sx+3, tile_21_sy+2]>>    ,
                    PCS_WORD_ALIGN_EN[1]          =>    <wire S_ID0    of <device CIM @[tile_sx+3, tile_21_sy+2]>>    ,
                    RX_POLARITY_INVERT[1]         =>    <wire S_ID2    of <device CIM @[tile_sx+3, tile_21_sy+2]>>    ,
                    PCS_MCB_EXT_EN[1]             =>    <wire S_ID3    of <device CIM @[tile_sx+3, tile_21_sy+2]>>    ,
                    PCS_NEAREND_LOOP[1]           =>    <wire A_ID2    of <device CIM @[tile_sx+3, tile_21_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX1[4]        =>    <wire S_IC1    of <device CIM @[tile_sx+3, tile_21_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX1[5]        =>    <wire S_IC0    of <device CIM @[tile_sx+3, tile_21_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX1[6]        =>    <wire S_IC2    of <device CIM @[tile_sx+3, tile_21_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX1[7]        =>    <wire S_IC4    of <device CIM @[tile_sx+3, tile_21_sy+2]>>    ,
                    CIM_CLK_DYN_DLY_SEL_RX[1]     =>    <wire S_IC3    of <device CIM @[tile_sx+3, tile_21_sy+2]>>    ,
                    LX_RX_CKDIV_1[1]              =>    <wire A_IC2    of <device CIM @[tile_sx+3, tile_21_sy+2]>>    ,
                    LX_RX_CKDIV_1[0]              =>    <wire A_IC0    of <device CIM @[tile_sx+3, tile_21_sy+2]>>    ,
                    LX_RX_CKDIV_DYNSEL_1          =>    <wire A_IC1    of <device CIM @[tile_sx+3, tile_21_sy+2]>>    ,
                    CIM_CLK_START_ALIGN_RX[1]     =>    <wire S_IB1    of <device CIM @[tile_sx+3, tile_21_sy+2]>>    ,
                    RX_REF_CLK_1                  =>    <wire S_ICLK   of <device CIM @[tile_sx+3, tile_21_sy+2]>>    ,
                    RX_PMA_RSTN_1                 =>    <wire S_IRS    of <device CIM @[tile_sx+3, tile_21_sy+2]>>    ,
                    RX_PLL_RSTN_1                 =>    <wire A_IRS    of <device CIM @[tile_sx+3, tile_21_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX1[0]        =>    <wire A_ID3    of <device CIM @[tile_sx+3, tile_22_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX1[1]        =>    <wire A_ID0    of <device CIM @[tile_sx+3, tile_22_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX1[2]        =>    <wire A_ID1    of <device CIM @[tile_sx+3, tile_22_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX1[3]        =>    <wire S_ICE    of <device CIM @[tile_sx+3, tile_22_sy+2]>>    ,
                    RX1_CLK_FR_CORE               =>    <wire A_ICLK   of <device CIM @[tile_sx+3, tile_22_sy+2]>>    ,
                    PCS_RX_RSTN_1                 =>    <wire A_IRS    of <device CIM @[tile_sx+3, tile_22_sy+2]>>    ,
                    LX_EXTLB_EN[1]                =>    <wire A_IC4    of <device CIM @[tile_sx+3, tile_23_sy+2]>>    ,
                    LX_BISTLB_EN[1]               =>    <wire A_IC3    of <device CIM @[tile_sx+3, tile_23_sy+2]>>    ,
                    RX_LANE_POWERUP[1]            =>    <wire S_IB0    of <device CIM @[tile_sx+3, tile_23_sy+2]>>    ,
                    LX_TX_LFMODE[1]               =>    <wire A_ID2    of <device CIM @[tile_sx+3, tile_25_sy+2]>>    ,
                    TX_LANE_POWERUP[1]            =>    <wire S_IC4    of <device CIM @[tile_sx+3, tile_25_sy+2]>>    ,
                    LX_RXDCT_EN[1]                =>    <wire S_IC3    of <device CIM @[tile_sx+3, tile_25_sy+2]>>    ,
                    LX_ELECIDLE_EN_MSB[1]         =>    <wire A_IB2    of <device CIM @[tile_sx+3, tile_25_sy+2]>>    ,
                    TDATA_1[13]                   =>    <wire S_ID1    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[14]                   =>    <wire S_ID0    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[15]                   =>    <wire S_ID2    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[16]                   =>    <wire S_ID3    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[17]                   =>    <wire A_ID2    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[18]                   =>    <wire A_ID3    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[19]                   =>    <wire A_ID0    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[20]                   =>    <wire A_ID1    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[21]                   =>    <wire S_ICE    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[22]                   =>    <wire S_IC1    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[23]                   =>    <wire S_IC0    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[24]                   =>    <wire S_IC2    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[25]                   =>    <wire S_IC4    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[26]                   =>    <wire S_IC3    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[27]                   =>    <wire A_IC4    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[28]                   =>    <wire A_IC3    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[29]                   =>    <wire A_IC2    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[30]                   =>    <wire A_IC0    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[31]                   =>    <wire A_IC1    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[32]                   =>    <wire S_IB0    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[33]                   =>    <wire S_IB1    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[34]                   =>    <wire S_IB2    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[35]                   =>    <wire S_IB3    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[36]                   =>    <wire A_IB4    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[37]                   =>    <wire A_IB3    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[38]                   =>    <wire A_IB2    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[39]                   =>    <wire S_IB4    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[40]                   =>    <wire A_IB1    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[41]                   =>    <wire A_IB0    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[42]                   =>    <wire A_ICE    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    TDATA_1[43]                   =>    <wire S_IA3    of <device CIM @[tile_sx+3, tile_27_sy+2]>>    ,
                    LX_AMP_CTL_1[3]               =>    <wire S_ID1    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    LX_AMP_CTL_1[2]               =>    <wire S_ID0    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    LX_AMP_CTL_1[1]               =>    <wire S_ID2    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    LX_AMP_CTL_1[0]               =>    <wire S_ID3    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    LX_LFD_FRCORE_1               =>    <wire A_ID3    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    TX_CKDIV_1[0]                 =>    <wire A_ID0    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    TX_CKDIV_1[1]                 =>    <wire A_ID1    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    LANE_SYNC_EN_1                =>    <wire S_ICE    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    LX_DEEMP_CTL_1[0]             =>    <wire S_IC1    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    LX_DEEMP_CTL_1[1]             =>    <wire S_IC0    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    LX_DEEMP_CTL_1[2]             =>    <wire S_IC2    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX1[0]        =>    <wire A_IC4    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX1[1]        =>    <wire A_IC3    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX1[2]        =>    <wire A_IC2    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX1[3]        =>    <wire A_IC0    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX1[4]        =>    <wire A_IC1    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX1[5]        =>    <wire S_IB0    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX1[6]        =>    <wire S_IB1    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX1[7]        =>    <wire S_IB2    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    CIM_CLK_DYN_DLY_SEL_TX[1]     =>    <wire S_IB3    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    LX_ELECIDLE_EN_1[0]           =>    <wire A_IB4    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    LX_ELECIDLE_EN_1[1]           =>    <wire A_IB3    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    PCS_FAREND_LOOP[1]            =>    <wire S_IB4    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    TDATA_1[0]                    =>    <wire A_IB1    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    TDATA_1[1]                    =>    <wire A_IB0    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    TDATA_1[2]                    =>    <wire A_ICE    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    TDATA_1[3]                    =>    <wire S_IA3    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    TDATA_1[4]                    =>    <wire S_IA1    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    TDATA_1[5]                    =>    <wire S_IA0    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    TDATA_1[6]                    =>    <wire S_IA2    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    TDATA_1[7]                    =>    <wire A_IA4    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    TDATA_1[8]                    =>    <wire S_IA4    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    TDATA_1[9]                    =>    <wire A_IA3    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    TDATA_1[10]                   =>    <wire A_IA2    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    TDATA_1[11]                   =>    <wire A_IA1    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    TDATA_1[12]                   =>    <wire A_IA0    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    CIM_CLK_START_ALIGN_TX[1]     =>    <wire S_ICLK   of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    TX_PMA_RSTN_1                 =>    <wire S_IRS    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    TX1_CLK_FR_CORE               =>    <wire A_ICLK   of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    PCS_TX_RSTN_1                 =>    <wire A_IRS    of <device CIM @[tile_sx+3, tile_28_sy+2]>>    ,
                    CEB_ADETECT_EN[0]             =>    <wire S_ID1    of <device CIM @[tile_sx+3, tile_31_sy+2]>>    ,
                    PCS_WORD_ALIGN_EN[0]          =>    <wire S_ID0    of <device CIM @[tile_sx+3, tile_31_sy+2]>>    ,
                    RX_POLARITY_INVERT[0]         =>    <wire S_ID2    of <device CIM @[tile_sx+3, tile_31_sy+2]>>    ,
                    PCS_MCB_EXT_EN[0]             =>    <wire S_ID3    of <device CIM @[tile_sx+3, tile_31_sy+2]>>    ,
                    PCS_NEAREND_LOOP[0]           =>    <wire A_ID2    of <device CIM @[tile_sx+3, tile_31_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX0[4]        =>    <wire S_IC1    of <device CIM @[tile_sx+3, tile_31_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX0[5]        =>    <wire S_IC0    of <device CIM @[tile_sx+3, tile_31_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX0[6]        =>    <wire S_IC2    of <device CIM @[tile_sx+3, tile_31_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX0[7]        =>    <wire S_IC4    of <device CIM @[tile_sx+3, tile_31_sy+2]>>    ,
                    CIM_CLK_DYN_DLY_SEL_RX[0]     =>    <wire S_IC3    of <device CIM @[tile_sx+3, tile_31_sy+2]>>    ,
                    LX_RX_CKDIV_0[1]              =>    <wire A_IC2    of <device CIM @[tile_sx+3, tile_31_sy+2]>>    ,
                    LX_RX_CKDIV_0[0]              =>    <wire A_IC0    of <device CIM @[tile_sx+3, tile_31_sy+2]>>    ,
                    LX_RX_CKDIV_DYNSEL_0          =>    <wire A_IC1    of <device CIM @[tile_sx+3, tile_31_sy+2]>>    ,
                    CIM_CLK_START_ALIGN_RX[0]     =>    <wire S_IB1    of <device CIM @[tile_sx+3, tile_31_sy+2]>>    ,
                    RX_REF_CLK_0                  =>    <wire S_ICLK   of <device CIM @[tile_sx+3, tile_31_sy+2]>>    ,
                    RX_PMA_RSTN_0                 =>    <wire S_IRS    of <device CIM @[tile_sx+3, tile_31_sy+2]>>    ,
                    RX_PLL_RSTN_0                 =>    <wire A_IRS    of <device CIM @[tile_sx+3, tile_31_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX0[0]        =>    <wire A_ID3    of <device CIM @[tile_sx+3, tile_32_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX0[1]        =>    <wire A_ID0    of <device CIM @[tile_sx+3, tile_32_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX0[2]        =>    <wire A_ID1    of <device CIM @[tile_sx+3, tile_32_sy+2]>>    ,
                    CIM_CLK_ALIGNER_RX0[3]        =>    <wire S_ICE    of <device CIM @[tile_sx+3, tile_32_sy+2]>>    ,
                    RX0_CLK_FR_CORE               =>    <wire A_ICLK   of <device CIM @[tile_sx+3, tile_32_sy+2]>>    ,
                    PCS_RX_RSTN_0                 =>    <wire A_IRS    of <device CIM @[tile_sx+3, tile_32_sy+2]>>    ,
                    LX_EXTLB_EN[0]                =>    <wire A_IC4    of <device CIM @[tile_sx+3, tile_33_sy+2]>>    ,
                    LX_BISTLB_EN[0]               =>    <wire A_IC3    of <device CIM @[tile_sx+3, tile_33_sy+2]>>    ,
                    RX_LANE_POWERUP[0]            =>    <wire S_IB0    of <device CIM @[tile_sx+3, tile_33_sy+2]>>    ,
                    LX_TX_LFMODE[0]               =>    <wire A_ID2    of <device CIM @[tile_sx+3, tile_35_sy+2]>>    ,
                    TX_LANE_POWERUP[0]            =>    <wire S_IC4    of <device CIM @[tile_sx+3, tile_35_sy+2]>>    ,
                    LX_RXDCT_EN[0]                =>    <wire S_IC3    of <device CIM @[tile_sx+3, tile_35_sy+2]>>    ,
                    LX_ELECIDLE_EN_MSB[0]         =>    <wire A_IB2    of <device CIM @[tile_sx+3, tile_35_sy+2]>>    ,
                    TDATA_0[13]                   =>    <wire S_ID1    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[14]                   =>    <wire S_ID0    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[15]                   =>    <wire S_ID2    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[16]                   =>    <wire S_ID3    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[17]                   =>    <wire A_ID2    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[18]                   =>    <wire A_ID3    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[19]                   =>    <wire A_ID0    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[20]                   =>    <wire A_ID1    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[21]                   =>    <wire S_ICE    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[22]                   =>    <wire S_IC1    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[23]                   =>    <wire S_IC0    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[24]                   =>    <wire S_IC2    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[25]                   =>    <wire S_IC4    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[26]                   =>    <wire S_IC3    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[27]                   =>    <wire A_IC4    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[28]                   =>    <wire A_IC3    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[29]                   =>    <wire A_IC2    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[30]                   =>    <wire A_IC0    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[31]                   =>    <wire A_IC1    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[32]                   =>    <wire S_IB0    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[33]                   =>    <wire S_IB1    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[34]                   =>    <wire S_IB2    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[35]                   =>    <wire S_IB3    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[36]                   =>    <wire A_IB4    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[37]                   =>    <wire A_IB3    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[38]                   =>    <wire A_IB2    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[39]                   =>    <wire S_IB4    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[40]                   =>    <wire A_IB1    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[41]                   =>    <wire A_IB0    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[42]                   =>    <wire A_ICE    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    TDATA_0[43]                   =>    <wire S_IA3    of <device CIM @[tile_sx+3, tile_37_sy+2]>>    ,
                    LX_AMP_CTL_0[3]               =>    <wire S_ID1    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    LX_AMP_CTL_0[2]               =>    <wire S_ID0    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    LX_AMP_CTL_0[1]               =>    <wire S_ID2    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    LX_AMP_CTL_0[0]               =>    <wire S_ID3    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    LX_LFD_FRCORE_0               =>    <wire A_ID3    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    TX_CKDIV_0[0]                 =>    <wire A_ID0    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    TX_CKDIV_0[1]                 =>    <wire A_ID1    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    LANE_SYNC_EN_0                =>    <wire S_ICE    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    LX_DEEMP_CTL_0[0]             =>    <wire S_IC1    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    LX_DEEMP_CTL_0[1]             =>    <wire S_IC0    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    LX_DEEMP_CTL_0[2]             =>    <wire S_IC2    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX0[0]        =>    <wire A_IC4    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX0[1]        =>    <wire A_IC3    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX0[2]        =>    <wire A_IC2    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX0[3]        =>    <wire A_IC0    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX0[4]        =>    <wire A_IC1    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX0[5]        =>    <wire S_IB0    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX0[6]        =>    <wire S_IB1    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    CIM_CLK_ALIGNER_TX0[7]        =>    <wire S_IB2    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    CIM_CLK_DYN_DLY_SEL_TX[0]     =>    <wire S_IB3    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    LX_ELECIDLE_EN_0[0]           =>    <wire A_IB4    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    LX_ELECIDLE_EN_0[1]           =>    <wire A_IB3    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    PCS_FAREND_LOOP[0]            =>    <wire S_IB4    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    TDATA_0[0]                    =>    <wire A_IB1    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    TDATA_0[1]                    =>    <wire A_IB0    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    TDATA_0[2]                    =>    <wire A_ICE    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    TDATA_0[3]                    =>    <wire S_IA3    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    TDATA_0[4]                    =>    <wire S_IA1    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    TDATA_0[5]                    =>    <wire S_IA0    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    TDATA_0[6]                    =>    <wire S_IA2    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    TDATA_0[7]                    =>    <wire A_IA4    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    TDATA_0[8]                    =>    <wire S_IA4    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    TDATA_0[9]                    =>    <wire A_IA3    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    TDATA_0[10]                   =>    <wire A_IA2    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    TDATA_0[11]                   =>    <wire A_IA1    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    TDATA_0[12]                   =>    <wire A_IA0    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    CIM_CLK_START_ALIGN_TX[0]     =>    <wire S_ICLK   of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    TX_PMA_RSTN_0                 =>    <wire S_IRS    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    TX0_CLK_FR_CORE               =>    <wire A_ICLK   of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
                    PCS_TX_RSTN_0                 =>    <wire A_IRS    of <device CIM @[tile_sx+3, tile_38_sy+2]>>    ,
    
                    //HSST_PAD_R to HSST
                    L0RXN             =>    <wire TX    of <device HSST_PAD_R @[sx+2, sy+1]>>    ,
                    L0RXP             =>    <wire TX    of <device HSST_PAD_R @[sx+3, sy+1]>>    ,
                    L1RXN             =>    <wire TX    of <device HSST_PAD_R @[sx+2, tile_1_sy+1]>>    ,
                    L1RXP             =>    <wire TX    of <device HSST_PAD_R @[sx+3, tile_1_sy+1]>>    ,
                    L2RXN             =>    <wire TX    of <device HSST_PAD_R @[sx+2, tile_2_sy+1]>>    ,
                    L2RXP             =>    <wire TX    of <device HSST_PAD_R @[sx+3, tile_2_sy+1]>>    ,
                    L3RXN             =>    <wire TX    of <device HSST_PAD_R @[sx+2, tile_3_sy+1]>>    ,
                    L3RXP             =>    <wire TX    of <device HSST_PAD_R @[sx+3, tile_3_sy+1]>>    ,
                    REFCKN             =>    <wire TX    of <device HSST_PAD_R @[sx, tile_4_sy+1]>>    ,
                    REFCKP             =>    <wire TX    of <device HSST_PAD_R @[sx+1, tile_4_sy+1]>>
                 )
        @([sx+1,sy]);  
    
    //
    // Layout HSST_PAD0 and connect wires and tracks driven by it
    //
    sprintf(strVar, "TXN_%d_%d", sx, sy+1);
    device HSST_PAD_T *strVar
        port map (
                   RX    => ntRef_ntL0TXN 
                 )
        @([sx, sy+1]);
    
    sprintf(strVar, "TXP_%d_%d", sx+1, sy+1);
    device HSST_PAD_T *strVar
        port map (
                   RX    => ntRef_ntL0TXP
                 )
        @([sx+1, sy+1]);

    
    
    //
    // Layout HSST_PAD1 and connect wires and tracks driven by it
    //
    sprintf(strVar, "TXN_%d_%d", sx, tile_1_sy+1);
    device HSST_PAD_T *strVar
        port map (
                    RX    => ntRef_ntL1TXN 
                 )
        @([sx, tile_1_sy+1]);
    
    sprintf(strVar, "TXP_%d_%d", sx+1, tile_1_sy+1);
    device HSST_PAD_T *strVar
        port map (
                    RX    => ntRef_ntL1TXP
                 )
        @([sx+1, tile_1_sy+1]);
    
    
    //
    // Layout HSST_PAD2 and connect wires and tracks driven by it
    //
    sprintf(strVar, "TXN_%d_%d", sx, tile_2_sy+1);
    device HSST_PAD_T *strVar
        port map (
                    RX    => ntRef_ntL2TXN 
                 )
        @([sx, tile_2_sy+1]);
    
    sprintf(strVar, "TXP_%d_%d", sx+1, tile_2_sy+1);
    device HSST_PAD_T *strVar
        port map (
                    RX    => ntRef_ntL2TXP
                 )
        @([sx+1, tile_2_sy+1]);
    
    
    //
    // Layout HSST_PAD3 and connect wires and tracks driven by it
    //
    sprintf(strVar, "TXN_%d_%d", sx, tile_3_sy+1);
    device HSST_PAD_T *strVar
        port map (
                    RX    => ntRef_ntL3TXN
                 )
        @([sx, tile_3_sy+1]);
    
    sprintf(strVar, "TXN_%d_%d", sx+1, tile_3_sy+1);
    device HSST_PAD_T *strVar
        port map (
                    RX    => ntRef_ntL3TXP
                 )
        @([sx+1, tile_3_sy+1]);
    
    
    connect
        (
            //HSST to CIM
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_1_sy+2]>> => ntRef_ntPCS_LSM_SYNCED[3],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_1_sy+2]>> => ntRef_ntPCS_RX_MCB_STATUS[3],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_1_sy+2]>> => ntRef_ntCLK2CORE_RX[3],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_1_sy+2]>> => ntRef_ntALIGN_RX[3],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_1_sy+2]>> => ntRef_ntLX_CDR_ALIGN_3,
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_1_sy+2]>> => ntRef_ntLX_OOB_STA_3,
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_1_sy+2]>> => ntRef_ntLX_ALOS_STA_3,
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_1_sy+2]>> => ntRef_ntLX_LFO_3,
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_2_sy+2]>> => ntRef_ntRDATA_3[40],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_2_sy+2]>> => ntRef_ntRDATA_3[41],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_2_sy+2]>> => ntRef_ntRDATA_3[42],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_2_sy+2]>> => ntRef_ntRDATA_3[43],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_2_sy+2]>> => ntRef_ntRDATA_3[44],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_2_sy+2]>> => ntRef_ntRDATA_3[45],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_2_sy+2]>> => ntRef_ntRDATA_3[46],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_3_sy+2]>> => ntRef_ntRDATA_3[30],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_3_sy+2]>> => ntRef_ntRDATA_3[31],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_3_sy+2]>> => ntRef_ntRDATA_3[32],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_3_sy+2]>> => ntRef_ntRDATA_3[33],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_3_sy+2]>> => ntRef_ntRDATA_3[34],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_3_sy+2]>> => ntRef_ntRDATA_3[35],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_3_sy+2]>> => ntRef_ntRDATA_3[36],
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_3_sy+2]>> => ntRef_ntRDATA_3[37],
            <pin A_IQ0    of <device CIM @[tile_sx+3,tile_3_sy+2]>> => ntRef_ntRDATA_3[38],
            <pin A_IY0    of <device CIM @[tile_sx+3,tile_3_sy+2]>> => ntRef_ntRDATA_3[39],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_4_sy+2]>> => ntRef_ntRDATA_3[20],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_4_sy+2]>> => ntRef_ntRDATA_3[21],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_4_sy+2]>> => ntRef_ntRDATA_3[22],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_4_sy+2]>> => ntRef_ntRDATA_3[23],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_4_sy+2]>> => ntRef_ntRDATA_3[24],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_4_sy+2]>> => ntRef_ntRDATA_3[25],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_4_sy+2]>> => ntRef_ntRDATA_3[26],
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_4_sy+2]>> => ntRef_ntRDATA_3[27],
            <pin A_IQ0    of <device CIM @[tile_sx+3,tile_4_sy+2]>> => ntRef_ntRDATA_3[28],
            <pin A_IY0    of <device CIM @[tile_sx+3,tile_4_sy+2]>> => ntRef_ntRDATA_3[29],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_5_sy+2]>> => ntRef_ntRDATA_3[10],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_5_sy+2]>> => ntRef_ntRDATA_3[11],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_5_sy+2]>> => ntRef_ntRDATA_3[12],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_5_sy+2]>> => ntRef_ntRDATA_3[13],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_5_sy+2]>> => ntRef_ntRDATA_3[14],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_5_sy+2]>> => ntRef_ntRDATA_3[15],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_5_sy+2]>> => ntRef_ntRDATA_3[16],
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_5_sy+2]>> => ntRef_ntRDATA_3[17],
            <pin A_IQ0    of <device CIM @[tile_sx+3,tile_5_sy+2]>> => ntRef_ntRDATA_3[18],
            <pin A_IY0    of <device CIM @[tile_sx+3,tile_5_sy+2]>> => ntRef_ntRDATA_3[19],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_6_sy+2]>> => ntRef_ntRDATA_3[0],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_6_sy+2]>> => ntRef_ntRDATA_3[1],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_6_sy+2]>> => ntRef_ntRDATA_3[2],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_6_sy+2]>> => ntRef_ntRDATA_3[3],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_6_sy+2]>> => ntRef_ntRDATA_3[4],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_6_sy+2]>> => ntRef_ntRDATA_3[5],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_6_sy+2]>> => ntRef_ntRDATA_3[6],
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_6_sy+2]>> => ntRef_ntRDATA_3[7],
            <pin A_IQ0    of <device CIM @[tile_sx+3,tile_6_sy+2]>> => ntRef_ntRDATA_3[8],
            <pin A_IY0    of <device CIM @[tile_sx+3,tile_6_sy+2]>> => ntRef_ntRDATA_3[9],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_8_sy+2]>> => ntRef_ntLX_RXDCT_OUT_3,
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_8_sy+2]>> => ntRef_ntLX_RXDCT_DONE_3,
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_8_sy+2]>> => ntRef_ntCLK2CORE_TX[3],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_8_sy+2]>> => ntRef_ntALIGN_TX[3],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_11_sy+2]>> => ntRef_ntPCS_LSM_SYNCED[2],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_11_sy+2]>> => ntRef_ntPCS_RX_MCB_STATUS[2],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_11_sy+2]>> => ntRef_ntCLK2CORE_RX[2],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_11_sy+2]>> => ntRef_ntALIGN_RX[2],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_11_sy+2]>> => ntRef_ntLX_CDR_ALIGN_2,
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_11_sy+2]>> => ntRef_ntLX_OOB_STA_2,
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_11_sy+2]>> => ntRef_ntLX_ALOS_STA_2,
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_11_sy+2]>> => ntRef_ntLX_LFO_2,
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_12_sy+2]>> => ntRef_ntRDATA_2[40],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_12_sy+2]>> => ntRef_ntRDATA_2[41],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_12_sy+2]>> => ntRef_ntRDATA_2[42],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_12_sy+2]>> => ntRef_ntRDATA_2[43],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_12_sy+2]>> => ntRef_ntRDATA_2[44],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_12_sy+2]>> => ntRef_ntRDATA_2[45],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_12_sy+2]>> => ntRef_ntRDATA_2[46],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_13_sy+2]>> => ntRef_ntRDATA_2[30],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_13_sy+2]>> => ntRef_ntRDATA_2[31],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_13_sy+2]>> => ntRef_ntRDATA_2[32],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_13_sy+2]>> => ntRef_ntRDATA_2[33],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_13_sy+2]>> => ntRef_ntRDATA_2[34],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_13_sy+2]>> => ntRef_ntRDATA_2[35],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_13_sy+2]>> => ntRef_ntRDATA_2[36],
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_13_sy+2]>> => ntRef_ntRDATA_2[37],
            <pin A_IQ0    of <device CIM @[tile_sx+3,tile_13_sy+2]>> => ntRef_ntRDATA_2[38],
            <pin A_IY0    of <device CIM @[tile_sx+3,tile_13_sy+2]>> => ntRef_ntRDATA_2[39],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_14_sy+2]>> => ntRef_ntRDATA_2[20],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_14_sy+2]>> => ntRef_ntRDATA_2[21],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_14_sy+2]>> => ntRef_ntRDATA_2[22],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_14_sy+2]>> => ntRef_ntRDATA_2[23],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_14_sy+2]>> => ntRef_ntRDATA_2[24],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_14_sy+2]>> => ntRef_ntRDATA_2[25],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_14_sy+2]>> => ntRef_ntRDATA_2[26],
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_14_sy+2]>> => ntRef_ntRDATA_2[27],
            <pin A_IQ0    of <device CIM @[tile_sx+3,tile_14_sy+2]>> => ntRef_ntRDATA_2[28],
            <pin A_IY0    of <device CIM @[tile_sx+3,tile_14_sy+2]>> => ntRef_ntRDATA_2[29],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_15_sy+2]>> => ntRef_ntRDATA_2[10],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_15_sy+2]>> => ntRef_ntRDATA_2[11],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_15_sy+2]>> => ntRef_ntRDATA_2[12],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_15_sy+2]>> => ntRef_ntRDATA_2[13],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_15_sy+2]>> => ntRef_ntRDATA_2[14],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_15_sy+2]>> => ntRef_ntRDATA_2[15],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_15_sy+2]>> => ntRef_ntRDATA_2[16],
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_15_sy+2]>> => ntRef_ntRDATA_2[17],
            <pin A_IQ0    of <device CIM @[tile_sx+3,tile_15_sy+2]>> => ntRef_ntRDATA_2[18],
            <pin A_IY0    of <device CIM @[tile_sx+3,tile_15_sy+2]>> => ntRef_ntRDATA_2[19],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_16_sy+2]>> => ntRef_ntRDATA_2[0],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_16_sy+2]>> => ntRef_ntRDATA_2[1],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_16_sy+2]>> => ntRef_ntRDATA_2[2],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_16_sy+2]>> => ntRef_ntRDATA_2[3],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_16_sy+2]>> => ntRef_ntRDATA_2[4],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_16_sy+2]>> => ntRef_ntRDATA_2[5],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_16_sy+2]>> => ntRef_ntRDATA_2[6],
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_16_sy+2]>> => ntRef_ntRDATA_2[7],
            <pin A_IQ0    of <device CIM @[tile_sx+3,tile_16_sy+2]>> => ntRef_ntRDATA_2[8],
            <pin A_IY0    of <device CIM @[tile_sx+3,tile_16_sy+2]>> => ntRef_ntRDATA_2[9],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_18_sy+2]>> => ntRef_ntLX_RXDCT_OUT_2,
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_18_sy+2]>> => ntRef_ntLX_RXDCT_DONE_2,
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_18_sy+2]>> => ntRef_ntCLK2CORE_TX[2],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_18_sy+2]>> => ntRef_ntALIGN_TX[2],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_19_sy+2]>> => ntRef_ntCFG_RDATA[0],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_19_sy+2]>> => ntRef_ntCFG_RDATA[1],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_19_sy+2]>> => ntRef_ntCFG_RDATA[2],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_19_sy+2]>> => ntRef_ntCFG_RDATA[3],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_19_sy+2]>> => ntRef_ntCFG_RDATA[4],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_19_sy+2]>> => ntRef_ntCFG_RDATA[5],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_19_sy+2]>> => ntRef_ntCFG_RDATA[6],
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_19_sy+2]>> => ntRef_ntCFG_RDATA[7],
            <pin A_IQ0    of <device CIM @[tile_sx+3,tile_19_sy+2]>> => ntRef_ntCFG_INT,
            <pin A_IY0    of <device CIM @[tile_sx+3,tile_19_sy+2]>> => ntRef_ntCFG_READY,
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_20_sy+2]>> => ntRef_ntPLL_LOCK,
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_20_sy+2]>> => ntRef_ntREFCK2CORE,
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_20_sy+2]>> => ntRef_ntTEST_SO0,
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_20_sy+2]>> => ntRef_ntTEST_SO1,
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_20_sy+2]>> => ntRef_ntTEST_SO2,
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_20_sy+2]>> => ntRef_ntTEST_SO3,
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_20_sy+2]>> => ntRef_ntTEST_SO4,
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_20_sy+2]>> => ntRef_ntTEST_SO5,
            <pin A_IQ0    of <device CIM @[tile_sx+3,tile_20_sy+2]>> => ntRef_ntTEST_SO6,
            <pin A_IY0    of <device CIM @[tile_sx+3,tile_20_sy+2]>> => ntRef_ntTEST_SO7,
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_21_sy+2]>> => ntRef_ntPCS_LSM_SYNCED[1],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_21_sy+2]>> => ntRef_ntPCS_RX_MCB_STATUS[1],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_21_sy+2]>> => ntRef_ntCLK2CORE_RX[1],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_21_sy+2]>> => ntRef_ntALIGN_RX[1],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_21_sy+2]>> => ntRef_ntLX_CDR_ALIGN_1,
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_21_sy+2]>> => ntRef_ntLX_OOB_STA_1,
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_21_sy+2]>> => ntRef_ntLX_ALOS_STA_1,
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_21_sy+2]>> => ntRef_ntLX_LFO_1,
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_22_sy+2]>> => ntRef_ntRDATA_1[40],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_22_sy+2]>> => ntRef_ntRDATA_1[41],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_22_sy+2]>> => ntRef_ntRDATA_1[42],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_22_sy+2]>> => ntRef_ntRDATA_1[43],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_22_sy+2]>> => ntRef_ntRDATA_1[44],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_22_sy+2]>> => ntRef_ntRDATA_1[45],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_22_sy+2]>> => ntRef_ntRDATA_1[46],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_23_sy+2]>> => ntRef_ntRDATA_1[30],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_23_sy+2]>> => ntRef_ntRDATA_1[31],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_23_sy+2]>> => ntRef_ntRDATA_1[32],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_23_sy+2]>> => ntRef_ntRDATA_1[33],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_23_sy+2]>> => ntRef_ntRDATA_1[34],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_23_sy+2]>> => ntRef_ntRDATA_1[35],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_23_sy+2]>> => ntRef_ntRDATA_1[36],
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_23_sy+2]>> => ntRef_ntRDATA_1[37],
            <pin A_IQ0    of <device CIM @[tile_sx+3,tile_23_sy+2]>> => ntRef_ntRDATA_1[38],
            <pin A_IY0    of <device CIM @[tile_sx+3,tile_23_sy+2]>> => ntRef_ntRDATA_1[39],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_24_sy+2]>> => ntRef_ntRDATA_1[20],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_24_sy+2]>> => ntRef_ntRDATA_1[21],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_24_sy+2]>> => ntRef_ntRDATA_1[22],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_24_sy+2]>> => ntRef_ntRDATA_1[23],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_24_sy+2]>> => ntRef_ntRDATA_1[24],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_24_sy+2]>> => ntRef_ntRDATA_1[25],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_24_sy+2]>> => ntRef_ntRDATA_1[26],
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_24_sy+2]>> => ntRef_ntRDATA_1[27],
            <pin A_IQ0    of <device CIM @[tile_sx+3,tile_24_sy+2]>> => ntRef_ntRDATA_1[28],
            <pin A_IY0    of <device CIM @[tile_sx+3,tile_24_sy+2]>> => ntRef_ntRDATA_1[29],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_25_sy+2]>> => ntRef_ntRDATA_1[10],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_25_sy+2]>> => ntRef_ntRDATA_1[11],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_25_sy+2]>> => ntRef_ntRDATA_1[12],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_25_sy+2]>> => ntRef_ntRDATA_1[13],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_25_sy+2]>> => ntRef_ntRDATA_1[14],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_25_sy+2]>> => ntRef_ntRDATA_1[15],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_25_sy+2]>> => ntRef_ntRDATA_1[16],
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_25_sy+2]>> => ntRef_ntRDATA_1[17],
            <pin A_IQ0    of <device CIM @[tile_sx+3,tile_25_sy+2]>> => ntRef_ntRDATA_1[18],
            <pin A_IY0    of <device CIM @[tile_sx+3,tile_25_sy+2]>> => ntRef_ntRDATA_1[19],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_26_sy+2]>> => ntRef_ntRDATA_1[0],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_26_sy+2]>> => ntRef_ntRDATA_1[1],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_26_sy+2]>> => ntRef_ntRDATA_1[2],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_26_sy+2]>> => ntRef_ntRDATA_1[3],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_26_sy+2]>> => ntRef_ntRDATA_1[4],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_26_sy+2]>> => ntRef_ntRDATA_1[5],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_26_sy+2]>> => ntRef_ntRDATA_1[6],
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_26_sy+2]>> => ntRef_ntRDATA_1[7],
            <pin A_IQ0    of <device CIM @[tile_sx+3,tile_26_sy+2]>> => ntRef_ntRDATA_1[8],
            <pin A_IY0    of <device CIM @[tile_sx+3,tile_26_sy+2]>> => ntRef_ntRDATA_1[9],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_28_sy+2]>> => ntRef_ntLX_RXDCT_OUT_1,
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_28_sy+2]>> => ntRef_ntLX_RXDCT_DONE_1,
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_28_sy+2]>> => ntRef_ntCLK2CORE_TX[1],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_28_sy+2]>> => ntRef_ntALIGN_TX[1],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_31_sy+2]>> => ntRef_ntPCS_LSM_SYNCED[0],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_31_sy+2]>> => ntRef_ntPCS_RX_MCB_STATUS[0],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_31_sy+2]>> => ntRef_ntCLK2CORE_RX[0],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_31_sy+2]>> => ntRef_ntALIGN_RX[0],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_31_sy+2]>> => ntRef_ntLX_CDR_ALIGN_0,
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_31_sy+2]>> => ntRef_ntLX_OOB_STA_0,
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_31_sy+2]>> => ntRef_ntLX_ALOS_STA_0,
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_31_sy+2]>> => ntRef_ntLX_LFO_0,
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_32_sy+2]>> => ntRef_ntRDATA_0[40],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_32_sy+2]>> => ntRef_ntRDATA_0[41],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_32_sy+2]>> => ntRef_ntRDATA_0[42],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_32_sy+2]>> => ntRef_ntRDATA_0[43],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_32_sy+2]>> => ntRef_ntRDATA_0[44],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_32_sy+2]>> => ntRef_ntRDATA_0[45],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_32_sy+2]>> => ntRef_ntRDATA_0[46],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_33_sy+2]>> => ntRef_ntRDATA_0[30],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_33_sy+2]>> => ntRef_ntRDATA_0[31],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_33_sy+2]>> => ntRef_ntRDATA_0[32],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_33_sy+2]>> => ntRef_ntRDATA_0[33],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_33_sy+2]>> => ntRef_ntRDATA_0[34],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_33_sy+2]>> => ntRef_ntRDATA_0[35],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_33_sy+2]>> => ntRef_ntRDATA_0[36],
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_33_sy+2]>> => ntRef_ntRDATA_0[37],
            <pin A_IQ0    of <device CIM @[tile_sx+3,tile_33_sy+2]>> => ntRef_ntRDATA_0[38],
            <pin A_IY0    of <device CIM @[tile_sx+3,tile_33_sy+2]>> => ntRef_ntRDATA_0[39],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_34_sy+2]>> => ntRef_ntRDATA_0[20],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_34_sy+2]>> => ntRef_ntRDATA_0[21],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_34_sy+2]>> => ntRef_ntRDATA_0[22],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_34_sy+2]>> => ntRef_ntRDATA_0[23],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_34_sy+2]>> => ntRef_ntRDATA_0[24],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_34_sy+2]>> => ntRef_ntRDATA_0[25],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_34_sy+2]>> => ntRef_ntRDATA_0[26],
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_34_sy+2]>> => ntRef_ntRDATA_0[27],
            <pin A_IQ0    of <device CIM @[tile_sx+3,tile_34_sy+2]>> => ntRef_ntRDATA_0[28],
            <pin A_IY0    of <device CIM @[tile_sx+3,tile_34_sy+2]>> => ntRef_ntRDATA_0[29],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_35_sy+2]>> => ntRef_ntRDATA_0[10],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_35_sy+2]>> => ntRef_ntRDATA_0[11],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_35_sy+2]>> => ntRef_ntRDATA_0[12],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_35_sy+2]>> => ntRef_ntRDATA_0[13],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_35_sy+2]>> => ntRef_ntRDATA_0[14],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_35_sy+2]>> => ntRef_ntRDATA_0[15],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_35_sy+2]>> => ntRef_ntRDATA_0[16],
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_35_sy+2]>> => ntRef_ntRDATA_0[17],
            <pin A_IQ0    of <device CIM @[tile_sx+3,tile_35_sy+2]>> => ntRef_ntRDATA_0[18],
            <pin A_IY0    of <device CIM @[tile_sx+3,tile_35_sy+2]>> => ntRef_ntRDATA_0[19],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_36_sy+2]>> => ntRef_ntRDATA_0[0],
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_36_sy+2]>> => ntRef_ntRDATA_0[1],
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_36_sy+2]>> => ntRef_ntRDATA_0[2],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_36_sy+2]>> => ntRef_ntRDATA_0[3],
            <pin A_IY2    of <device CIM @[tile_sx+3,tile_36_sy+2]>> => ntRef_ntRDATA_0[4],
            <pin A_IQ1    of <device CIM @[tile_sx+3,tile_36_sy+2]>> => ntRef_ntRDATA_0[5],
            <pin A_IY1    of <device CIM @[tile_sx+3,tile_36_sy+2]>> => ntRef_ntRDATA_0[6],
            <pin A_IY6AB  of <device CIM @[tile_sx+3,tile_36_sy+2]>> => ntRef_ntRDATA_0[7],
            <pin A_IQ0    of <device CIM @[tile_sx+3,tile_36_sy+2]>> => ntRef_ntRDATA_0[8],
            <pin A_IY0    of <device CIM @[tile_sx+3,tile_36_sy+2]>> => ntRef_ntRDATA_0[9],
            <pin A_IQ3    of <device CIM @[tile_sx+3,tile_38_sy+2]>> => ntRef_ntLX_RXDCT_OUT_0,
            <pin A_IY3    of <device CIM @[tile_sx+3,tile_38_sy+2]>> => ntRef_ntLX_RXDCT_DONE_0,
            <pin A_IY6CD  of <device CIM @[tile_sx+3,tile_38_sy+2]>> => ntRef_ntCLK2CORE_TX[0],
            <pin A_IQ2    of <device CIM @[tile_sx+3,tile_38_sy+2]>> => ntRef_ntALIGN_TX[0]

        );    

}; // end of function place_hsst_tile

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places all the device within a logic tile @[tx,ty].
             The logic tile include SRB, SIB, CLMS, CLMA, VCC, GND.
             The logic layout inside of a tile is as followings,


              ---------|---------|---------|---------
              
                V[0,1]    A[1,1]   S[2,1]

                G[0,0]    R[1,0]   I[2,0] 
              ---------|---------|---------|---------
            ]

  Revision History:

*****************************************************************************************/
function place_logic_sa_tile ( unsigned int tx, ty )
{
    string strVar;

    // Site index variable
    unsigned int sx, sy;

    // Calculate the site coordinate of the lower-left corner
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;

    //
    // Allocate wires for logic connection inside of a logic tile
    //
    
    //
    // Wires driven by SRB
    //
    
    // TO SIB
    sprintf(strVar, "ntZM1_%d_%d", sx+1, sy);
    &wire ntRef_ntZM1[13:0] = wire *strVar[13:0]   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntZM_%d_%d", sx+1, sy);
    &wire ntRef_ntZM[47:0] = wire *strVar[47:0]   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    // LOCAL
    sprintf(strVar, "ntZSS_%d_%d", sx+1, sy);
    &wire ntRef_ntZSS[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSN_%d_%d", sx+1, sy);
    &wire ntRef_ntZSN[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSE_%d_%d", sx+1, sy);
    &wire ntRef_ntZSE[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSW_%d_%d", sx+1, sy);
    &wire ntRef_ntZSW[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSNW_%d_%d", sx+1, sy);
    &wire ntRef_ntZSNW[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSNE_%d_%d", sx+1, sy);
    &wire ntRef_ntZSNE[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSSW_%d_%d", sx+1, sy);
    &wire ntRef_ntZSSW[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSSE_%d_%d", sx+1, sy);
    &wire ntRef_ntZSSE[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    
    // DOUBLE
    sprintf(strVar, "ntZDS_%d_%d", sx+1, sy);
    &wire ntRef_ntZDS[5:0] = wire *strVar[5:0] /*pragma PAP_ARC_ITC_TYPE="DOUBLE" */ ;
    
    sprintf(strVar, "ntZDN_%d_%d", sx+1, sy);
    &wire ntRef_ntZDN[5:0] = wire *strVar[5:0] /*pragma PAP_ARC_ITC_TYPE="DOUBLE" */ ;

    sprintf(strVar, "ntZDE_%d_%d", sx+1, sy);
    &wire ntRef_ntZDE[5:0] = wire *strVar[5:0] /*pragma PAP_ARC_ITC_TYPE="DOUBLE" */ ;
    
    sprintf(strVar, "ntZDW_%d_%d", sx+1, sy);
    &wire ntRef_ntZDW[5:0] = wire *strVar[5:0] /*pragma PAP_ARC_ITC_TYPE="DOUBLE" */ ;
    
    // QUAD
    sprintf(strVar, "ntZQS_%d_%d", sx+1, sy);
    &wire ntRef_ntZQS[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="QUAD" */ ;
    
    sprintf(strVar, "ntZQN_%d_%d", sx+1, sy);
    &wire ntRef_ntZQN[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="QUAD" */ ;
    
    sprintf(strVar, "ntZQE_%d_%d", sx+1, sy);
    &wire ntRef_ntZQE[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="QUAD" */ ;
    
    sprintf(strVar, "ntZQW_%d_%d", sx+1, sy);
    &wire ntRef_ntZQW[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="QUAD" */ ;
    
    // LONG LINE
    //sprintf(strVar, "ntLH0_%d_%d", sx+1, sy);
    //&wire ntRef_ntLH0 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLH2_%d_%d", sx+1, sy);
    //&wire ntRef_ntLH2 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLH0__%d_%d", sx+1, sy);
    //&wire ntRef_ntLH0_ = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLH2__%d_%d", sx+1, sy);
    //&wire ntRef_ntLH2_ = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLV0_%d_%d", sx+1, sy);
    //&wire ntRef_ntLV0 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLV2_%d_%d", sx+1, sy);
    //&wire ntRef_ntLV2 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLV0__%d_%d", sx+1, sy);
    //&wire ntRef_ntLV0_ = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLV2__%d_%d", sx+1, sy);
    //&wire ntRef_ntLV2_ = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;

    //
    // Wires driven by SIB
    //
    // TO CLMS
    sprintf(strVar, "ntS_DD_%d_%d", sx+2, sy);
    &wire ntRef_ntS_DD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_D4_%d_%d", sx+2, sy);
    &wire ntRef_ntS_D4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_D3_%d_%d", sx+2, sy);
    &wire ntRef_ntS_D3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_D2_%d_%d", sx+2, sy);
    &wire ntRef_ntS_D2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_D1_%d_%d", sx+2, sy);
    &wire ntRef_ntS_D1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_D0_%d_%d", sx+2, sy);
    &wire ntRef_ntS_D0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_M3_%d_%d", sx+2, sy);
    &wire ntRef_ntS_M3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntS_CD_%d_%d", sx+2, sy);
    &wire ntRef_ntS_CD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_C4_%d_%d", sx+2, sy);
    &wire ntRef_ntS_C4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_C3_%d_%d", sx+2, sy);
    &wire ntRef_ntS_C3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_C2_%d_%d", sx+2, sy);
    &wire ntRef_ntS_C2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_C1_%d_%d", sx+2, sy);
    &wire ntRef_ntS_C1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_C0_%d_%d", sx+2, sy);
    &wire ntRef_ntS_C0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_M2_%d_%d", sx+2, sy);
    &wire ntRef_ntS_M2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntS_BD_%d_%d", sx+2, sy);
    &wire ntRef_ntS_BD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_B4_%d_%d", sx+2, sy);
    &wire ntRef_ntS_B4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_B3_%d_%d", sx+2, sy);
    &wire ntRef_ntS_B3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_B2_%d_%d", sx+2, sy);
    &wire ntRef_ntS_B2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_B1_%d_%d", sx+2, sy);
    &wire ntRef_ntS_B1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_B0_%d_%d", sx+2, sy);
    &wire ntRef_ntS_B0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_M1_%d_%d", sx+2, sy);
    &wire ntRef_ntS_M1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntS_AD_%d_%d", sx+2, sy);
    &wire ntRef_ntS_AD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_A4_%d_%d", sx+2, sy);
    &wire ntRef_ntS_A4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_A3_%d_%d", sx+2, sy);
    &wire ntRef_ntS_A3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_A2_%d_%d", sx+2, sy);
    &wire ntRef_ntS_A2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_A1_%d_%d", sx+2, sy);
    &wire ntRef_ntS_A1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_A0_%d_%d", sx+2, sy);
    &wire ntRef_ntS_A0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_M0_%d_%d", sx+2, sy);
    &wire ntRef_ntS_M0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntS_CE_%d_%d", sx+2, sy);
    &wire ntRef_ntS_CE = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_RS_%d_%d", sx+2, sy);
    &wire ntRef_ntS_RS = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_CLK_%d_%d", sx+2, sy);
    &wire ntRef_ntS_CLK = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    // TO CLMA
    sprintf(strVar, "ntA_DD_%d_%d", sx+2, sy);
    &wire ntRef_ntA_DD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_D4_%d_%d", sx+2, sy);
    &wire ntRef_ntA_D4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_D3_%d_%d", sx+2, sy);
    &wire ntRef_ntA_D3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_D2_%d_%d", sx+2, sy);
    &wire ntRef_ntA_D2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_D1_%d_%d", sx+2, sy);
    &wire ntRef_ntA_D1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_D0_%d_%d", sx+2, sy);
    &wire ntRef_ntA_D0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_M3_%d_%d", sx+2, sy);
    &wire ntRef_ntA_M3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntA_CD_%d_%d", sx+2, sy);
    &wire ntRef_ntA_CD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_C4_%d_%d", sx+2, sy);
    &wire ntRef_ntA_C4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_C3_%d_%d", sx+2, sy);
    &wire ntRef_ntA_C3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_C2_%d_%d", sx+2, sy);
    &wire ntRef_ntA_C2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_C1_%d_%d", sx+2, sy);
    &wire ntRef_ntA_C1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_C0_%d_%d", sx+2, sy);
    &wire ntRef_ntA_C0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_M2_%d_%d", sx+2, sy);
    &wire ntRef_ntA_M2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntA_BD_%d_%d", sx+2, sy);
    &wire ntRef_ntA_BD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_B4_%d_%d", sx+2, sy);
    &wire ntRef_ntA_B4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_B3_%d_%d", sx+2, sy);
    &wire ntRef_ntA_B3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_B2_%d_%d", sx+2, sy);
    &wire ntRef_ntA_B2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_B1_%d_%d", sx+2, sy);
    &wire ntRef_ntA_B1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_B0_%d_%d", sx+2, sy);
    &wire ntRef_ntA_B0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_M1_%d_%d", sx+2, sy);
    &wire ntRef_ntA_M1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntA_AD_%d_%d", sx+2, sy);
    &wire ntRef_ntA_AD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_A4_%d_%d", sx+2, sy);
    &wire ntRef_ntA_A4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_A3_%d_%d", sx+2, sy);
    &wire ntRef_ntA_A3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_A2_%d_%d", sx+2, sy);
    &wire ntRef_ntA_A2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_A1_%d_%d", sx+2, sy);
    &wire ntRef_ntA_A1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_A0_%d_%d", sx+2, sy);
    &wire ntRef_ntA_A0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_M0_%d_%d", sx+2, sy);
    &wire ntRef_ntA_M0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntA_CE_%d_%d", sx+2, sy);
    &wire ntRef_ntA_CE = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_RS_%d_%d", sx+2, sy);
    &wire ntRef_ntA_RS = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_CLK_%d_%d", sx+2, sy);
    &wire ntRef_ntA_CLK = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Wires driven by CLMS
    //
    sprintf(strVar, "ntY6CD_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Y6CD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY6AB_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Y6AB = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntQ3_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Q3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntQ2_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Q2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntQ1_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Q1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntQ0_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Q0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY3_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Y3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY2_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Y2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY1_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Y1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY0_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Y0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntL7OUT_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_L7OUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntCOUT_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_COUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRSOUT_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_RSOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntCEOUT_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_CEOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntSHIFTOUT_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_SHIFTOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Wires driven by CLMA
    //
    sprintf(strVar, "ntY6CD_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Y6CD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY6AB_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Y6AB = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntQ3_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Q3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntQ2_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Q2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntQ1_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Q1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntQ0_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Q0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY3_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Y3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY2_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Y2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY1_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Y1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY0_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Y0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntL7OUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_L7OUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntCOUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_COUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRSOUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_RSOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntCEOUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_CEOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntSHIFTOUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_SHIFTOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntCLKOUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_CLKOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Wires driven by VCC or GND
    //
    sprintf(strVar, "ntVCCOUT_%d_%d", sx, sy+1);
    &wire ntRef_ntVCCOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntGNDOUT_%d_%d", sx, sy);
    &wire ntRef_ntGNDOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout SRB and connect wires and tracks driven by it
    //
    sprintf(strVar, "SRB_%d_%d", sx+1, sy);
    device SRB *strVar
        port map (
                   VCC    => ntRef_ntVCCOUT,       // Inputs from local VCC (V)
                   GND    => ntRef_ntGNDOUT,       // Inputs from local GND (G)
                   
                   S_Y6CD => ntRef_ntCLMS_Y6CD,    // Inputs from local CLMS (S)
                   S_Y6AB => ntRef_ntCLMS_Y6AB,
                   S_Q3   => ntRef_ntCLMS_Q3,
                   S_Q2   => ntRef_ntCLMS_Q2,
                   S_Q1   => ntRef_ntCLMS_Q1,
                   S_Q0   => ntRef_ntCLMS_Q0,
                   S_Y3   => ntRef_ntCLMS_Y3,
                   S_Y2   => ntRef_ntCLMS_Y2,
                   S_Y1   => ntRef_ntCLMS_Y1,
                   S_Y0   => ntRef_ntCLMS_Y0,

                   A_Y6CD => ntRef_ntCLMA_Y6CD,    // Inputs from local CLMA (A)
                   A_Y6AB => ntRef_ntCLMA_Y6AB,
                   A_Q3   => ntRef_ntCLMA_Q3,
                   A_Q2   => ntRef_ntCLMA_Q2,
                   A_Q1   => ntRef_ntCLMA_Q1,
                   A_Q0   => ntRef_ntCLMA_Q0,
                   A_Y3   => ntRef_ntCLMA_Y3,
                   A_Y2   => ntRef_ntCLMA_Y2,
                   A_Y1   => ntRef_ntCLMA_Y1,
                   A_Y0   => ntRef_ntCLMA_Y0,

                   ZM1   => ntRef_ntZM1,
                   ZM    => ntRef_ntZM,

                   ZSS   => ntRef_ntZSS,
                   ZSN   => ntRef_ntZSN,
                   ZSE   => ntRef_ntZSE,
                   ZSW   => ntRef_ntZSW,
                   ZSNW  => ntRef_ntZSNW,
                   ZSNE  => ntRef_ntZSNE,
                   ZSSW  => ntRef_ntZSSW,
                   ZSSE  => ntRef_ntZSSE,
                   ZDS   => ntRef_ntZDS,
                   ZDN   => ntRef_ntZDN,
                   ZDE   => ntRef_ntZDE,
                   ZDW   => ntRef_ntZDW,
                   ZQS   => ntRef_ntZQS,
                   ZQN   => ntRef_ntZQN,
                   ZQE   => ntRef_ntZQE,
                   ZQW   => ntRef_ntZQW
                   
                   //LH0   => ntRef_ntLH0,
                   //LH2   => ntRef_ntLH2,
                   //LH0_  => ntRef_ntLH0_,
                   //LH2_  => ntRef_ntLH2_,
                   //LV0   => ntRef_ntLV0,
                   //LV2   => ntRef_ntLV2,
                   //LV0_  => ntRef_ntLV0_,
                   //LV2_  => ntRef_ntLV2_
                 )
        @([sx+1,sy]);
        
        
    //
    // Layout SIB and connect wires and tracks driven by it
    //
    sprintf(strVar, "SIB_%d_%d", sx+2, sy);
    device SIB *strVar
        port map (
                   IM1  => ntRef_ntZM1,          // Input from local SRB (R)
                   IM   => ntRef_ntZM,
                   
                   S_DD  => ntRef_ntS_DD,
                   S_D4  => ntRef_ntS_D4,
                   S_D3  => ntRef_ntS_D3,
                   S_D2  => ntRef_ntS_D2,
                   S_D1  => ntRef_ntS_D1,
                   S_D0  => ntRef_ntS_D0,
                   S_M3  => ntRef_ntS_M3,
                   S_CD  => ntRef_ntS_CD,
                   S_C4  => ntRef_ntS_C4,
                   S_C3  => ntRef_ntS_C3,
                   S_C2  => ntRef_ntS_C2,
                   S_C1  => ntRef_ntS_C1,
                   S_C0  => ntRef_ntS_C0,
                   S_M2  => ntRef_ntS_M2,
                   S_BD  => ntRef_ntS_BD,
                   S_B4  => ntRef_ntS_B4,
                   S_B3  => ntRef_ntS_B3,
                   S_B2  => ntRef_ntS_B2,
                   S_B1  => ntRef_ntS_B1,
                   S_B0  => ntRef_ntS_B0,
                   S_M1  => ntRef_ntS_M1,
                   S_AD  => ntRef_ntS_AD,
                   S_A4  => ntRef_ntS_A4,
                   S_A3  => ntRef_ntS_A3,
                   S_A2  => ntRef_ntS_A2,
                   S_A1  => ntRef_ntS_A1,
                   S_A0  => ntRef_ntS_A0,
                   S_M0  => ntRef_ntS_M0,
                   S_CE  => ntRef_ntS_CE,
                   S_RS  => ntRef_ntS_RS,
                   S_CLK => ntRef_ntS_CLK,

                   A_DD  => ntRef_ntA_DD,
                   A_D4  => ntRef_ntA_D4,
                   A_D3  => ntRef_ntA_D3,
                   A_D2  => ntRef_ntA_D2,
                   A_D1  => ntRef_ntA_D1,
                   A_D0  => ntRef_ntA_D0,
                   A_M3  => ntRef_ntA_M3,
                   A_CD  => ntRef_ntA_CD,
                   A_C4  => ntRef_ntA_C4,
                   A_C3  => ntRef_ntA_C3,
                   A_C2  => ntRef_ntA_C2,
                   A_C1  => ntRef_ntA_C1,
                   A_C0  => ntRef_ntA_C0,
                   A_M2  => ntRef_ntA_M2,
                   A_BD  => ntRef_ntA_BD,
                   A_B4  => ntRef_ntA_B4,
                   A_B3  => ntRef_ntA_B3,
                   A_B2  => ntRef_ntA_B2,
                   A_B1  => ntRef_ntA_B1,
                   A_B0  => ntRef_ntA_B0,
                   A_M1  => ntRef_ntA_M1,
                   A_AD  => ntRef_ntA_AD,
                   A_A4  => ntRef_ntA_A4,
                   A_A3  => ntRef_ntA_A3,
                   A_A2  => ntRef_ntA_A2,
                   A_A1  => ntRef_ntA_A1,
                   A_A0  => ntRef_ntA_A0,
                   A_M0  => ntRef_ntA_M0,
                   A_CE  => ntRef_ntA_CE,
                   A_RS  => ntRef_ntA_RS,
                   A_CLK => ntRef_ntA_CLK
                 )
        @([sx+2,sy]);
    
    //
    // Layout CLMS and connect wires and tracks driven by it
    //
    sprintf(strVar, "CLMS_%d_%d", sx+2, sy+1);
    device CLMS *strVar
        port map (
                   DD  => ntRef_ntS_DD,        // Input from local SIB (I)
                   D4  => ntRef_ntS_D4, 
                   D3  => ntRef_ntS_D3, 
                   D2  => ntRef_ntS_D2, 
                   D1  => ntRef_ntS_D1, 
                   D0  => ntRef_ntS_D0, 
                   M3  => ntRef_ntS_M3, 
                   CD  => ntRef_ntS_CD, 
                   C4  => ntRef_ntS_C4, 
                   C3  => ntRef_ntS_C3, 
                   C2  => ntRef_ntS_C2, 
                   C1  => ntRef_ntS_C1, 
                   C0  => ntRef_ntS_C0, 
                   M2  => ntRef_ntS_M2, 
                   BD  => ntRef_ntS_BD, 
                   B4  => ntRef_ntS_B4, 
                   B3  => ntRef_ntS_B3, 
                   B2  => ntRef_ntS_B2, 
                   B1  => ntRef_ntS_B1, 
                   B0  => ntRef_ntS_B0, 
                   M1  => ntRef_ntS_M1, 
                   AD  => ntRef_ntS_AD, 
                   A4  => ntRef_ntS_A4, 
                   A3  => ntRef_ntS_A3, 
                   A2  => ntRef_ntS_A2, 
                   A1  => ntRef_ntS_A1, 
                   A0  => ntRef_ntS_A0, 
                   M0  => ntRef_ntS_M0, 
                   CE  => ntRef_ntS_CE, 
                   RS  => ntRef_ntS_RS, 
                   CLK => ntRef_ntS_CLK,

                   ACLK => ntRef_ntCLMA_CLKOUT,   //from CLMA

                   Y6CD => ntRef_ntCLMS_Y6CD,
                   Y6AB => ntRef_ntCLMS_Y6AB,
                   Q3   => ntRef_ntCLMS_Q3,  
                   Q2   => ntRef_ntCLMS_Q2,  
                   Q1   => ntRef_ntCLMS_Q1,  
                   Q0   => ntRef_ntCLMS_Q0,  
                   Y3   => ntRef_ntCLMS_Y3,  
                   Y2   => ntRef_ntCLMS_Y2,  
                   Y1   => ntRef_ntCLMS_Y1,  
                   Y0   => ntRef_ntCLMS_Y0,  
                   
                   L7OUT    => ntRef_ntCLMS_L7OUT,     
                   COUT     => ntRef_ntCLMS_COUT,
                   RSOUT    => ntRef_ntCLMS_RSOUT,     
                   CEOUT    => ntRef_ntCLMS_CEOUT,     
                   SHIFTOUT => ntRef_ntCLMS_SHIFTOUT
                 )
        @([sx+2,sy+1]);
        
        
    //
    // Layout CLMA and connect wires and tracks driven by it
    //
    sprintf(strVar, "CLMA_%d_%d", sx+1, sy+1);
    device CLMA *strVar
        port map (
                   DD  => ntRef_ntA_DD,        // Input from local SIB (I)
                   D4  => ntRef_ntA_D4, 
                   D3  => ntRef_ntA_D3, 
                   D2  => ntRef_ntA_D2, 
                   D1  => ntRef_ntA_D1, 
                   D0  => ntRef_ntA_D0, 
                   M3  => ntRef_ntA_M3, 
                   CD  => ntRef_ntA_CD, 
                   C4  => ntRef_ntA_C4, 
                   C3  => ntRef_ntA_C3, 
                   C2  => ntRef_ntA_C2, 
                   C1  => ntRef_ntA_C1, 
                   C0  => ntRef_ntA_C0, 
                   M2  => ntRef_ntA_M2, 
                   BD  => ntRef_ntA_BD, 
                   B4  => ntRef_ntA_B4, 
                   B3  => ntRef_ntA_B3, 
                   B2  => ntRef_ntA_B2, 
                   B1  => ntRef_ntA_B1, 
                   B0  => ntRef_ntA_B0, 
                   M1  => ntRef_ntA_M1, 
                   AD  => ntRef_ntA_AD, 
                   A4  => ntRef_ntA_A4, 
                   A3  => ntRef_ntA_A3, 
                   A2  => ntRef_ntA_A2, 
                   A1  => ntRef_ntA_A1, 
                   A0  => ntRef_ntA_A0, 
                   M0  => ntRef_ntA_M0, 
                   CE  => ntRef_ntA_CE, 
                   RS  => ntRef_ntA_RS, 
                   CLK => ntRef_ntA_CLK,
                   CLKOUT => ntRef_ntCLMA_CLKOUT,
                   
                   L7IN => ntRef_ntCLMS_L7OUT,     // Input from local CLMS (S)

                   Y6CD => ntRef_ntCLMA_Y6CD,
                   Y6AB => ntRef_ntCLMA_Y6AB,
                   Q3   => ntRef_ntCLMA_Q3,  
                   Q2   => ntRef_ntCLMA_Q2,  
                   Q1   => ntRef_ntCLMA_Q1,  
                   Q0   => ntRef_ntCLMA_Q0,  
                   Y3   => ntRef_ntCLMA_Y3,  
                   Y2   => ntRef_ntCLMA_Y2,  
                   Y1   => ntRef_ntCLMA_Y1,  
                   Y0   => ntRef_ntCLMA_Y0,  
                   
                   L7OUT    => ntRef_ntCLMA_L7OUT,     
                   COUT     => ntRef_ntCLMA_COUT,
                   RSOUT    => ntRef_ntCLMA_RSOUT,     
                   CEOUT    => ntRef_ntCLMA_CEOUT,     
                   SHIFTOUT => ntRef_ntCLMA_SHIFTOUT
                 )
        @([sx+1,sy+1]);
        
    //
    // Layout VCC and connect wires and tracks driven by it
    //
    sprintf(strVar, "VCC_%d_%d", sx, sy+1);
    device VCC *strVar
        port map (
                   VCCOUT   => ntRef_ntVCCOUT     // Output
                 )
    @([sx,sy+1]);
    
    //
    // Layout GND and connect wires and tracks driven by it
    //
    sprintf(strVar, "GND_%d_%d", sx, sy);
    device GND *strVar
        port map (
                   GNDOUT   => ntRef_ntGNDOUT     // Output
                 )
    @([sx,sy]);
    
}; // end of function place_logic_sa_tile


/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places all the device within a logic tile @[tx,ty].
             The logic tile include SRB, SIB, CLMA0, CLMA1, VCC, GND.
             The logic layout inside of a tile is as followings,


              ---------|---------|---------|---------
              
                V[0,1]    A0[1,1]  A1[2,1]

                G[0,0]    R[1,0]   I[2,0] 
              ---------|---------|---------|---------
            ]

  Revision History:

*****************************************************************************************/
function place_logic_aa_tile ( unsigned int tx, ty )
{
    string strVar;

    // Site index variable
    unsigned int sx, sy;

    // Calculate the site coordinate of the lower-left corner
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;

    //
    // Allocate wires for logic connection inside of a logic tile
    //
    
    //
    // Wires driven by SRB
    //
    
    // TO SIB
    sprintf(strVar, "ntZM1_%d_%d", sx+1, sy);
    &wire ntRef_ntZM1[13:0] = wire *strVar[13:0]   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntZM_%d_%d", sx+1, sy);
    &wire ntRef_ntZM[47:0] = wire *strVar[47:0]   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    // LOCAL
    sprintf(strVar, "ntZSS_%d_%d", sx+1, sy);
    &wire ntRef_ntZSS[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSN_%d_%d", sx+1, sy);
    &wire ntRef_ntZSN[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSE_%d_%d", sx+1, sy);
    &wire ntRef_ntZSE[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSW_%d_%d", sx+1, sy);
    &wire ntRef_ntZSW[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSNW_%d_%d", sx+1, sy);
    &wire ntRef_ntZSNW[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSNE_%d_%d", sx+1, sy);
    &wire ntRef_ntZSNE[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSSW_%d_%d", sx+1, sy);
    &wire ntRef_ntZSSW[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSSE_%d_%d", sx+1, sy);
    &wire ntRef_ntZSSE[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    
    // DOUBLE
    sprintf(strVar, "ntZDS_%d_%d", sx+1, sy);
    &wire ntRef_ntZDS[5:0] = wire *strVar[5:0] /*pragma PAP_ARC_ITC_TYPE="DOUBLE" */ ;
    
    sprintf(strVar, "ntZDN_%d_%d", sx+1, sy);
    &wire ntRef_ntZDN[5:0] = wire *strVar[5:0] /*pragma PAP_ARC_ITC_TYPE="DOUBLE" */ ;

    sprintf(strVar, "ntZDE_%d_%d", sx+1, sy);
    &wire ntRef_ntZDE[5:0] = wire *strVar[5:0] /*pragma PAP_ARC_ITC_TYPE="DOUBLE" */ ;
    
    sprintf(strVar, "ntZDW_%d_%d", sx+1, sy);
    &wire ntRef_ntZDW[5:0] = wire *strVar[5:0] /*pragma PAP_ARC_ITC_TYPE="DOUBLE" */ ;
    
    // QUAD
    sprintf(strVar, "ntZQS_%d_%d", sx+1, sy);
    &wire ntRef_ntZQS[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="QUAD" */ ;
    
    sprintf(strVar, "ntZQN_%d_%d", sx+1, sy);
    &wire ntRef_ntZQN[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="QUAD" */ ;
    
    sprintf(strVar, "ntZQE_%d_%d", sx+1, sy);
    &wire ntRef_ntZQE[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="QUAD" */ ;
    
    sprintf(strVar, "ntZQW_%d_%d", sx+1, sy);
    &wire ntRef_ntZQW[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="QUAD" */ ;
    
    // LONG LINE
    //sprintf(strVar, "ntLH0_%d_%d", sx+1, sy);
    //&wire ntRef_ntLH0 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLH2_%d_%d", sx+1, sy);
    //&wire ntRef_ntLH2 = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLH0__%d_%d", sx+1, sy);
    //&wire ntRef_ntLH0_ = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLH2__%d_%d", sx+1, sy);
    //&wire ntRef_ntLH2_ = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLV0_%d_%d", sx+1, sy);
    //&wire ntRef_ntLV0 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLV2_%d_%d", sx+1, sy);
    //&wire ntRef_ntLV2 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLV0__%d_%d", sx+1, sy);
    //&wire ntRef_ntLV0_ = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLV2__%d_%d", sx+1, sy);
    //&wire ntRef_ntLV2_ = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;

    //
    // Wires driven by SIB
    //
    // TO CLMS
    sprintf(strVar, "ntS_DD_%d_%d", sx+2, sy);
    &wire ntRef_ntS_DD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_D4_%d_%d", sx+2, sy);
    &wire ntRef_ntS_D4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_D3_%d_%d", sx+2, sy);
    &wire ntRef_ntS_D3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_D2_%d_%d", sx+2, sy);
    &wire ntRef_ntS_D2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_D1_%d_%d", sx+2, sy);
    &wire ntRef_ntS_D1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_D0_%d_%d", sx+2, sy);
    &wire ntRef_ntS_D0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_M3_%d_%d", sx+2, sy);
    &wire ntRef_ntS_M3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntS_CD_%d_%d", sx+2, sy);
    &wire ntRef_ntS_CD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_C4_%d_%d", sx+2, sy);
    &wire ntRef_ntS_C4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_C3_%d_%d", sx+2, sy);
    &wire ntRef_ntS_C3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_C2_%d_%d", sx+2, sy);
    &wire ntRef_ntS_C2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_C1_%d_%d", sx+2, sy);
    &wire ntRef_ntS_C1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_C0_%d_%d", sx+2, sy);
    &wire ntRef_ntS_C0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_M2_%d_%d", sx+2, sy);
    &wire ntRef_ntS_M2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntS_BD_%d_%d", sx+2, sy);
    &wire ntRef_ntS_BD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_B4_%d_%d", sx+2, sy);
    &wire ntRef_ntS_B4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_B3_%d_%d", sx+2, sy);
    &wire ntRef_ntS_B3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_B2_%d_%d", sx+2, sy);
    &wire ntRef_ntS_B2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_B1_%d_%d", sx+2, sy);
    &wire ntRef_ntS_B1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_B0_%d_%d", sx+2, sy);
    &wire ntRef_ntS_B0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_M1_%d_%d", sx+2, sy);
    &wire ntRef_ntS_M1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntS_AD_%d_%d", sx+2, sy);
    &wire ntRef_ntS_AD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_A4_%d_%d", sx+2, sy);
    &wire ntRef_ntS_A4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_A3_%d_%d", sx+2, sy);
    &wire ntRef_ntS_A3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_A2_%d_%d", sx+2, sy);
    &wire ntRef_ntS_A2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_A1_%d_%d", sx+2, sy);
    &wire ntRef_ntS_A1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_A0_%d_%d", sx+2, sy);
    &wire ntRef_ntS_A0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_M0_%d_%d", sx+2, sy);
    &wire ntRef_ntS_M0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntS_CE_%d_%d", sx+2, sy);
    &wire ntRef_ntS_CE = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_RS_%d_%d", sx+2, sy);
    &wire ntRef_ntS_RS = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_CLK_%d_%d", sx+2, sy);
    &wire ntRef_ntS_CLK = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    // TO CLMA
    sprintf(strVar, "ntA_DD_%d_%d", sx+2, sy);
    &wire ntRef_ntA_DD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_D4_%d_%d", sx+2, sy);
    &wire ntRef_ntA_D4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_D3_%d_%d", sx+2, sy);
    &wire ntRef_ntA_D3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_D2_%d_%d", sx+2, sy);
    &wire ntRef_ntA_D2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_D1_%d_%d", sx+2, sy);
    &wire ntRef_ntA_D1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_D0_%d_%d", sx+2, sy);
    &wire ntRef_ntA_D0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_M3_%d_%d", sx+2, sy);
    &wire ntRef_ntA_M3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntA_CD_%d_%d", sx+2, sy);
    &wire ntRef_ntA_CD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_C4_%d_%d", sx+2, sy);
    &wire ntRef_ntA_C4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_C3_%d_%d", sx+2, sy);
    &wire ntRef_ntA_C3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_C2_%d_%d", sx+2, sy);
    &wire ntRef_ntA_C2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_C1_%d_%d", sx+2, sy);
    &wire ntRef_ntA_C1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_C0_%d_%d", sx+2, sy);
    &wire ntRef_ntA_C0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_M2_%d_%d", sx+2, sy);
    &wire ntRef_ntA_M2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntA_BD_%d_%d", sx+2, sy);
    &wire ntRef_ntA_BD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_B4_%d_%d", sx+2, sy);
    &wire ntRef_ntA_B4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_B3_%d_%d", sx+2, sy);
    &wire ntRef_ntA_B3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_B2_%d_%d", sx+2, sy);
    &wire ntRef_ntA_B2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_B1_%d_%d", sx+2, sy);
    &wire ntRef_ntA_B1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_B0_%d_%d", sx+2, sy);
    &wire ntRef_ntA_B0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_M1_%d_%d", sx+2, sy);
    &wire ntRef_ntA_M1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntA_AD_%d_%d", sx+2, sy);
    &wire ntRef_ntA_AD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_A4_%d_%d", sx+2, sy);
    &wire ntRef_ntA_A4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_A3_%d_%d", sx+2, sy);
    &wire ntRef_ntA_A3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_A2_%d_%d", sx+2, sy);
    &wire ntRef_ntA_A2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_A1_%d_%d", sx+2, sy);
    &wire ntRef_ntA_A1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_A0_%d_%d", sx+2, sy);
    &wire ntRef_ntA_A0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_M0_%d_%d", sx+2, sy);
    &wire ntRef_ntA_M0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntA_CE_%d_%d", sx+2, sy);
    &wire ntRef_ntA_CE = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_RS_%d_%d", sx+2, sy);
    &wire ntRef_ntA_RS = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_CLK_%d_%d", sx+2, sy);
    &wire ntRef_ntA_CLK = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Wires driven by CLMA1
    //
    sprintf(strVar, "ntY6CD_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Y6CD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY6AB_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Y6AB = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntQ3_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Q3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntQ2_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Q2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntQ1_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Q1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntQ0_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Q0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY3_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Y3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY2_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Y2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY1_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Y1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY0_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_Y0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntL7OUT_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_L7OUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntCOUT_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_COUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRSOUT_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_RSOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntCEOUT_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_CEOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntSHIFTOUT_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLMS_SHIFTOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Wires driven by CLMA0
    //
    sprintf(strVar, "ntY6CD_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Y6CD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY6AB_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Y6AB = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntQ3_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Q3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntQ2_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Q2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntQ1_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Q1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntQ0_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Q0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY3_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Y3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY2_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Y2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY1_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Y1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntY0_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_Y0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntL7OUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_L7OUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntCOUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_COUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRSOUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_RSOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntCEOUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_CEOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntSHIFTOUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_SHIFTOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntCLKOUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCLMA_CLKOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Wires driven by VCC or GND
    //
    sprintf(strVar, "ntVCCOUT_%d_%d", sx, sy+1);
    &wire ntRef_ntVCCOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntGNDOUT_%d_%d", sx, sy);
    &wire ntRef_ntGNDOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout SRB and connect wires and tracks driven by it
    //
    sprintf(strVar, "SRB_%d_%d", sx+1, sy);
    device SRB *strVar
        port map (
                   VCC    => ntRef_ntVCCOUT,       // Inputs from local VCC (V)
                   GND    => ntRef_ntGNDOUT,       // Inputs from local GND (G)
                   
                   S_Y6CD => ntRef_ntCLMS_Y6CD,    // Inputs from local CLMA1 (A1)
                   S_Y6AB => ntRef_ntCLMS_Y6AB,
                   S_Q3   => ntRef_ntCLMS_Q3,
                   S_Q2   => ntRef_ntCLMS_Q2,
                   S_Q1   => ntRef_ntCLMS_Q1,
                   S_Q0   => ntRef_ntCLMS_Q0,
                   S_Y3   => ntRef_ntCLMS_Y3,
                   S_Y2   => ntRef_ntCLMS_Y2,
                   S_Y1   => ntRef_ntCLMS_Y1,
                   S_Y0   => ntRef_ntCLMS_Y0,

                   A_Y6CD => ntRef_ntCLMA_Y6CD,    // Inputs from local CLMA0 (A0)
                   A_Y6AB => ntRef_ntCLMA_Y6AB,
                   A_Q3   => ntRef_ntCLMA_Q3,
                   A_Q2   => ntRef_ntCLMA_Q2,
                   A_Q1   => ntRef_ntCLMA_Q1,
                   A_Q0   => ntRef_ntCLMA_Q0,
                   A_Y3   => ntRef_ntCLMA_Y3,
                   A_Y2   => ntRef_ntCLMA_Y2,
                   A_Y1   => ntRef_ntCLMA_Y1,
                   A_Y0   => ntRef_ntCLMA_Y0,

                   ZM1   => ntRef_ntZM1,
                   ZM    => ntRef_ntZM,

                   ZSS   => ntRef_ntZSS,
                   ZSN   => ntRef_ntZSN,
                   ZSE   => ntRef_ntZSE,
                   ZSW   => ntRef_ntZSW,
                   ZSNW  => ntRef_ntZSNW,
                   ZSNE  => ntRef_ntZSNE,
                   ZSSW  => ntRef_ntZSSW,
                   ZSSE  => ntRef_ntZSSE,
                   ZDS   => ntRef_ntZDS,
                   ZDN   => ntRef_ntZDN,
                   ZDE   => ntRef_ntZDE,
                   ZDW   => ntRef_ntZDW,
                   ZQS   => ntRef_ntZQS,
                   ZQN   => ntRef_ntZQN,
                   ZQE   => ntRef_ntZQE,
                   ZQW   => ntRef_ntZQW
                   
                   //LH0   => ntRef_ntLH0,
                   //LH2   => ntRef_ntLH2,
                   //LH0_  => ntRef_ntLH0_,
                   //LH2_  => ntRef_ntLH2_,
                   //LV0   => ntRef_ntLV0,
                   //LV2   => ntRef_ntLV2,
                   //LV0_  => ntRef_ntLV0_,
                   //LV2_  => ntRef_ntLV2_
                 )
        @([sx+1,sy]);
        
        
    //
    // Layout SIB and connect wires and tracks driven by it
    //
    sprintf(strVar, "SIB_%d_%d", sx+2, sy);
    device SIB *strVar
        port map (
                   IM1  => ntRef_ntZM1,          // Input from local SRB (R)
                   IM   => ntRef_ntZM,
                   
                   S_DD  => ntRef_ntS_DD,
                   S_D4  => ntRef_ntS_D4,
                   S_D3  => ntRef_ntS_D3,
                   S_D2  => ntRef_ntS_D2,
                   S_D1  => ntRef_ntS_D1,
                   S_D0  => ntRef_ntS_D0,
                   S_M3  => ntRef_ntS_M3,
                   S_CD  => ntRef_ntS_CD,
                   S_C4  => ntRef_ntS_C4,
                   S_C3  => ntRef_ntS_C3,
                   S_C2  => ntRef_ntS_C2,
                   S_C1  => ntRef_ntS_C1,
                   S_C0  => ntRef_ntS_C0,
                   S_M2  => ntRef_ntS_M2,
                   S_BD  => ntRef_ntS_BD,
                   S_B4  => ntRef_ntS_B4,
                   S_B3  => ntRef_ntS_B3,
                   S_B2  => ntRef_ntS_B2,
                   S_B1  => ntRef_ntS_B1,
                   S_B0  => ntRef_ntS_B0,
                   S_M1  => ntRef_ntS_M1,
                   S_AD  => ntRef_ntS_AD,
                   S_A4  => ntRef_ntS_A4,
                   S_A3  => ntRef_ntS_A3,
                   S_A2  => ntRef_ntS_A2,
                   S_A1  => ntRef_ntS_A1,
                   S_A0  => ntRef_ntS_A0,
                   S_M0  => ntRef_ntS_M0,
                   S_CE  => ntRef_ntS_CE,
                   S_RS  => ntRef_ntS_RS,
                   S_CLK => ntRef_ntS_CLK,

                   A_DD  => ntRef_ntA_DD,
                   A_D4  => ntRef_ntA_D4,
                   A_D3  => ntRef_ntA_D3,
                   A_D2  => ntRef_ntA_D2,
                   A_D1  => ntRef_ntA_D1,
                   A_D0  => ntRef_ntA_D0,
                   A_M3  => ntRef_ntA_M3,
                   A_CD  => ntRef_ntA_CD,
                   A_C4  => ntRef_ntA_C4,
                   A_C3  => ntRef_ntA_C3,
                   A_C2  => ntRef_ntA_C2,
                   A_C1  => ntRef_ntA_C1,
                   A_C0  => ntRef_ntA_C0,
                   A_M2  => ntRef_ntA_M2,
                   A_BD  => ntRef_ntA_BD,
                   A_B4  => ntRef_ntA_B4,
                   A_B3  => ntRef_ntA_B3,
                   A_B2  => ntRef_ntA_B2,
                   A_B1  => ntRef_ntA_B1,
                   A_B0  => ntRef_ntA_B0,
                   A_M1  => ntRef_ntA_M1,
                   A_AD  => ntRef_ntA_AD,
                   A_A4  => ntRef_ntA_A4,
                   A_A3  => ntRef_ntA_A3,
                   A_A2  => ntRef_ntA_A2,
                   A_A1  => ntRef_ntA_A1,
                   A_A0  => ntRef_ntA_A0,
                   A_M0  => ntRef_ntA_M0,
                   A_CE  => ntRef_ntA_CE,
                   A_RS  => ntRef_ntA_RS,
                   A_CLK => ntRef_ntA_CLK
                 )
        @([sx+2,sy]);
    
    //
    // Layout CLMA1 and connect wires and tracks driven by it
    //
    sprintf(strVar, "CLMA_%d_%d", sx+2, sy+1);
    device CLMA *strVar
        port map (
                   DD  => ntRef_ntS_DD,        // Input from local SIB (I)
                   D4  => ntRef_ntS_D4, 
                   D3  => ntRef_ntS_D3, 
                   D2  => ntRef_ntS_D2, 
                   D1  => ntRef_ntS_D1, 
                   D0  => ntRef_ntS_D0, 
                   M3  => ntRef_ntS_M3, 
                   CD  => ntRef_ntS_CD, 
                   C4  => ntRef_ntS_C4, 
                   C3  => ntRef_ntS_C3, 
                   C2  => ntRef_ntS_C2, 
                   C1  => ntRef_ntS_C1, 
                   C0  => ntRef_ntS_C0, 
                   M2  => ntRef_ntS_M2, 
                   BD  => ntRef_ntS_BD, 
                   B4  => ntRef_ntS_B4, 
                   B3  => ntRef_ntS_B3, 
                   B2  => ntRef_ntS_B2, 
                   B1  => ntRef_ntS_B1, 
                   B0  => ntRef_ntS_B0, 
                   M1  => ntRef_ntS_M1, 
                   AD  => ntRef_ntS_AD, 
                   A4  => ntRef_ntS_A4, 
                   A3  => ntRef_ntS_A3, 
                   A2  => ntRef_ntS_A2, 
                   A1  => ntRef_ntS_A1, 
                   A0  => ntRef_ntS_A0, 
                   M0  => ntRef_ntS_M0, 
                   CE  => ntRef_ntS_CE, 
                   RS  => ntRef_ntS_RS, 
                   CLK => ntRef_ntS_CLK,

                   Y6CD => ntRef_ntCLMS_Y6CD,
                   Y6AB => ntRef_ntCLMS_Y6AB,
                   Q3   => ntRef_ntCLMS_Q3,  
                   Q2   => ntRef_ntCLMS_Q2,  
                   Q1   => ntRef_ntCLMS_Q1,  
                   Q0   => ntRef_ntCLMS_Q0,  
                   Y3   => ntRef_ntCLMS_Y3,  
                   Y2   => ntRef_ntCLMS_Y2,  
                   Y1   => ntRef_ntCLMS_Y1,  
                   Y0   => ntRef_ntCLMS_Y0,  
                   
                   L7OUT    => ntRef_ntCLMS_L7OUT,     
                   COUT     => ntRef_ntCLMS_COUT,
                   RSOUT    => ntRef_ntCLMS_RSOUT,     
                   CEOUT    => ntRef_ntCLMS_CEOUT,     
                   SHIFTOUT => ntRef_ntCLMS_SHIFTOUT
                 )
        @([sx+2,sy+1]);
        
        
    //
    // Layout CLMA0 and connect wires and tracks driven by it
    //
    sprintf(strVar, "CLMA_%d_%d", sx+1, sy+1);
    device CLMA *strVar
        port map (
                   DD  => ntRef_ntA_DD,        // Input from local SIB (I)
                   D4  => ntRef_ntA_D4, 
                   D3  => ntRef_ntA_D3, 
                   D2  => ntRef_ntA_D2, 
                   D1  => ntRef_ntA_D1, 
                   D0  => ntRef_ntA_D0, 
                   M3  => ntRef_ntA_M3, 
                   CD  => ntRef_ntA_CD, 
                   C4  => ntRef_ntA_C4, 
                   C3  => ntRef_ntA_C3, 
                   C2  => ntRef_ntA_C2, 
                   C1  => ntRef_ntA_C1, 
                   C0  => ntRef_ntA_C0, 
                   M2  => ntRef_ntA_M2, 
                   BD  => ntRef_ntA_BD, 
                   B4  => ntRef_ntA_B4, 
                   B3  => ntRef_ntA_B3, 
                   B2  => ntRef_ntA_B2, 
                   B1  => ntRef_ntA_B1, 
                   B0  => ntRef_ntA_B0, 
                   M1  => ntRef_ntA_M1, 
                   AD  => ntRef_ntA_AD, 
                   A4  => ntRef_ntA_A4, 
                   A3  => ntRef_ntA_A3, 
                   A2  => ntRef_ntA_A2, 
                   A1  => ntRef_ntA_A1, 
                   A0  => ntRef_ntA_A0, 
                   M0  => ntRef_ntA_M0, 
                   CE  => ntRef_ntA_CE, 
                   RS  => ntRef_ntA_RS, 
                   CLK => ntRef_ntA_CLK,
                   
                   L7IN => ntRef_ntCLMS_L7OUT,     // Input from local CLMA1 (A1)

                   Y6CD => ntRef_ntCLMA_Y6CD,
                   Y6AB => ntRef_ntCLMA_Y6AB,
                   Q3   => ntRef_ntCLMA_Q3,  
                   Q2   => ntRef_ntCLMA_Q2,  
                   Q1   => ntRef_ntCLMA_Q1,  
                   Q0   => ntRef_ntCLMA_Q0,  
                   Y3   => ntRef_ntCLMA_Y3,  
                   Y2   => ntRef_ntCLMA_Y2,  
                   Y1   => ntRef_ntCLMA_Y1,  
                   Y0   => ntRef_ntCLMA_Y0,  
                   
                   L7OUT    => ntRef_ntCLMA_L7OUT,     
                   COUT     => ntRef_ntCLMA_COUT,
                   RSOUT    => ntRef_ntCLMA_RSOUT,     
                   CEOUT    => ntRef_ntCLMA_CEOUT,     
                   SHIFTOUT => ntRef_ntCLMA_SHIFTOUT
                 )
        @([sx+1,sy+1]);
        
    //
    // Layout VCC and connect wires and tracks driven by it
    //
    sprintf(strVar, "VCC_%d_%d", sx, sy+1);
    device VCC *strVar
        port map (
                   VCCOUT   => ntRef_ntVCCOUT     // Output
                 )
    @([sx,sy+1]);
    
    //
    // Layout GND and connect wires and tracks driven by it
    //
    sprintf(strVar, "GND_%d_%d", sx, sy);
    device GND *strVar
        port map (
                   GNDOUT   => ntRef_ntGNDOUT     // Output
                 )
    @([sx,sy]);

}; // end of function place_logic_aa_tile

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places all the device within a logic tile @[tx,ty].
             The logic tile include SRB, SIB, CIM, VCC, GND.
             The logic layout inside of a tile is as followings,

              ---------|---------|---------|---------
              
                V[0,1]            
                G[0,0]    R[1,0]   I[2,0] 
              ---------|---------|---------|---------
            ]

  Revision History:

*****************************************************************************************/
function place_base_tile ( unsigned int tx, ty )
{
    string strVar;

    // Site index variable
    unsigned int sx, sy;

    // Calculate the site coordinate of the lower-left corner
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;

    //
    // Allocate wires for logic connection inside of a logic tile
    //
    
    //
    // Wires driven by SRB
    //
    
    // TO SIB
    sprintf(strVar, "ntZM1_%d_%d", sx+1, sy);
    &wire ntRef_ntZM1[13:0] = wire *strVar[13:0]   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntZM_%d_%d", sx+1, sy);
    &wire ntRef_ntZM[47:0] = wire *strVar[47:0]   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    // LOCAL
    sprintf(strVar, "ntZSS_%d_%d", sx+1, sy);
    &wire ntRef_ntZSS[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSN_%d_%d", sx+1, sy);
    &wire ntRef_ntZSN[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSE_%d_%d", sx+1, sy);
    &wire ntRef_ntZSE[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSW_%d_%d", sx+1, sy);
    &wire ntRef_ntZSW[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSNW_%d_%d", sx+1, sy);
    &wire ntRef_ntZSNW[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSNE_%d_%d", sx+1, sy);
    &wire ntRef_ntZSNE[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSSW_%d_%d", sx+1, sy);
    &wire ntRef_ntZSSW[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntZSSE_%d_%d", sx+1, sy);
    &wire ntRef_ntZSSE[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    
    // DOUBLE
    sprintf(strVar, "ntZDS_%d_%d", sx+1, sy);
    &wire ntRef_ntZDS[5:0] = wire *strVar[5:0] /*pragma PAP_ARC_ITC_TYPE="DOUBLE" */ ;
    
    sprintf(strVar, "ntZDN_%d_%d", sx+1, sy);
    &wire ntRef_ntZDN[5:0] = wire *strVar[5:0] /*pragma PAP_ARC_ITC_TYPE="DOUBLE" */ ;

    sprintf(strVar, "ntZDE_%d_%d", sx+1, sy);
    &wire ntRef_ntZDE[5:0] = wire *strVar[5:0] /*pragma PAP_ARC_ITC_TYPE="DOUBLE" */ ;
    
    sprintf(strVar, "ntZDW_%d_%d", sx+1, sy);
    &wire ntRef_ntZDW[5:0] = wire *strVar[5:0] /*pragma PAP_ARC_ITC_TYPE="DOUBLE" */ ;
    
    // QUAD
    sprintf(strVar, "ntZQS_%d_%d", sx+1, sy);
    &wire ntRef_ntZQS[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="QUAD" */ ;
    
    sprintf(strVar, "ntZQN_%d_%d", sx+1, sy);
    &wire ntRef_ntZQN[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="QUAD" */ ;
    
    sprintf(strVar, "ntZQE_%d_%d", sx+1, sy);
    &wire ntRef_ntZQE[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="QUAD" */ ;
    
    sprintf(strVar, "ntZQW_%d_%d", sx+1, sy);
    &wire ntRef_ntZQW[5:0] = wire *strVar[5:0]   /*pragma PAP_ARC_ITC_TYPE="QUAD" */ ;
    
    // LONG LINE
    //sprintf(strVar, "ntLH0_%d_%d", sx+1, sy);
    //&wire ntRef_ntLH0 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLH2_%d_%d", sx+1, sy);
    //&wire ntRef_ntLH2 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLH0__%d_%d", sx+1, sy);
    //&wire ntRef_ntLH0_ = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLH2__%d_%d", sx+1, sy);
    //&wire ntRef_ntLH2_ = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLV0_%d_%d", sx+1, sy);
    //&wire ntRef_ntLV0 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLV2_%d_%d", sx+1, sy);
    //&wire ntRef_ntLV2 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLV0__%d_%d", sx+1, sy);
    //&wire ntRef_ntLV0_ = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
    
    //sprintf(strVar, "ntLV2__%d_%d", sx+1, sy);
    //&wire ntRef_ntLV2_ = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LONG" */ ;
  
    //
    // Wires driven by SIB
    //
    sprintf(strVar, "ntS_DD_%d_%d", sx+2, sy);
    &wire ntRef_ntS_DD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_D4_%d_%d", sx+2, sy);
    &wire ntRef_ntS_D4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_D3_%d_%d", sx+2, sy);
    &wire ntRef_ntS_D3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_D2_%d_%d", sx+2, sy);
    &wire ntRef_ntS_D2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_D1_%d_%d", sx+2, sy);
    &wire ntRef_ntS_D1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_D0_%d_%d", sx+2, sy);
    &wire ntRef_ntS_D0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_M3_%d_%d", sx+2, sy);
    &wire ntRef_ntS_M3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntS_CD_%d_%d", sx+2, sy);
    &wire ntRef_ntS_CD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_C4_%d_%d", sx+2, sy);
    &wire ntRef_ntS_C4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_C3_%d_%d", sx+2, sy);
    &wire ntRef_ntS_C3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_C2_%d_%d", sx+2, sy);
    &wire ntRef_ntS_C2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_C1_%d_%d", sx+2, sy);
    &wire ntRef_ntS_C1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_C0_%d_%d", sx+2, sy);
    &wire ntRef_ntS_C0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_M2_%d_%d", sx+2, sy);
    &wire ntRef_ntS_M2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntS_BD_%d_%d", sx+2, sy);
    &wire ntRef_ntS_BD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_B4_%d_%d", sx+2, sy);
    &wire ntRef_ntS_B4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_B3_%d_%d", sx+2, sy);
    &wire ntRef_ntS_B3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_B2_%d_%d", sx+2, sy);
    &wire ntRef_ntS_B2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_B1_%d_%d", sx+2, sy);
    &wire ntRef_ntS_B1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_B0_%d_%d", sx+2, sy);
    &wire ntRef_ntS_B0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_M1_%d_%d", sx+2, sy);
    &wire ntRef_ntS_M1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntS_AD_%d_%d", sx+2, sy);
    &wire ntRef_ntS_AD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_A4_%d_%d", sx+2, sy);
    &wire ntRef_ntS_A4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_A3_%d_%d", sx+2, sy);
    &wire ntRef_ntS_A3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_A2_%d_%d", sx+2, sy);
    &wire ntRef_ntS_A2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_A1_%d_%d", sx+2, sy);
    &wire ntRef_ntS_A1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_A0_%d_%d", sx+2, sy);
    &wire ntRef_ntS_A0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_M0_%d_%d", sx+2, sy);
    &wire ntRef_ntS_M0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntS_CE_%d_%d", sx+2, sy);
    &wire ntRef_ntS_CE = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_RS_%d_%d", sx+2, sy);
    &wire ntRef_ntS_RS = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntS_CLK_%d_%d", sx+2, sy);
    &wire ntRef_ntS_CLK = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntA_DD_%d_%d", sx+2, sy);
    &wire ntRef_ntA_DD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_D4_%d_%d", sx+2, sy);
    &wire ntRef_ntA_D4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_D3_%d_%d", sx+2, sy);
    &wire ntRef_ntA_D3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_D2_%d_%d", sx+2, sy);
    &wire ntRef_ntA_D2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_D1_%d_%d", sx+2, sy);
    &wire ntRef_ntA_D1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_D0_%d_%d", sx+2, sy);
    &wire ntRef_ntA_D0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_M3_%d_%d", sx+2, sy);
    &wire ntRef_ntA_M3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntA_CD_%d_%d", sx+2, sy);
    &wire ntRef_ntA_CD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_C4_%d_%d", sx+2, sy);
    &wire ntRef_ntA_C4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_C3_%d_%d", sx+2, sy);
    &wire ntRef_ntA_C3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_C2_%d_%d", sx+2, sy);
    &wire ntRef_ntA_C2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_C1_%d_%d", sx+2, sy);
    &wire ntRef_ntA_C1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_C0_%d_%d", sx+2, sy);
    &wire ntRef_ntA_C0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_M2_%d_%d", sx+2, sy);
    &wire ntRef_ntA_M2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntA_BD_%d_%d", sx+2, sy);
    &wire ntRef_ntA_BD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_B4_%d_%d", sx+2, sy);
    &wire ntRef_ntA_B4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_B3_%d_%d", sx+2, sy);
    &wire ntRef_ntA_B3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_B2_%d_%d", sx+2, sy);
    &wire ntRef_ntA_B2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_B1_%d_%d", sx+2, sy);
    &wire ntRef_ntA_B1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_B0_%d_%d", sx+2, sy);
    &wire ntRef_ntA_B0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_M1_%d_%d", sx+2, sy);
    &wire ntRef_ntA_M1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntA_AD_%d_%d", sx+2, sy);
    &wire ntRef_ntA_AD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_A4_%d_%d", sx+2, sy);
    &wire ntRef_ntA_A4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_A3_%d_%d", sx+2, sy);
    &wire ntRef_ntA_A3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_A2_%d_%d", sx+2, sy);
    &wire ntRef_ntA_A2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_A1_%d_%d", sx+2, sy);
    &wire ntRef_ntA_A1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_A0_%d_%d", sx+2, sy);
    &wire ntRef_ntA_A0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_M0_%d_%d", sx+2, sy);
    &wire ntRef_ntA_M0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    sprintf(strVar, "ntA_CE_%d_%d", sx+2, sy);
    &wire ntRef_ntA_CE = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_RS_%d_%d", sx+2, sy);
    &wire ntRef_ntA_RS = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntA_CLK_%d_%d", sx+2, sy);
    &wire ntRef_ntA_CLK = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Wires driven by VCC or GND
    //
    sprintf(strVar, "ntVCCOUT_%d_%d", sx, sy+1);
    &wire ntRef_ntVCCOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntGNDOUT_%d_%d", sx, sy);
    &wire ntRef_ntGNDOUT = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Wires driven by CIM
    //
    sprintf(strVar, "ntS_IDD_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IDD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_ID4_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_ID4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_ID3_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_ID3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_ID2_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_ID2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_ID1_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_ID1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_ID0_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_ID0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IM3_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IM3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    //
    sprintf(strVar, "ntS_ICD_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_ICD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IC4_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IC4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IC3_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IC3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IC2_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IC2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IC1_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IC1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IC0_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IC0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IM2_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IM2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    //
    sprintf(strVar, "ntS_IBD_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IBD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IB4_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IB4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IB3_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IB3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IB2_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IB2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IB1_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IB1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IB0_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IB0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IM1_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IM1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    //
    sprintf(strVar, "ntS_IAD_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IAD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IA4_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IA4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IA3_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IA3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IA2_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IA2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IA1_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IA1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IA0_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IA0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IM0_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IM0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    //
    sprintf(strVar, "ntS_ICE_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_ICE = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_IRS_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_IRS = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_ICLK_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_ICLK = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    //TO SRB
    sprintf(strVar, "ntS_Y0_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_Y0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_Y1_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_Y1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_Y2_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_Y2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_Y3_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_Y3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_Q0_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_Q0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_Q1_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_Q1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_Q2_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_Q2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_Q3_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_Q3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_Y6AB_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_Y6AB = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntS_Y6CD_%d_%d", sx+3, sy+2);
    &wire ntRef_ntS_Y6CD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    //
    sprintf(strVar, "ntA_IDD_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IDD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_ID4_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_ID4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_ID3_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_ID3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_ID2_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_ID2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_ID1_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_ID1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_ID0_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_ID0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IM3_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IM3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    //
    sprintf(strVar, "ntA_ICD_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_ICD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IC4_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IC4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IC3_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IC3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IC2_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IC2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IC1_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IC1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IC0_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IC0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IM2_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IM2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    //
    sprintf(strVar, "ntA_IBD_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IBD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IB4_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IB4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IB3_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IB3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IB2_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IB2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IB1_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IB1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IB0_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IB0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IM1_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IM1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    //
    sprintf(strVar, "ntA_IAD_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IAD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IA4_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IA4 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IA3_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IA3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IA2_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IA2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IA1_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IA1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IA0_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IA0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IM0_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IM0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    //
    sprintf(strVar, "ntA_ICE_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_ICE = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_IRS_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_IRS = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_ICLK_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_ICLK = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    //TO SRB
    sprintf(strVar, "ntA_Y0_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_Y0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_Y1_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_Y1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_Y2_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_Y2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_Y3_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_Y3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_Q0_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_Q0 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_Q1_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_Q1 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_Q2_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_Q2 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_Q3_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_Q3 = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_Y6AB_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_Y6AB = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntA_Y6CD_%d_%d", sx+3, sy+2);
    &wire ntRef_ntA_Y6CD = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    //
    // Layout SRB and connect wires and tracks driven by it
    //
    sprintf(strVar, "SRB_%d_%d", sx+1, sy);
    device SRB *strVar
        port map (
                   VCC    => ntRef_ntVCCOUT,     // Input from local VCC (V)
                   GND    => ntRef_ntGNDOUT,     // Input from local GND (G)
                   S_Y0   => ntRef_ntS_Y0,      // Input from local CIM (C)
                   S_Y1   => ntRef_ntS_Y1,  
                   S_Y2   => ntRef_ntS_Y2,  
                   S_Y3   => ntRef_ntS_Y3,  
                   S_Q0   => ntRef_ntS_Q0,  
                   S_Q1   => ntRef_ntS_Q1,  
                   S_Q2   => ntRef_ntS_Q2,  
                   S_Q3   => ntRef_ntS_Q3,  
                   S_Y6AB => ntRef_ntS_Y6AB,
                   S_Y6CD => ntRef_ntS_Y6CD,
                                            
                   A_Y0   => ntRef_ntA_Y0,  
                   A_Y1   => ntRef_ntA_Y1,  
                   A_Y2   => ntRef_ntA_Y2,  
                   A_Y3   => ntRef_ntA_Y3,  
                   A_Q0   => ntRef_ntA_Q0,  
                   A_Q1   => ntRef_ntA_Q1,  
                   A_Q2   => ntRef_ntA_Q2,  
                   A_Q3   => ntRef_ntA_Q3,  
                   A_Y6AB => ntRef_ntA_Y6AB,
                   A_Y6CD => ntRef_ntA_Y6CD,
                   
                   ZM1   => ntRef_ntZM1,
                   ZM    => ntRef_ntZM,

                   ZSS   => ntRef_ntZSS,
                   ZSN   => ntRef_ntZSN,
                   ZSE   => ntRef_ntZSE,
                   ZSW   => ntRef_ntZSW,
                   ZSNW  => ntRef_ntZSNW,
                   ZSNE  => ntRef_ntZSNE,
                   ZSSW  => ntRef_ntZSSW,
                   ZSSE  => ntRef_ntZSSE,
                   ZDS   => ntRef_ntZDS,
                   ZDN   => ntRef_ntZDN,
                   ZDE   => ntRef_ntZDE,
                   ZDW   => ntRef_ntZDW,
                   ZQS   => ntRef_ntZQS,
                   ZQN   => ntRef_ntZQN,
                   ZQE   => ntRef_ntZQE,
                   ZQW   => ntRef_ntZQW
                   
                   //LH0   => ntRef_ntLH0,
                   //LH2   => ntRef_ntLH2,
                   //LH0_  => ntRef_ntLH0_,
                   //LH2_  => ntRef_ntLH2_,
                   //LV0   => ntRef_ntLV0,
                   //LV2   => ntRef_ntLV2,
                   //LV0_  => ntRef_ntLV0_,
                   //LV2_  => ntRef_ntLV2_
                 )
        @([sx+1,sy]);
        
        
    //
    // Layout SIB and connect wires and tracks driven by it
    //
    sprintf(strVar, "SIB_%d_%d", sx+2, sy);
    device SIB *strVar
        port map (
                   IM1  => ntRef_ntZM1,          // Input from local SRB (R)
                   IM   => ntRef_ntZM,
                   
                   S_DD  => ntRef_ntS_DD,
                   S_D4  => ntRef_ntS_D4,
                   S_D3  => ntRef_ntS_D3,
                   S_D2  => ntRef_ntS_D2,
                   S_D1  => ntRef_ntS_D1,
                   S_D0  => ntRef_ntS_D0,
                   S_M3  => ntRef_ntS_M3,
                   S_CD  => ntRef_ntS_CD,
                   S_C4  => ntRef_ntS_C4,
                   S_C3  => ntRef_ntS_C3,
                   S_C2  => ntRef_ntS_C2,
                   S_C1  => ntRef_ntS_C1,
                   S_C0  => ntRef_ntS_C0,
                   S_M2  => ntRef_ntS_M2,
                   S_BD  => ntRef_ntS_BD,
                   S_B4  => ntRef_ntS_B4,
                   S_B3  => ntRef_ntS_B3,
                   S_B2  => ntRef_ntS_B2,
                   S_B1  => ntRef_ntS_B1,
                   S_B0  => ntRef_ntS_B0,
                   S_M1  => ntRef_ntS_M1,
                   S_AD  => ntRef_ntS_AD,
                   S_A4  => ntRef_ntS_A4,
                   S_A3  => ntRef_ntS_A3,
                   S_A2  => ntRef_ntS_A2,
                   S_A1  => ntRef_ntS_A1,
                   S_A0  => ntRef_ntS_A0,
                   S_M0  => ntRef_ntS_M0,
                   S_CE  => ntRef_ntS_CE,
                   S_RS  => ntRef_ntS_RS,
                   S_CLK => ntRef_ntS_CLK,

                   A_DD  => ntRef_ntA_DD,
                   A_D4  => ntRef_ntA_D4,
                   A_D3  => ntRef_ntA_D3,
                   A_D2  => ntRef_ntA_D2,
                   A_D1  => ntRef_ntA_D1,
                   A_D0  => ntRef_ntA_D0,
                   A_M3  => ntRef_ntA_M3,
                   A_CD  => ntRef_ntA_CD,
                   A_C4  => ntRef_ntA_C4,
                   A_C3  => ntRef_ntA_C3,
                   A_C2  => ntRef_ntA_C2,
                   A_C1  => ntRef_ntA_C1,
                   A_C0  => ntRef_ntA_C0,
                   A_M2  => ntRef_ntA_M2,
                   A_BD  => ntRef_ntA_BD,
                   A_B4  => ntRef_ntA_B4,
                   A_B3  => ntRef_ntA_B3,
                   A_B2  => ntRef_ntA_B2,
                   A_B1  => ntRef_ntA_B1,
                   A_B0  => ntRef_ntA_B0,
                   A_M1  => ntRef_ntA_M1,
                   A_AD  => ntRef_ntA_AD,
                   A_A4  => ntRef_ntA_A4,
                   A_A3  => ntRef_ntA_A3,
                   A_A2  => ntRef_ntA_A2,
                   A_A1  => ntRef_ntA_A1,
                   A_A0  => ntRef_ntA_A0,
                   A_M0  => ntRef_ntA_M0,
                   A_CE  => ntRef_ntA_CE,
                   A_RS  => ntRef_ntA_RS,
                   A_CLK => ntRef_ntA_CLK
                 )
        @([sx+2,sy]);

    //
    // Layout VCC and connect wires and tracks driven by it
    //
    sprintf(strVar, "VCC_%d_%d", sx, sy+1);
    device VCC *strVar
        port map (
                   VCCOUT   => ntRef_ntVCCOUT     // Output
                 )
    @([sx,sy+1]);
    
    //
    // Layout GND and connect wires and tracks driven by it
    //
    sprintf(strVar, "GND_%d_%d", sx, sy);
    device GND *strVar
        port map (
                   GNDOUT   => ntRef_ntGNDOUT     // Output
                 )
    @([sx,sy]);
     
    //
    // Layout CIM and connect wires and tracks driven by it
    //
    sprintf(strVar, "CIM_%d_%d", sx+3, sy+2);
    device CIM *strVar
        port map (
                   S_DD   => ntRef_ntS_DD,    // Input from local SIB (I)
                   S_D4   => ntRef_ntS_D4,
                   S_D3   => ntRef_ntS_D3,
                   S_D2   => ntRef_ntS_D2,
                   S_D1   => ntRef_ntS_D1,
                   S_D0   => ntRef_ntS_D0,
                   S_M3   => ntRef_ntS_M3,
                   S_CD   => ntRef_ntS_CD,
                   S_C4   => ntRef_ntS_C4,
                   S_C3   => ntRef_ntS_C3,
                   S_C2   => ntRef_ntS_C2,
                   S_C1   => ntRef_ntS_C1,
                   S_C0   => ntRef_ntS_C0,
                   S_M2   => ntRef_ntS_M2,
                   S_BD   => ntRef_ntS_BD,
                   S_B4   => ntRef_ntS_B4,
                   S_B3   => ntRef_ntS_B3,
                   S_B2   => ntRef_ntS_B2,
                   S_B1   => ntRef_ntS_B1,
                   S_B0   => ntRef_ntS_B0,
                   S_M1   => ntRef_ntS_M1,
                   S_AD   => ntRef_ntS_AD,
                   S_A4   => ntRef_ntS_A4,
                   S_A3   => ntRef_ntS_A3,
                   S_A2   => ntRef_ntS_A2,
                   S_A1   => ntRef_ntS_A1,
                   S_A0   => ntRef_ntS_A0,
                   S_M0   => ntRef_ntS_M0,
                   S_CE   => ntRef_ntS_CE,
                   S_RS   => ntRef_ntS_RS,
                   S_CLK  => ntRef_ntS_CLK,

                   A_DD   => ntRef_ntA_DD,
                   A_D4   => ntRef_ntA_D4,
                   A_D3   => ntRef_ntA_D3,
                   A_D2   => ntRef_ntA_D2,
                   A_D1   => ntRef_ntA_D1,
                   A_D0   => ntRef_ntA_D0,
                   A_M3   => ntRef_ntA_M3,
                   A_CD   => ntRef_ntA_CD,
                   A_C4   => ntRef_ntA_C4,
                   A_C3   => ntRef_ntA_C3,
                   A_C2   => ntRef_ntA_C2,
                   A_C1   => ntRef_ntA_C1,
                   A_C0   => ntRef_ntA_C0,
                   A_M2   => ntRef_ntA_M2,
                   A_BD   => ntRef_ntA_BD,
                   A_B4   => ntRef_ntA_B4,
                   A_B3   => ntRef_ntA_B3,
                   A_B2   => ntRef_ntA_B2,
                   A_B1   => ntRef_ntA_B1,
                   A_B0   => ntRef_ntA_B0,
                   A_M1   => ntRef_ntA_M1,
                   A_AD   => ntRef_ntA_AD,
                   A_A4   => ntRef_ntA_A4,
                   A_A3   => ntRef_ntA_A3,
                   A_A2   => ntRef_ntA_A2,
                   A_A1   => ntRef_ntA_A1,
                   A_A0   => ntRef_ntA_A0,
                   A_M0   => ntRef_ntA_M0,
                   A_CE   => ntRef_ntA_CE,
                   A_RS   => ntRef_ntA_RS,
                   A_CLK  => ntRef_ntA_CLK,
                   
                   S_IDD  => ntRef_ntS_IDD,        //output
                   S_ID4  => ntRef_ntS_ID4,
                   S_ID3  => ntRef_ntS_ID3,
                   S_ID2  => ntRef_ntS_ID2,
                   S_ID1  => ntRef_ntS_ID1,
                   S_ID0  => ntRef_ntS_ID0,
                   S_IM3  => ntRef_ntS_IM3,
                   S_ICD  => ntRef_ntS_ICD,
                   S_IC4  => ntRef_ntS_IC4,
                   S_IC3  => ntRef_ntS_IC3,
                   S_IC2  => ntRef_ntS_IC2,
                   S_IC1  => ntRef_ntS_IC1,
                   S_IC0  => ntRef_ntS_IC0,
                   S_IM2  => ntRef_ntS_IM2,
                   S_IBD  => ntRef_ntS_IBD,
                   S_IB4  => ntRef_ntS_IB4,
                   S_IB3  => ntRef_ntS_IB3,
                   S_IB2  => ntRef_ntS_IB2,
                   S_IB1  => ntRef_ntS_IB1,
                   S_IB0  => ntRef_ntS_IB0,
                   S_IM1  => ntRef_ntS_IM1,
                   S_IAD  => ntRef_ntS_IAD,
                   S_IA4  => ntRef_ntS_IA4,
                   S_IA3  => ntRef_ntS_IA3,
                   S_IA2  => ntRef_ntS_IA2,
                   S_IA1  => ntRef_ntS_IA1,
                   S_IA0  => ntRef_ntS_IA0,
                   S_IM0  => ntRef_ntS_IM0,
                   S_ICE  => ntRef_ntS_ICE,
                   S_IRS  => ntRef_ntS_IRS,
                   S_ICLK => ntRef_ntS_ICLK,

                   A_IDD  => ntRef_ntA_IDD,
                   A_ID4  => ntRef_ntA_ID4,
                   A_ID3  => ntRef_ntA_ID3,
                   A_ID2  => ntRef_ntA_ID2,
                   A_ID1  => ntRef_ntA_ID1,
                   A_ID0  => ntRef_ntA_ID0,
                   A_IM3  => ntRef_ntA_IM3,
                   A_ICD  => ntRef_ntA_ICD,
                   A_IC4  => ntRef_ntA_IC4,
                   A_IC3  => ntRef_ntA_IC3,
                   A_IC2  => ntRef_ntA_IC2,
                   A_IC1  => ntRef_ntA_IC1,
                   A_IC0  => ntRef_ntA_IC0,
                   A_IM2  => ntRef_ntA_IM2,
                   A_IBD  => ntRef_ntA_IBD,
                   A_IB4  => ntRef_ntA_IB4,
                   A_IB3  => ntRef_ntA_IB3,
                   A_IB2  => ntRef_ntA_IB2,
                   A_IB1  => ntRef_ntA_IB1,
                   A_IB0  => ntRef_ntA_IB0,
                   A_IM1  => ntRef_ntA_IM1,
                   A_IAD  => ntRef_ntA_IAD,
                   A_IA4  => ntRef_ntA_IA4,
                   A_IA3  => ntRef_ntA_IA3,
                   A_IA2  => ntRef_ntA_IA2,
                   A_IA1  => ntRef_ntA_IA1,
                   A_IA0  => ntRef_ntA_IA0,
                   A_IM0  => ntRef_ntA_IM0,
                   A_ICE  => ntRef_ntA_ICE,
                   A_IRS  => ntRef_ntA_IRS,
                   A_ICLK => ntRef_ntA_ICLK,
                   
                   S_Y0   => ntRef_ntS_Y0,    //output to SRB
                   S_Y1   => ntRef_ntS_Y1,
                   S_Y2   => ntRef_ntS_Y2,
                   S_Y3   => ntRef_ntS_Y3,
                   S_Q0   => ntRef_ntS_Q0,
                   S_Q1   => ntRef_ntS_Q1,
                   S_Q2   => ntRef_ntS_Q2,
                   S_Q3   => ntRef_ntS_Q3,
                   S_Y6AB => ntRef_ntS_Y6AB,
                   S_Y6CD => ntRef_ntS_Y6CD,
                   
                   A_Y0   => ntRef_ntA_Y0,
                   A_Y1   => ntRef_ntA_Y1,
                   A_Y2   => ntRef_ntA_Y2,
                   A_Y3   => ntRef_ntA_Y3,
                   A_Q0   => ntRef_ntA_Q0,
                   A_Q1   => ntRef_ntA_Q1,
                   A_Q2   => ntRef_ntA_Q2,
                   A_Q3   => ntRef_ntA_Q3,
                   A_Y6AB => ntRef_ntA_Y6AB,
                   A_Y6CD => ntRef_ntA_Y6CD
                 )
        @([sx+3,sy+2]);
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within APM block tiles. Each APM block takes
             the size of 4 logic tiles. 


              ---------|---------|---------|---------
              
                            
                          R[1,0]   I[2,0]                TILE 3
              ---------|---------|---------|---------
              
                            
                          R[1,0]   I[2,0]                TILE 2
              ---------|---------|---------|---------
              
                            
                          R[1,0]   I[2,0]                TILE 1
              ---------|---------|---------|---------
              
                                   A[2,1]
                          R[1,0]   I[2,0]                TILE 0
              ---------|---------|---------|---------
            ]

  Revision History:

*****************************************************************************************/
function place_apm_tile ( unsigned int tx, ty )
{
    string strVar;

    // Layout devices in 4 tiles. 
    place_base_tile (tx, ty);
    place_base_tile (tx, ty+1);
    place_base_tile (tx, ty+2);
    place_base_tile (tx, ty+3);
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;

    //
    // Layout APM in the tile #0
    //
    // Allocate the wires driven by APM
    //
    sprintf(strVar, "ntDPO_%d_%d", sx+2, sy+1);
    &wire ntRef_ntDPO[73:0] = wire *strVar[73:0]  /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ; 

    sprintf(strVar, "ntCPO_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCPO[64:0] = wire *strVar[64:0]  /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ; 
    
    sprintf(strVar, "ntCPO_SIGNED_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCPO_SIGNED = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ; 
    
    sprintf(strVar, "ntCZO_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCZO[26:0] = wire *strVar[26:0]  /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntCZO_SIGNED_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCZO_SIGNED = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ; 
    
    sprintf(strVar, "ntCYO_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCYO[26:0] = wire *strVar[26:0]  /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
    
    sprintf(strVar, "ntCYO_SIGNED_%d_%d", sx+2, sy+1);
    &wire ntRef_ntCYO_SIGNED = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ; 
    
    // The wires are spread out in 4 tiles. Pre-calculate the lower-left corner of all 4 tiles
    unsigned int tile_0_sy =  ty      * TILE_NUM_SITE_Y;
    unsigned int tile_1_sy = (ty + 1) * TILE_NUM_SITE_Y;
    unsigned int tile_2_sy = (ty + 2) * TILE_NUM_SITE_Y;
    unsigned int tile_3_sy = (ty + 3) * TILE_NUM_SITE_Y;
    
    //
    // Instantiate the APM @[2,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "APM_%d_%d", sx+2, sy+1);
    device APM *strVar
        port map (
                   DPO        => ntRef_ntDPO        ,                           // output
                   CPO        => ntRef_ntCPO        ,
                   CPO_SIGNED => ntRef_ntCPO_SIGNED ,
                   CZO        => ntRef_ntCZO        ,
                   CZO_SIGNED => ntRef_ntCZO_SIGNED ,
                   CYO        => ntRef_ntCYO        ,
                   CYO_SIGNED => ntRef_ntCYO_SIGNED ,
                   
                   //
                   // DXIA
                   //
                   DXIA[0] => <wire A_IA0  of <device CIM @[sx+3,tile_0_sy+2]>>,      //A
                   DXIA[1] => <wire A_IA1  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DXIA[2] => <wire A_IA2  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DXIA[3] => <wire A_IA3  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DXIA[4] => <wire A_IA4  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   
                   DXIA[5] => <wire S_IA4  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DXIA[6] => <wire S_IA3  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DXIA[7] => <wire S_IA2  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DXIA[8] => <wire S_IA1  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DXIA[9] => <wire S_IA0  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   
                   DXIA[10] => <wire A_IB0  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DXIA[11] => <wire A_IB1  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DXIA[12] => <wire A_IB2  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DXIA[13] => <wire A_IB3  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DXIA[14] => <wire A_IB4  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   
                   DXIA[15] => <wire S_IB4  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DXIA[16] => <wire S_IB3  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DXIA[17] => <wire S_IB2  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   
                   DXIA_SIGNED => <wire S_IB1  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   
                   CLK[0]   => <wire S_ICLK of <device CIM @[sx+3,tile_0_sy+2]>>,       //S
                   RST[0]   => <wire S_IRS  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   CE[0]    => <wire S_ICE  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   
                   //
                   // DXIB
                   //
                   DXIB[0] => <wire A_IA0  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DXIB[1] => <wire A_IA1  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DXIB[2] => <wire A_IA2  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DXIB[3] => <wire A_IA3  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DXIB[4] => <wire A_IA4  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   
                   DXIB[5] => <wire S_IA4  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DXIB[6] => <wire S_IA3  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DXIB[7] => <wire S_IA2  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DXIB[8] => <wire S_IA0  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DXIB[9] => <wire S_IA1  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   
                   DXIB[10] => <wire A_IB0  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DXIB[11] => <wire A_IB1  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DXIB[12] => <wire A_IB2  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DXIB[13] => <wire A_IB3  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DXIB[14] => <wire A_IB4  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   
                   DXIB[15] => <wire S_IB4  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DXIB[16] => <wire S_IB3  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DXIB[17] => <wire S_IB2  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   
                   DXIB_SIGNED => <wire S_IB1  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   
                   //
                   // DYIA
                   //
                   DYIA[0] => <wire A_IC0  of <device CIM @[sx+3,tile_0_sy+2]>>,      //A
                   DYIA[1] => <wire A_IC1  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DYIA[2] => <wire A_IC2  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DYIA[3] => <wire A_IC3  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DYIA[4] => <wire A_IC4  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   
                   DYIA[5] => <wire S_IC4  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DYIA[6] => <wire S_IC3  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DYIA[7] => <wire S_IC2  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DYIA[8] => <wire S_IC1  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DYIA[9] => <wire S_IC0  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   
                   DYIA[10] => <wire A_ID0  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DYIA[11] => <wire A_ID1  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DYIA[12] => <wire A_ID2  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DYIA[13] => <wire A_ID3  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DYIA[14] => <wire A_ID4  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   
                   DYIA[15] => <wire S_ID4  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DYIA[16] => <wire S_ID3  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   DYIA[17] => <wire S_ID2  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   
                   DYIA_SIGNED => <wire S_ID1  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   
                   CLK[1]   => <wire S_ICLK of <device CIM @[sx+3,tile_1_sy+2]>>,       //S
                   RST[1]   => <wire S_IRS  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   CE[1]    => <wire S_ICE  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   
                   //
                   // DYIB
                   //
                   DYIB[0] => <wire A_IC0  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DYIB[1] => <wire A_IC1  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DYIB[2] => <wire A_IC2  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DYIB[3] => <wire A_IC3  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DYIB[4] => <wire A_IC4  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   
                   DYIB[5] => <wire S_IC4  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DYIB[6] => <wire S_IC3  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DYIB[7] => <wire S_IC2  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DYIB[8] => <wire S_IC1  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DYIB[9] => <wire S_IC0  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   
                   DYIB[10] => <wire A_ID0  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DYIB[11] => <wire A_ID1  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DYIB[12] => <wire A_ID2  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DYIB[13] => <wire A_ID3  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DYIB[14] => <wire A_ID4  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   
                   DYIB[15] => <wire S_ID4  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DYIB[16] => <wire S_ID3  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   DYIB[17] => <wire S_ID2  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   
                   DYIB_SIGNED => <wire S_ID1  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   
                   //
                   // DZIA
                   //
                   DZIA[0] => <wire A_IA0  of <device CIM @[sx+3,tile_1_sy+2]>>,      //A
                   DZIA[1] => <wire A_IA1  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[2] => <wire A_IA2  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[3] => <wire A_IA3  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[4] => <wire A_IA4  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   
                   DZIA[5] => <wire S_IA4  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[6] => <wire S_IA3  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[7] => <wire S_IA2  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[8] => <wire S_IA1  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[9] => <wire S_IA0  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   
                   DZIA[10] => <wire A_IB0  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[11] => <wire A_IB1  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[12] => <wire A_IB2  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[13] => <wire A_IB3  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[14] => <wire A_IB4  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   
                   DZIA[15] => <wire S_IB4  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[16] => <wire S_IB3  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[17] => <wire S_IB2  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   
                   DZIA[18] => <wire S_IB1  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[19] => <wire S_IB0  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[20] => <wire A_IC0  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[21] => <wire A_IC1  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[22] => <wire A_IC2  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   
                   DZIA[23] => <wire A_IC3  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[24] => <wire A_IC4  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[25] => <wire S_IC4  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   
                   DZIA[26] => <wire S_IC3  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[27] => <wire S_IC2  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[28] => <wire S_IC1  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   
                   DZIA[29] => <wire S_IC0  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[30] => <wire A_ID0  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   DZIA[31] => <wire A_ID1  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   
                   DZIA_SIGNED => <wire A_ID4  of <device CIM @[sx+3,tile_1_sy+2]>>,                
                   
                   CLK[2]   => <wire S_ICLK of <device CIM @[sx+3,tile_2_sy+2]>>,       //S
                   RST[2]   => <wire S_IRS  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   CE[2]    => <wire S_ICE  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   
                   //
                   // DZIB
                   //
                   DZIB[0] => <wire A_IA0  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[1] => <wire A_IA1  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[2] => <wire A_IA2  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[3] => <wire A_IA3  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[4] => <wire A_IA4  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   
                   DZIB[5] => <wire S_IA4  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[6] => <wire S_IA3  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[7] => <wire S_IA2  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[8] => <wire S_IA1  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[9] => <wire S_IA0  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   
                   DZIB[10] => <wire A_IB0  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[11] => <wire A_IB1  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[12] => <wire A_IB2  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[13] => <wire A_IB3  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[14] => <wire A_IB4  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   
                   DZIB[15] => <wire S_IB4  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[16] => <wire S_IB3  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[17] => <wire S_IB2  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   
                   DZIB[18] => <wire S_IB1  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[19] => <wire S_IB0  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[20] => <wire A_IC0  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[21] => <wire A_IC1  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[22] => <wire A_IC2  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   
                   DZIB[23] => <wire A_IC3  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[24] => <wire A_IC4  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[25] => <wire S_IC4  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[26] => <wire S_IC3  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[27] => <wire S_IC2  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   
                   DZIB[28] => <wire S_IC1  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[29] => <wire S_IC0  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[30] => <wire A_ID0  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   DZIB[31] => <wire A_ID1  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   
                   DZIB_SIGNED => <wire A_ID4  of <device CIM @[sx+3,tile_3_sy+2]>>,
                  
                   CLK[3]   => <wire S_ICLK of <device CIM @[sx+3,tile_3_sy+2]>>,       //S
                   RST[3]   => <wire S_IRS  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   CE[3]    => <wire S_ICE  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   
                   
                   //APM_OP_POST
                   APM_OP_POST[0] => <wire A_IM1  of <device CIM @[sx+3,tile_0_sy+2]>>,      
                   APM_OP_POST[1] => <wire A_IM2  of <device CIM @[sx+3,tile_0_sy+2]>>,
                   APM_OP_POST[2] => <wire A_IM2  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   APM_OP_POST[3] => <wire A_IM3  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   APM_OP_POST[4] => <wire S_IM0  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   
                   APM_OP_POST[5] => <wire S_IM1  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   APM_OP_POST[6] => <wire S_IM2  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   APM_OP_POST[7] => <wire S_IM3  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   APM_OP_POST[8] => <wire A_IM0  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   APM_OP_POST[9] => <wire A_IM1  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   APM_OP_POST[10]=> <wire A_IM2  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   
                   //APM_OP_IR
                   APM_OP_IR[0] => <wire A_IM3  of <device CIM @[sx+3,tile_0_sy+2]>>,   
                   APM_OP_IR[1] => <wire S_IM0  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   APM_OP_IR[2] => <wire S_IM1  of <device CIM @[sx+3,tile_1_sy+2]>>,
                   APM_OP_IR[3] => <wire A_IM3  of <device CIM @[sx+3,tile_2_sy+2]>>,
                   APM_OP_IR[4] => <wire S_IM3  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   
                   APM_OP_IR[5] => <wire A_IM0  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   APM_OP_IR[6] => <wire A_IM2  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   APM_OP_IR[7] => <wire A_IM1  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   APM_OP_IR[8] => <wire A_IM3  of <device CIM @[sx+3,tile_3_sy+2]>>,
                   
                   //APM_OP_PRAD
                   APM_OP_PRAD[0] => <wire S_IM3  of <device CIM @[sx+3,tile_0_sy+2]>>,   
                   APM_OP_PRAD[1] => <wire S_IM0  of <device CIM @[sx+3,tile_2_sy+2]>>
                   
                 )
        @[sx+2,sy+1];
        
    // Hook up the outputs of APM -> SRB  (A -> R)
    connect
        (
          <pin A_IY0   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntDPO[0],
          <pin A_IQ0   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntDPO[1],
          <pin A_IY6AB of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntDPO[2],
          <pin S_IQ0   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntDPO[3],
          <pin S_IY0   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntDPO[4],
          <pin A_IY1   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntDPO[5],
          <pin A_IQ1   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntDPO[6],
          <pin S_IQ1   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntDPO[7],
          
          <pin S_IY1 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntDPO[8] ,
          <pin A_IY2 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntDPO[9] ,
          <pin A_IQ2 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntDPO[10],
          <pin S_IQ2 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntDPO[11],
          <pin S_IY2 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntDPO[12],
          <pin A_IY3 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntDPO[13],
          <pin A_IQ3 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntDPO[14],
          <pin S_IQ3 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntDPO[15],
          
          <pin S_IY3   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntDPO[16],
          <pin S_IY6CD of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntDPO[17],
          <pin A_IY0   of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDPO[18],
          <pin A_IQ0   of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDPO[19],
          <pin A_IY6AB of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDPO[20],
          <pin S_IQ0   of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDPO[21],
          <pin S_IY0   of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDPO[22],
          <pin A_IY1   of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDPO[23],
          
          <pin S_IY1 of <device CIM @[sx+3,tile_3_sy+2]>> => ntRef_ntDPO[64],
          <pin A_IY2 of <device CIM @[sx+3,tile_3_sy+2]>> => ntRef_ntDPO[65],
          
          <pin A_IQ1   of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDPO[24],
          <pin S_IY6AB of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDPO[25],
          <pin S_IQ1   of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDPO[26],
          <pin S_IY1   of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDPO[27],
          <pin A_IY2   of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDPO[28],
          <pin A_IQ2   of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDPO[29],
          <pin A_IY6CD of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDPO[30],
          <pin S_IQ2   of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDPO[31],
          
          <pin A_IQ2   of <device CIM @[sx+3,tile_3_sy+2]>> => ntRef_ntDPO[66],
          <pin A_IY6CD of <device CIM @[sx+3,tile_3_sy+2]>> => ntRef_ntDPO[67],
          
          <pin S_IY2   of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDPO[32],
          <pin A_IY3   of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDPO[33],
          <pin A_IQ3   of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDPO[34],
          <pin S_IQ3   of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDPO[35],
          <pin S_IY3   of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDPO[36],
          <pin A_IY0   of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDPO[37],
          <pin A_IQ0   of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDPO[38],
          <pin A_IY6AB of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDPO[39],
          
          <pin S_IQ2 of <device CIM @[sx+3,tile_3_sy+2]>> => ntRef_ntDPO[68],
          <pin S_IY2 of <device CIM @[sx+3,tile_3_sy+2]>> => ntRef_ntDPO[69],
          
          <pin S_IQ0 of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDPO[40],
          <pin S_IY0 of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDPO[41],
          <pin A_IY1 of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDPO[42],
          <pin A_IQ1 of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDPO[43],
          <pin S_IQ1 of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDPO[44],
          <pin S_IY1 of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDPO[45],
          <pin A_IY2 of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDPO[46],
          <pin A_IQ2 of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDPO[47],
          
          <pin A_IY3 of <device CIM @[sx+3,tile_3_sy+2]>> => ntRef_ntDPO[70],
          <pin A_IQ3 of <device CIM @[sx+3,tile_3_sy+2]>> => ntRef_ntDPO[71],
          
          <pin S_IQ2   of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDPO[48],
          <pin S_IY2   of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDPO[49],
          <pin A_IY3   of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDPO[50],
          <pin A_IQ3   of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDPO[51],
          <pin S_IQ3   of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDPO[52],
          <pin S_IY3   of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDPO[53],
          <pin S_IY6CD of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDPO[54],
          <pin A_IY0   of <device CIM @[sx+3,tile_3_sy+2]>> => ntRef_ntDPO[55],
          
          <pin S_IQ3 of <device CIM @[sx+3,tile_3_sy+2]>> => ntRef_ntDPO[72],
          <pin S_IY3 of <device CIM @[sx+3,tile_3_sy+2]>> => ntRef_ntDPO[73],
          
          <pin A_IQ0   of <device CIM @[sx+3,tile_3_sy+2]>> => ntRef_ntDPO[56],
          <pin A_IY6AB of <device CIM @[sx+3,tile_3_sy+2]>> => ntRef_ntDPO[57],
          <pin S_IQ0   of <device CIM @[sx+3,tile_3_sy+2]>> => ntRef_ntDPO[58],
          <pin S_IY0   of <device CIM @[sx+3,tile_3_sy+2]>> => ntRef_ntDPO[59],
          <pin A_IY1   of <device CIM @[sx+3,tile_3_sy+2]>> => ntRef_ntDPO[60],
          <pin A_IQ1   of <device CIM @[sx+3,tile_3_sy+2]>> => ntRef_ntDPO[61],
          <pin S_IY6AB of <device CIM @[sx+3,tile_3_sy+2]>> => ntRef_ntDPO[62],
          <pin S_IQ1   of <device CIM @[sx+3,tile_3_sy+2]>> => ntRef_ntDPO[63]
        );
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within DRM block tiles. Each DRM block takes
             the size of 5 logic tiles. 


              ---------|---------|---------|---------
                                             C[3,2]

                          R[1,0]   I[2,0]                 TILE 2
              ---------|---------|---------|---------
                                             C[3,2]
                                   D[2,1]
                          R[1,0]   I[2,0]                 TILE 1
              ---------|---------|---------|---------
                                             C[3,2]
                                             
                          R[1,0]   I[2,0]                 TILE 0
              ---------|---------|---------|---------
            ]

  Revision History:

*****************************************************************************************/
function place_drm0_tile ( unsigned int tx, ty )
{
    string strVar;
   
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // The wires are spread out in 5 tiles. Pre-calculate the lower-left corner of all 5 tiles
    unsigned int tile_0_sy =  ty      * TILE_NUM_SITE_Y;
    unsigned int tile_1_sy = (ty + 1) * TILE_NUM_SITE_Y;
    unsigned int tile_2_sy = (ty + 2) * TILE_NUM_SITE_Y;
    unsigned int tile_3_sy = (ty + 3) * TILE_NUM_SITE_Y;
    unsigned int tile_4_sy = (ty + 4) * TILE_NUM_SITE_Y;
    
    //
    // Allocate wires for logic connection inside of a DRM block tile
    //
    
    //
    // Wires driven by DRM0
    //
    
    // TO SIB
    sprintf(strVar, "ntDRM0_QA_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntDRM0_QA[17:0] = wire *strVar[17:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
   
    sprintf(strVar, "ntDRM0_QB_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntDRM0_QB[17:0] = wire *strVar[17:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ; 
    
    sprintf(strVar, "ntDRM0_WWCONF_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntDRM0_WWCONF = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ; 
    
    sprintf(strVar, "ntDRM0_AE_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntDRM0_AE = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ; 
    
    sprintf(strVar, "ntDRM0_AF_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntDRM0_AF = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ; 
    
    sprintf(strVar, "ntDRM0_FULL_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntDRM0_FULL = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ; 
    
    sprintf(strVar, "ntDRM0_EMPTY_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntDRM0_EMPTY = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ; 
    
    //
    // Layout DRM0 and connect wires and tracks driven by it
    //
    sprintf(strVar, "DRM_%d_%d", sx+2, tile_1_sy+1);
    device DRM *strVar
        port map (
                   QA     => ntRef_ntDRM0_QA,     // Output to CIM
                   QB     => ntRef_ntDRM0_QB,     
                   WWCONF => ntRef_ntDRM0_WWCONF,                   
                    AE     => ntRef_ntDRM0_AE,     
                    AF => ntRef_ntDRM0_AF,
                    EMPTY     => ntRef_ntDRM0_EMPTY,     
                    FULL => ntRef_ntDRM0_FULL,
    
                   RD_NAK    => <wire A_IC2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   WR_ERR    => <wire A_IC3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   WR_EOP    => <wire A_IC4 of <device CIM @[sx+3, tile_0_sy+2]>>  ,
                   ADA[4]    => <wire A_IA0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   ADA[5]    => <wire A_IA1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   ADA[6]    => <wire A_IA2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   ADA[7]    => <wire A_IA3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   ADA[8]    => <wire A_IA4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   ADA[9]    => <wire A_IB0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   ADA[10]   => <wire A_IB1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   ADA[11]   => <wire A_IB2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   ADA[12]   => <wire A_IB3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   ADA[13]   => <wire A_IB4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DA[0]     => <wire A_ID0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DA[1]     => <wire A_ID1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DA[2]     => <wire A_ID2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DA[3]     => <wire A_ID3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DA[4]     => <wire A_ID4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   CSA[0]    => <wire A_IAD of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   CLKA      => <wire A_ICLK of <device CIM @[sx+3, tile_0_sy+2]>>   ,
                   CEA       => <wire A_ICE of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   RSTA      => <wire A_IRS of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   ADB[4]    => <wire S_IA0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   ADB[5]    => <wire S_IA1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   ADB[6]    => <wire S_IA2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   ADB[7]    => <wire S_IA3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   ADB[8]    => <wire S_IA4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   ADB[9]    => <wire S_IB0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   ADB[10]   => <wire S_IB1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   ADB[11]   => <wire S_IB2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   ADB[12]   => <wire S_IB3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   ADB[13]   => <wire S_IB4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DA[5]     => <wire S_ID0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DA[6]     => <wire S_ID1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DA[7]     => <wire S_ID2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DA[8]     => <wire S_ID3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DA[9]     => <wire S_ID4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   CSA[1]    => <wire S_IAD of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   WEA       => <wire S_ICLK of <device CIM @[sx+3, tile_0_sy+2]>>   ,
                   OCEA      => <wire S_ICE of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DA[10]    => <wire A_IA0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DA[11]    => <wire A_IA1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DA[12]    => <wire A_IA2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DA[13]    => <wire A_IA3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DA[14]    => <wire A_IA4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DA[15]    => <wire A_IB0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DA[16]    => <wire A_IB1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DA[17]    => <wire A_IB2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   ADA[0]    => <wire A_IB3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   ADA[1]    => <wire A_IB4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   ADSA      => <wire A_ID0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   ADB[0]    => <wire A_ID3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   ADB[1]    => <wire A_ID4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   CSA[2]    => <wire A_IM0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   CSB[0]    => <wire A_ICD of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   CLKB      => <wire A_ICLK of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                   CEB       => <wire A_ICE of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   RSTB      => <wire A_IRS of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DB[0]     => <wire S_IA0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DB[1]     => <wire S_IA1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DB[2]     => <wire S_IA2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DB[3]     => <wire S_IA3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DB[4]     => <wire S_IA4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DB[5]     => <wire S_IB0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DB[6]     => <wire S_IB1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DB[7]     => <wire S_IB2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   ADA[2]    => <wire S_IB3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   ADA[3]    => <wire S_IB4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   ADSB      => <wire S_ID0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   ADB[2]    => <wire S_ID3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   ADB[3]    => <wire S_ID4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   CSB[2]    => <wire S_IM0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   CSB[1]    => <wire S_ICD of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   WEB       => <wire S_ICLK of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                   OCEB      => <wire S_ICE of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DB[8]     => <wire A_IA0 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   DB[9]     => <wire A_IA1 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   DB[10]    => <wire A_IA2 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   DB[11]    => <wire A_IA3 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   DB[12]    => <wire A_IA4 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   DB[13]    => <wire A_IB0 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   DB[14]    => <wire A_IB1 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   DB[15]    => <wire A_IB2 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   DB[16]    => <wire A_IB3 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   DB[17]    => <wire A_IB4 of <device CIM @[sx+3, tile_2_sy+2]>> 
                 )
        @([sx+2, tile_1_sy+1]);
        
        
    // Hook up the outputs of DRM0 -> CIM  (D -> C)
    connect
        (
            <pin A_IY0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntDRM0_QA[0]   ,
            <pin A_IY1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntDRM0_QA[1]   ,
            <pin A_IY2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntDRM0_QA[2]   ,
            <pin A_IY3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntDRM0_AE   ,
            <pin A_IQ0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntDRM0_QA[3]   ,
            <pin A_IQ1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntDRM0_QA[4]   ,
            <pin A_IQ2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntDRM0_QA[5]   ,
            <pin A_IQ3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntDRM0_EMPTY   ,
            <pin S_IY0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntDRM0_QB[0]   ,
            <pin S_IY1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntDRM0_QB[1]   ,
            <pin S_IY2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntDRM0_QB[2]   ,
            <pin S_IY3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntDRM0_AF   ,
            <pin S_IQ0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntDRM0_QB[3]   ,
            <pin S_IQ1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntDRM0_QB[4]   ,
            <pin S_IQ2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntDRM0_QB[5]   ,
            <pin S_IQ3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntDRM0_FULL   ,
            <pin A_IY0 of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntDRM0_QA[6]   ,
            <pin A_IY1 of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntDRM0_QA[7]   ,
            <pin A_IY2 of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntDRM0_QA[9]   ,
            <pin A_IY3 of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntDRM0_QA[10]  ,
            <pin A_IQ0 of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntDRM0_QA[11]  ,
            <pin A_IQ1 of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntDRM0_QA[12]  ,
            <pin A_IQ2 of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntDRM0_QA[13]  ,
            <pin A_IQ3 of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntDRM0_QA[14]  ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDRM0_QA[8]   ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDRM0_WWCONF  ,
            <pin S_IY0 of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntDRM0_QB[6]   ,
            <pin S_IY1 of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntDRM0_QB[7]   ,
            <pin S_IY2 of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntDRM0_QB[9]   ,
            <pin S_IY3 of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntDRM0_QB[10]  ,
            <pin S_IQ0 of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntDRM0_QB[11]  ,
            <pin S_IQ1 of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntDRM0_QB[12]  ,
            <pin S_IQ2 of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntDRM0_QB[13]  ,
            <pin S_IQ3 of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntDRM0_QB[14]  ,
            <pin S_IY6AB of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDRM0_QB[8]   ,
            <pin A_IY0 of <device CIM @[sx+3,tile_2_sy+2]>>   => ntRef_ntDRM0_QA[15]  ,
            <pin A_IY1 of <device CIM @[sx+3,tile_2_sy+2]>>   => ntRef_ntDRM0_QA[16]  ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDRM0_QA[17]  ,
            <pin S_IY0 of <device CIM @[sx+3,tile_2_sy+2]>>   => ntRef_ntDRM0_QB[15]  ,
            <pin S_IY1 of <device CIM @[sx+3,tile_2_sy+2]>>   => ntRef_ntDRM0_QB[16]  ,
            <pin S_IY6AB of <device CIM @[sx+3,tile_2_sy+2]>> => ntRef_ntDRM0_QB[17]
        );

};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within DRM block tiles. Each DRM block takes
             the size of 5 logic tiles. 


              ---------|---------|---------|---------
                                             C[3,2]

                          R[1,0]   I[2,0]                 TILE 4
              ---------|---------|---------|---------
                                             C[3,2]
                                   D[2,1]
                          R[1,0]   I[2,0]                 TILE 3
              ---------|---------|---------|---------
                                             C[3,2]

                          R[1,0]   I[2,0]                 TILE 2
              ---------|---------|---------|---------
            ]

  Revision History:

*****************************************************************************************/
function place_drm1_tile ( unsigned int tx, ty )
{
    string strVar;
       
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // The wires are spread out in 5 tiles. Pre-calculate the lower-left corner of all 5 tiles
    unsigned int tile_0_sy =  ty      * TILE_NUM_SITE_Y;
    unsigned int tile_1_sy = (ty + 1) * TILE_NUM_SITE_Y;
    unsigned int tile_2_sy = (ty + 2) * TILE_NUM_SITE_Y;
    unsigned int tile_3_sy = (ty + 3) * TILE_NUM_SITE_Y;
    unsigned int tile_4_sy = (ty + 4) * TILE_NUM_SITE_Y;
    
    //
    // Allocate wires for logic connection inside of a DRM block tile
    //
    
    //
    // Wires driven by DRM1
    //
    
    // TO SIB
    sprintf(strVar, "ntDRM1_QA_%d_%d", sx+2, tile_3_sy+1);
    &wire ntRef_ntDRM1_QA[17:0] = wire *strVar[17:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ;
   
    sprintf(strVar, "ntDRM1_QB_%d_%d", sx+2, tile_3_sy+1);
    &wire ntRef_ntDRM1_QB[17:0] = wire *strVar[17:0]   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ; 
    
    sprintf(strVar, "ntDRM1_WWCONF_%d_%d", sx+2, tile_3_sy+1);
    &wire ntRef_ntDRM1_WWCONF = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ; 

    sprintf(strVar, "ntDRM1_AE_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntDRM1_AE = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ; 
    
    sprintf(strVar, "ntDRM1_AF_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntDRM1_AF = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ; 
    
    sprintf(strVar, "ntDRM1_FULL_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntDRM1_FULL = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ; 
    
    sprintf(strVar, "ntDRM1_EMPTY_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntDRM1_EMPTY = wire *strVar   /*pragma PAP_ARC_ITC_TYPE="LOCAL" */ ; 

    //
    // Layout DRM1 and connect wires and tracks driven by it
    //
    sprintf(strVar, "DRM_%d_%d", sx+2, tile_3_sy+1);
    device DRM *strVar
        port map (
                   QA     => ntRef_ntDRM1_QA,     // Output to CIM
                   QB     => ntRef_ntDRM1_QB,     
                   WWCONF => ntRef_ntDRM1_WWCONF,                   
                    AE     => ntRef_ntDRM1_AE,     
                    AF => ntRef_ntDRM1_AF,
                    EMPTY     => ntRef_ntDRM1_EMPTY,     
                    FULL => ntRef_ntDRM1_FULL,
    
                   ADA[6]    => <wire A_IC0 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   ADA[7]    => <wire A_IC1 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   ADA[8]    => <wire A_IC2 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   ADA[9]    => <wire A_IC3 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   DA[0]     => <wire A_ID0 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   DA[1]     => <wire A_ID1 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   DA[2]     => <wire A_ID2 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   DA[3]     => <wire A_ID3 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   ADA[10]   => <wire A_ICD of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   ADA[11]   => <wire A_IDD of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   ADB[6]    => <wire S_IC0 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   ADB[7]    => <wire S_IC1 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   ADB[8]    => <wire S_IC2 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   ADB[9]    => <wire S_IC3 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   DA[4]     => <wire S_ID0 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   DA[5]     => <wire S_ID1 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   DA[6]     => <wire S_ID2 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   DA[7]     => <wire S_ID3 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   ADB[10]   => <wire S_ICD of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                   ADB[11]   => <wire S_IDD of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                    RD_NAK    => <wire S_IB0 of <device CIM @[sx+3, tile_2_sy+2]>>    ,
                    WR_ERR    => <wire A_IC4 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                    WR_EOP    => <wire A_IC3 of <device CIM @[sx+3, tile_3_sy+2]>>  ,
                   DA[8]     => <wire A_IA0 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   DA[9]     => <wire A_IA1 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   DA[10]    => <wire A_IA2 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   DA[11]    => <wire A_IA3 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   DA[12]    => <wire A_IA4 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   DA[13]    => <wire A_IB0 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   DA[14]    => <wire A_IB1 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   DA[15]    => <wire A_IB2 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   DA[16]    => <wire A_IB3 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   DA[17]    => <wire A_IB4 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   CSA[0]    => <wire A_IAD of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   CLKA      => <wire A_ICLK of <device CIM @[sx+3, tile_3_sy+2]>>   ,
                   CEA       => <wire A_ICE of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   RSTA      => <wire A_IRS of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   ADA[4]    => <wire S_IA0 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   ADA[5]    => <wire S_IA1 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   ADA[12]   => <wire S_IA2 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   ADA[13]   => <wire S_IA3 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   ADB[4]    => <wire S_IB0 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   ADB[5]    => <wire S_IB1 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   ADB[12]   => <wire S_IB2 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   ADB[13]   => <wire S_IB3 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   ADA[0]    => <wire S_IC0 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   ADA[1]    => <wire S_IC1 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   ADA[2]    => <wire S_IC2 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   ADA[3]    => <wire S_IC3 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   CSA[2]    => <wire S_IM0 of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   CSA[1]    => <wire S_IAD of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   WEA       => <wire S_ICLK of <device CIM @[sx+3, tile_3_sy+2]>>   ,
                   OCEA      => <wire S_ICE of <device CIM @[sx+3, tile_3_sy+2]>>    ,
                   DB[0]     => <wire A_IA0 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   DB[1]     => <wire A_IA1 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   DB[2]     => <wire A_IA2 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   DB[3]     => <wire A_IA3 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   DB[4]     => <wire A_IB0 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   DB[5]     => <wire A_IB1 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   DB[6]     => <wire A_IB2 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   DB[7]     => <wire A_IB3 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   DB[8]     => <wire A_IC0 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   DB[9]     => <wire A_IC1 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   ADSB      => <wire A_ID0 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   CSB[2]    => <wire A_IM0 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   CSB[0]    => <wire A_IAD of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   CLKB      => <wire A_ICLK of <device CIM @[sx+3, tile_4_sy+2]>>   ,
                   CEB       => <wire A_ICE of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   RSTB      => <wire A_IRS of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   ADB[0]    => <wire S_IA0 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   ADB[1]    => <wire S_IA1 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   ADB[2]    => <wire S_IA2 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   ADB[3]    => <wire S_IA3 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   ADSA      => <wire S_IB0 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   DB[10]    => <wire S_IC0 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   DB[11]    => <wire S_IC1 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   DB[12]    => <wire S_IC2 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   DB[13]    => <wire S_IC3 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   DB[14]    => <wire S_ID0 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   DB[15]    => <wire S_ID1 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   DB[16]    => <wire S_ID2 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   DB[17]    => <wire S_ID3 of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   CSB[1]    => <wire S_IAD of <device CIM @[sx+3, tile_4_sy+2]>>    ,
                   WEB       => <wire S_ICLK of <device CIM @[sx+3, tile_4_sy+2]>>   ,
                   OCEB      => <wire S_ICE of <device CIM @[sx+3, tile_4_sy+2]>>
                 )
        @([sx+2, tile_3_sy+1]);
        
    // Hook up the outputs of DRM1 -> CIM  (D -> C)
    connect
        (
            <pin A_IY2 of <device CIM @[sx+3,tile_2_sy+2]>>    => ntRef_ntDRM1_QA[0]   ,
            <pin A_IY3 of <device CIM @[sx+3,tile_2_sy+2]>>    => ntRef_ntDRM1_QA[1]   ,
            <pin A_IQ0 of <device CIM @[sx+3,tile_2_sy+2]>>    => ntRef_ntDRM1_QA[2]   ,
            <pin A_IQ1 of <device CIM @[sx+3,tile_2_sy+2]>>    => ntRef_ntDRM1_QA[3]   ,
            <pin A_IQ2 of <device CIM @[sx+3,tile_2_sy+2]>>    => ntRef_ntDRM1_QA[4]   ,
            <pin A_IQ3 of <device CIM @[sx+3,tile_2_sy+2]>>    => ntRef_ntDRM1_QA[5]   ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_2_sy+2]>>   => ntRef_ntDRM1_AE   ,
            <pin S_IY2 of <device CIM @[sx+3,tile_2_sy+2]>>    => ntRef_ntDRM1_QB[0]   ,
            <pin S_IY3 of <device CIM @[sx+3,tile_2_sy+2]>>    => ntRef_ntDRM1_QB[1]   ,
            <pin S_IQ0 of <device CIM @[sx+3,tile_2_sy+2]>>    => ntRef_ntDRM1_QB[2]   ,
            <pin S_IQ1 of <device CIM @[sx+3,tile_2_sy+2]>>    => ntRef_ntDRM1_QB[3]   ,
            <pin S_IQ2 of <device CIM @[sx+3,tile_2_sy+2]>>    => ntRef_ntDRM1_QB[4]   ,
            <pin S_IQ3 of <device CIM @[sx+3,tile_2_sy+2]>>    => ntRef_ntDRM1_QB[5]   ,
            <pin S_IY6CD of <device CIM @[sx+3,tile_2_sy+2]>>   => ntRef_ntDRM1_EMPTY   ,
            <pin A_IY0 of <device CIM @[sx+3,tile_3_sy+2]>>    => ntRef_ntDRM1_QA[6]   ,
            <pin A_IY1 of <device CIM @[sx+3,tile_3_sy+2]>>    => ntRef_ntDRM1_QA[7]   ,
            <pin A_IQ0 of <device CIM @[sx+3,tile_3_sy+2]>>    => ntRef_ntDRM1_QA[9]   ,
            <pin A_IQ1 of <device CIM @[sx+3,tile_3_sy+2]>>    => ntRef_ntDRM1_QA[10]  ,
            <pin A_IQ2 of <device CIM @[sx+3,tile_3_sy+2]>>    => ntRef_ntDRM1_QA[11]  ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_3_sy+2]>>  => ntRef_ntDRM1_QA[8]   ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_3_sy+2]>>  => ntRef_ntDRM1_WWCONF  ,
            <pin S_IY0 of <device CIM @[sx+3,tile_3_sy+2]>>    => ntRef_ntDRM1_QB[6]   ,
            <pin S_IY1 of <device CIM @[sx+3,tile_3_sy+2]>>    => ntRef_ntDRM1_QB[7]   ,
            <pin S_IQ0 of <device CIM @[sx+3,tile_3_sy+2]>>    => ntRef_ntDRM1_QB[9]   ,
            <pin S_IQ1 of <device CIM @[sx+3,tile_3_sy+2]>>    => ntRef_ntDRM1_QB[10]  ,
            <pin S_IQ2 of <device CIM @[sx+3,tile_3_sy+2]>>    => ntRef_ntDRM1_QB[11]  ,
            <pin S_IY6AB of <device CIM @[sx+3,tile_3_sy+2]>>  => ntRef_ntDRM1_QB[8]   ,
            <pin A_IY0 of <device CIM @[sx+3,tile_4_sy+2]>>    => ntRef_ntDRM1_QA[12]  ,
            <pin A_IY1 of <device CIM @[sx+3,tile_4_sy+2]>>    => ntRef_ntDRM1_QA[13]  ,
            <pin A_IY2 of <device CIM @[sx+3,tile_4_sy+2]>>    => ntRef_ntDRM1_QA[14]  ,
            <pin A_IQ0 of <device CIM @[sx+3,tile_4_sy+2]>>    => ntRef_ntDRM1_QA[15]  ,
            <pin A_IQ1 of <device CIM @[sx+3,tile_4_sy+2]>>    => ntRef_ntDRM1_QA[16]  ,
            <pin A_IQ2 of <device CIM @[sx+3,tile_4_sy+2]>>    => ntRef_ntDRM1_QA[17]  ,
            <pin A_IQ3 of <device CIM @[sx+3,tile_4_sy+2]>>   => ntRef_ntDRM1_AF   ,
            <pin S_IY0 of <device CIM @[sx+3,tile_4_sy+2]>>    => ntRef_ntDRM1_QB[12]  ,
            <pin S_IY1 of <device CIM @[sx+3,tile_4_sy+2]>>    => ntRef_ntDRM1_QB[13]  ,
            <pin S_IY2 of <device CIM @[sx+3,tile_4_sy+2]>>    => ntRef_ntDRM1_QB[14]  ,
            <pin S_IQ0 of <device CIM @[sx+3,tile_4_sy+2]>>    => ntRef_ntDRM1_QB[15]  ,
            <pin S_IQ1 of <device CIM @[sx+3,tile_4_sy+2]>>    => ntRef_ntDRM1_QB[16]  ,
            <pin S_IQ2 of <device CIM @[sx+3,tile_4_sy+2]>>    => ntRef_ntDRM1_QB[17]  ,
            <pin S_IQ3 of <device CIM @[sx+3,tile_4_sy+2]>>   => ntRef_ntDRM1_FULL
        );
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within DRM block tiles. Each DRM block takes
             the size of 5 logic tiles. 


              ---------|---------|---------|---------
                                             C[3,2]

                          R[1,0]   I[2,0]                 TILE 4
              ---------|---------|---------|---------
                                             C[3,2]
                                   D[2,1]
                          R[1,0]   I[2,0]                 TILE 3
              ---------|---------|---------|---------
                                             C[3,2]

                          R[1,0]   I[2,0]                 TILE 2
              ---------|---------|---------|---------
                                             C[3,2]
                                   D[2,1]
                          R[1,0]   I[2,0]                 TILE 1
              ---------|---------|---------|---------
                                             C[3,2]
                                             
                          R[1,0]   I[2,0]                 TILE 0
              ---------|---------|---------|---------
            ]

  Revision History:

*****************************************************************************************/
function place_drm_tile ( unsigned int tx, ty )
{
    string strVar;
    
    // Layout devices in 5 tiles. 
    place_base_tile (tx, ty);
    place_base_tile (tx, ty+1);
    place_base_tile (tx, ty+2);
    place_base_tile (tx, ty+3);
    place_base_tile (tx, ty+4);

    place_drm0_tile(tx, ty);
    place_drm1_tile(tx, ty);

};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-2CIM block tiles in horizontal direction. 
             Each IO block takes the size of 2 tiles. 
             
             ---------|---------|---------|---------   ---------|---------|---------|---------  
                       IOL2[1,2] IOB2[2,2]  C[3,2]                                    C[3,2]
               V[0,1]  IOL1[1,1] IOB1[2,1] IOMUX2[3,1]    V[0,1] IOL3[1,1] IOB3[2,1]   
               G[0,0]  R[1,0]    I[2,0]    IOMUX1[3,0]    G[0,0]  R[1,0]    I[2,0]    IOMUX3[3,0]  
             ---------|---------|---------|---------   ---------|---------|---------|---------   
                         
                             TILE 0                                    TILE 1                     
              
            ]

  Revision History:

*****************************************************************************************/
function place_io_aba_ttf_2cim_h_tile ( unsigned int tx, ty)
{
    string strVar;
       
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // The wires are spread out in 2 tiles. Pre-calculate the lower-left corner of all 2 tiles
    unsigned int tile_0_sx =  tx              * TILE_NUM_SITE_X;
    unsigned int tile_1_sx = (tx + 1)         * TILE_NUM_SITE_X;
    
    //
    // Layout IOL1 in the tile #0
    //
    // Allocate the wires driven by IOL1
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", tile_0_sx+1, sy+1);
    &wire ntRef_ntIOL1_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", tile_0_sx+1, sy+1);
    &wire ntRef_ntIOL1_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", tile_0_sx+1, sy+1);
    &wire ntRef_ntIOL1_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", tile_0_sx+1, sy+1);
    &wire ntRef_ntIOL1_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", tile_0_sx+1, sy+1);
    &wire ntRef_ntIOL1_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", tile_0_sx+1, sy+1);
    &wire ntRef_ntIOL1_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;    
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", tile_0_sx+1, sy+1);                             
    &wire ntRef_ntIOL1_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", tile_0_sx+1, sy+1);                             
    &wire ntRef_ntIOL1_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntDO_OUT_%d_%d", tile_0_sx+1, sy+1);
    &wire ntRef_ntIOL1_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", tile_0_sx+1, sy+1);
    &wire ntRef_ntIOL1_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
        
    //
    // Layout IOB1(IOB_A) in the tile #0
    //
    // Allocate the wires driven by IOB1 
    //
    sprintf(strVar, "ntDIN_%d_%d", tile_0_sx+2, sy+1);
    &wire ntRef_ntIOB1_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFO_OUT_%d_%d", tile_0_sx+2, sy+1);
    &wire ntRef_ntIOB1_DIFFO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", tile_0_sx+2, sy+1);
    &wire ntRef_ntIOB1_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOL2 in the tile #0
    //
    // Allocate the wires driven by IOL2
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", tile_0_sx+1, sy+2);
    &wire ntRef_ntIOL2_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", tile_0_sx+1, sy+2);
    &wire ntRef_ntIOL2_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", tile_0_sx+1, sy+2);
    &wire ntRef_ntIOL2_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    sprintf(strVar, "ntRX_DATA_%d_%d", tile_0_sx+1, sy+2);
    &wire ntRef_ntIOL2_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", tile_0_sx+1, sy+2);
    &wire ntRef_ntIOL2_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", tile_0_sx+1, sy+2);
    &wire ntRef_ntIOL2_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", tile_0_sx+1, sy+2);                             
    &wire ntRef_ntIOL2_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", tile_0_sx+1, sy+2);                             
    &wire ntRef_ntIOL2_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    //
    // Layout IOB2(IOB_B) in the tile #0
    //
    // Allocate the wires driven by IOB2 
    //
    sprintf(strVar, "ntDIN_%d_%d", tile_0_sx+2, sy+2);
    &wire ntRef_ntIOB2_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", tile_0_sx+2, sy+2);
    &wire ntRef_ntIOB2_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    //
    // Layout IOMUX1 in the tile #0
    //
    // Allocate the wires driven by IOMUX1 
    //
    sprintf(strVar, "ntOUT_%d_%d", tile_0_sx+3, sy);
    &wire ntRef_ntIOMUX1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX1 @[3,0] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", tile_0_sx+3, sy);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX1_OUT
                 )
        @[tile_0_sx+3,sy];
    
    //
    // Layout IOMUX2 in the tile #0
    //
    // Allocate the wires driven by IOMUX2 
    //
    sprintf(strVar, "ntOUT_%d_%d", tile_0_sx+3, sy+1);
    &wire ntRef_ntIOMUX2_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX2 @[3,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", tile_0_sx+3, sy+1);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX2_OUT
                 )
        @[tile_0_sx+3,sy+1];

    //
    // Instantiate the IOL1 @[1,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", tile_0_sx+1, sy+1);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL1_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL1_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL1_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL1_RX_DATA         ,
                   DO              => ntRef_ntIOL1_DO              ,
                   TO              => ntRef_ntIOL1_TO              ,
                   ODDR_COUT       => ntRef_ntIOL1_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL1_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL1_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL1_TO_OUT          ,
                   
                 
                   TX_DATA[0]     => <wire A_IA0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,      // IOL1 <- CIM
                   TX_DATA[1]     => <wire A_IA1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[2]     => <wire A_IA2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[3]     => <wire A_IA3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[4]     => <wire A_IA4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[5]     => <wire A_IB0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[0]     => <wire A_IB1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[1]     => <wire A_IB2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[2]     => <wire A_IB3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[3]     => <wire A_IB4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_STS_CLR    => <wire A_IC0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[0]  => <wire A_IC1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[1]  => <wire A_IC2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[2]  => <wire A_IC3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_CTRL[0]    => <wire A_IC4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_CTRL[1]    => <wire A_ID0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   SLIP           => <wire A_ID1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   SYSCLK         => <wire A_ICLK of <device CIM @[tile_0_sx+3, sy+2]>>   ,
                   CE             => <wire A_ICE of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   LRS            => <wire A_IRS of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   
                   DIN            => ntRef_ntIOB1_DIN                                    ,   // IOL1 <- IOB1
                   IOCLK          => ntRef_ntIOMUX1_OUT                                      // IOL1 <- IOMUX1
                 )
        @[tile_0_sx+1,sy+1];
        
    // Hook up the outputs of IOL1 -> CIM (TILE 0)
    connect
        (           
            <pin A_IY0   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_IODLY_OV      , 
            <pin A_IY1   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA_DD      ,
            <pin A_IY2   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[0]   ,
            <pin A_IY3   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[1]   ,
            <pin A_IQ0   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[2]   ,
            <pin A_IQ1   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[3]   ,
            <pin A_IQ2   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[4]   ,
            <pin A_IQ3   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[5]   ,
            <pin A_IY6AB of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_DPI_STS[0]    ,
            <pin A_IY6CD of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_DPI_STS[1]
        );
        
    //
    // Instantiate the IOB1 @[2,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_A_%d_%d", tile_0_sx+2, sy+1);
    device IOB_A *strVar
        port map (
                   DO          => ntRef_ntIOL1_DO        , //Input from IOL1 (Tile 0)
                   TO          => ntRef_ntIOL1_TO        ,
                   
                   DIN         => ntRef_ntIOB1_DIN       ,   //output
                   DIFFO_OUT   => ntRef_ntIOB1_DIFFO_OUT ,
                   DIFFI_OUT   => ntRef_ntIOB1_DIFFI_OUT
                 )
        @[tile_0_sx+2,sy+1];
        

    //
    // Instantiate the IOL2 @[1,2] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", tile_0_sx+1, sy+2);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL2_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL2_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL2_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL2_RX_DATA         ,
                   DO              => ntRef_ntIOL2_DO              ,
                   TO              => ntRef_ntIOL2_TO              ,
                   ODDR_COUT       => ntRef_ntIOL2_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL2_IDDR_COUT       ,

                   TX_DATA[0]        => <wire S_IA0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,   // IOL2 <- CIM
                   TX_DATA[1]        => <wire S_IA1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[2]        => <wire S_IA2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[3]        => <wire S_IA3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[4]        => <wire S_IA4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[5]        => <wire S_IB0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[0]        => <wire S_IB1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[1]        => <wire S_IB2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[2]        => <wire S_IB3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[3]        => <wire S_IB4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_STS_CLR       => <wire S_IC0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[0]     => <wire S_IC1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[1]     => <wire S_IC2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[2]     => <wire S_IC3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_CTRL[0]       => <wire S_IC4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_CTRL[1]       => <wire S_ID0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   SLIP              => <wire S_ID1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   SYSCLK            => <wire S_ICLK of <device CIM @[tile_0_sx+3, sy+2]>>   ,
                   CE                => <wire S_ICE of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   LRS               => <wire S_IRS of <device CIM @[tile_0_sx+3, sy+2]>>    ,

                   DIN              => ntRef_ntIOB2_DIN                                      , // IOL2 <- IOB2
                   IOCLK            => ntRef_ntIOMUX2_OUT                                      // IOL2 <- IOMUX2
                 )
        @[tile_0_sx+1,sy+2];
        
    // Hook up the outputs of CIM <- IOL2
    connect
        (          
            <pin S_IY0   of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_IODLY_OV       ,
            <pin S_IY1   of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA_DD       ,
            <pin S_IY2   of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[0]    ,
            <pin S_IY3   of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[1]    ,
            <pin S_IQ0   of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[2]    ,
            <pin S_IQ1   of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[3]    ,
            <pin S_IQ2   of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[4]    ,
            <pin S_IQ3   of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[5]    ,
            <pin A_IY6AB of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL2_DPI_STS[0]     ,
            <pin A_IY6CD of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL2_DPI_STS[1]
        );  
        
    //
    // Instantiate the IOB2 @[2,2] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_B_%d_%d", tile_0_sx+2, sy+2);
    device IOB_B *strVar
        port map (
                   DO         => ntRef_ntIOL2_DO    ,  //Input from IOL2 (Tile 0)
                   TO         => ntRef_ntIOL2_TO     ,
                   
                   DIN        => ntRef_ntIOB2_DIN     ,  //output
                   DIFFI_OUT     => ntRef_ntIOB2_DIFFI_OUT  
                 )
        @[tile_0_sx+2,sy+2];
        
    //
    // Layout IOL3 in the tile #1
    //
    // Allocate the wires driven by IOL3
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL3_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL3_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL3_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    sprintf(strVar, "ntRX_DATA_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL3_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL3_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL3_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", tile_1_sx+1, sy+1);                             
    &wire ntRef_ntIOL3_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", tile_1_sx+1, sy+1);                             
    &wire ntRef_ntIOL3_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 
    
    sprintf(strVar, "ntDO_OUT_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL3_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL3_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOB3(IOB_A) in the tile #1
    //
    // Allocate the wires driven by IOB3
    //
    sprintf(strVar, "ntDIN_%d_%d", tile_1_sx+2, sy+1);
    &wire ntRef_ntIOB3_DIN = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", tile_1_sx+2, sy+1);
    &wire ntRef_ntIOB3_DIFFI_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX3 in the tile #1
    //
    // Allocate the wires driven by IOMUX3
    //
    sprintf(strVar, "ntOUT_%d_%d", tile_1_sx+3, sy);
    &wire ntRef_ntIOMUX3_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX3 @[3,0] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", tile_1_sx+3, sy);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX3_OUT
                 )
        @[tile_1_sx+3,sy];

    //
    // Instantiate the IOL3 @[1,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", tile_1_sx+1, sy+1);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL3_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL3_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL3_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL3_RX_DATA         ,
                   DO              => ntRef_ntIOL3_DO              ,
                   TO              => ntRef_ntIOL3_TO              ,
                   ODDR_COUT       => ntRef_ntIOL3_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL3_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL3_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL3_TO_OUT          ,
                  
                   TX_DATA[0]      => <wire A_IA0 of <device CIM @[tile_1_sx+3, sy+2]>>    ,      //IOL3 <- CIM (tile 1)
                   TX_DATA[1]      => <wire A_IA1 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TX_DATA[2]      => <wire A_IA2 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TX_DATA[3]      => <wire A_IA3 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TX_DATA[4]      => <wire A_IA4 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TX_DATA[5]      => <wire A_IB0 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TS_CTRL[0]      => <wire A_IB1 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TS_CTRL[1]      => <wire A_IB2 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TS_CTRL[2]      => <wire A_IB3 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TS_CTRL[3]      => <wire A_IB4 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   DPI_STS_CLR     => <wire A_IC0 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   IODLY_CTRL[0]   => <wire A_IC1 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   IODLY_CTRL[1]   => <wire A_IC2 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   IODLY_CTRL[2]   => <wire A_IC3 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   DPI_CTRL[0]     => <wire A_IC4 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   DPI_CTRL[1]     => <wire A_ID0 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   SLIP            => <wire A_ID1 of <device CIM @[tile_1_sx+3, sy+2]>>    ,                   
                   SYSCLK          => <wire A_ICLK of <device CIM @[tile_1_sx+3, sy+2]>>   ,
                   CE              => <wire A_ICE of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   LRS             => <wire A_IRS of <device CIM @[tile_1_sx+3, sy+2]>>    ,

                   DIN             => ntRef_ntIOB3_DIN                                     ,  // IOL3 <- IOB3 (Tile 1) 
                   IOCLK           => ntRef_ntIOMUX3_OUT                                      // IOL3 <- IOMUX3

                 )
        @[tile_1_sx+1,sy+1];

    // Hook up the outputs of IOL3 -> CIM (TILE 1)
    connect
        (            
            <pin A_IY0   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_IODLY_OV       , 
            <pin A_IY1   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA_DD       ,
            <pin A_IY2   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[0]    ,
            <pin A_IY3   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[1]    ,
            <pin A_IQ0   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[2]    ,
            <pin A_IQ1   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[3]    ,
            <pin A_IQ2   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[4]    ,
            <pin A_IQ3   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[5]    ,
            <pin S_IY6AB of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_DPI_STS[0]     ,
            <pin S_IY6CD of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_DPI_STS[1]
        );

    //
    // Instantiate the IOB3 @[2,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LA_%d_%d", tile_1_sx+2, sy+1);
    device IOB_LA *strVar
        port map (
                   DO          => ntRef_ntIOL3_DO         ,   //Input from IOL3 (Tile 1)
                   TO          => ntRef_ntIOL3_TO         ,
                   
                   DIN         => ntRef_ntIOB3_DIN        ,   //output
                   DIFFI_OUT   => ntRef_ntIOB3_DIFFI_OUT
                 )
        @[tile_1_sx+2,sy+1];

};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-2CIM block tiles in horizontal direction. 
             Each IO block takes the size of 2 tiles. 
             
             ---------|---------|---------|---------   ---------|---------|---------|---------  
                       IOL2[1,2] IOB2[2,2]  C[3,2]                                    C[3,2]
               V[0,1]  IOL1[1,1] IOB1[2,1]  IOMUX2[3,1]   V[0,1] IOL3[1,1] IOB3[2,1]   
               G[0,0]  R[1,0]    I[2,0]     IOMUX1[3,0]   G[0,0]  R[1,0]    I[2,0]   IOMUX3[3,0]  
             ---------|---------|---------|---------   ---------|---------|---------|---------   
                         
                             TILE 0                                    TILE 1                     
              
            ]

  Revision History:

*****************************************************************************************/
function place_io_aba_fft_2cim_h_tile ( unsigned int tx, ty)
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // The wires are spread out in 2 tiles. Pre-calculate the lower-left corner of all 2 tiles
    unsigned int tile_0_sx =  tx              * TILE_NUM_SITE_X;
    unsigned int tile_1_sx = (tx + 1)         * TILE_NUM_SITE_X;
    
    //
    // Layout IOL1 in the tile #0
    //
    // Allocate the wires driven by IOL1
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", tile_0_sx+1, sy+1);
    &wire ntRef_ntIOL1_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", tile_0_sx+1, sy+1);
    &wire ntRef_ntIOL1_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", tile_0_sx+1, sy+1);
    &wire ntRef_ntIOL1_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", tile_0_sx+1, sy+1);
    &wire ntRef_ntIOL1_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", tile_0_sx+1, sy+1);
    &wire ntRef_ntIOL1_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", tile_0_sx+1, sy+1);
    &wire ntRef_ntIOL1_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;    
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", tile_0_sx+1, sy+1);                             
    &wire ntRef_ntIOL1_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", tile_0_sx+1, sy+1);                             
    &wire ntRef_ntIOL1_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntDO_OUT_%d_%d", tile_0_sx+1, sy+1);
    &wire ntRef_ntIOL1_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", tile_0_sx+1, sy+1);
    &wire ntRef_ntIOL1_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 
       
    //
    // Layout IOB1(IOB_A) in the tile #0
    //
    // Allocate the wires driven by IOB1 
    //
    sprintf(strVar, "ntDIN_%d_%d", tile_0_sx+2, sy+1);
    &wire ntRef_ntIOB1_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", tile_0_sx+2, sy+1);
    &wire ntRef_ntIOB1_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOL2 in the tile #0
    //
    // Allocate the wires driven by IOL2
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", tile_0_sx+1, sy+2);
    &wire ntRef_ntIOL2_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", tile_0_sx+1, sy+2);
    &wire ntRef_ntIOL2_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", tile_0_sx+1, sy+2);
    &wire ntRef_ntIOL2_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    sprintf(strVar, "ntRX_DATA_%d_%d", tile_0_sx+1, sy+2);
    &wire ntRef_ntIOL2_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", tile_0_sx+1, sy+2);
    &wire ntRef_ntIOL2_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", tile_0_sx+1, sy+2);
    &wire ntRef_ntIOL2_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", tile_0_sx+1, sy+2);                             
    &wire ntRef_ntIOL2_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", tile_0_sx+1, sy+2);                             
    &wire ntRef_ntIOL2_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    //
    // Layout IOB2(IOB_B) in the tile #0
    //
    // Allocate the wires driven by IOB2 
    //
    sprintf(strVar, "ntDIN_%d_%d", tile_0_sx+2, sy+2);
    &wire ntRef_ntIOB2_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", tile_0_sx+2, sy+2);
    &wire ntRef_ntIOB2_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    //
    // Layout IOMUX1 in the tile #0
    //
    // Allocate the wires driven by IOMUX1 
    //
    sprintf(strVar, "ntOUT_%d_%d", tile_0_sx+3, sy);
    &wire ntRef_ntIOMUX1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX1 @[3,0] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", tile_0_sx+3, sy);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX1_OUT
                 )
        @[tile_0_sx+3,sy];
    
    //
    // Layout IOMUX2 in the tile #0
    //
    // Allocate the wires driven by IOMUX2 
    //
    sprintf(strVar, "ntOUT_%d_%d", tile_0_sx+3, sy+1);
    &wire ntRef_ntIOMUX2_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX2 @[3,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", tile_0_sx+3, sy+1);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX2_OUT
                 )
        @[tile_0_sx+3,sy+1];

    //
    // Instantiate the IOL1 @[1,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", tile_0_sx+1, sy+1);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL1_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL1_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL1_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL1_RX_DATA         ,
                   DO              => ntRef_ntIOL1_DO              ,
                   TO              => ntRef_ntIOL1_TO              ,
                   ODDR_COUT       => ntRef_ntIOL1_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL1_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL1_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL1_TO_OUT          ,
                 
                   TX_DATA[0]     => <wire A_IA0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,      // IOL1 <- CIM
                   TX_DATA[1]     => <wire A_IA1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[2]     => <wire A_IA2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[3]     => <wire A_IA3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[4]     => <wire A_IA4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[5]     => <wire A_IB0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[0]     => <wire A_IB1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[1]     => <wire A_IB2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[2]     => <wire A_IB3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[3]     => <wire A_IB4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_STS_CLR    => <wire A_IC0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[0]  => <wire A_IC1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[1]  => <wire A_IC2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[2]  => <wire A_IC3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_CTRL[0]    => <wire A_IC4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_CTRL[1]    => <wire A_ID0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   SLIP           => <wire A_ID1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   SYSCLK         => <wire A_ICLK of <device CIM @[tile_0_sx+3, sy+2]>>   ,
                   CE             => <wire A_ICE of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   LRS            => <wire A_IRS of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   
                   DIN            => ntRef_ntIOB1_DIN                                     ,  // IOL1 <- IOB1
                   IOCLK          => ntRef_ntIOMUX1_OUT                                      // IOL1 <- IOMUX1
                 )
        @[tile_0_sx+1,sy+1];
        
    // Hook up the outputs of IOL1 -> CIM (TILE 0)
    connect
        (           
            <pin A_IY0   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_IODLY_OV      , 
            <pin A_IY1   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA_DD      ,
            <pin A_IY2   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[0]   ,
            <pin A_IY3   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[1]   ,
            <pin A_IQ0   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[2]   ,
            <pin A_IQ1   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[3]   ,
            <pin A_IQ2   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[4]   ,
            <pin A_IQ3   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[5]   ,
            <pin A_IY6AB of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_DPI_STS[0]    ,
            <pin A_IY6CD of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_DPI_STS[1]
        );
        
    //
    // Instantiate the IOB1 @[2,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LA_%d_%d", tile_0_sx+2, sy+1);
    device IOB_LA *strVar
        port map (
                   DO          => ntRef_ntIOL1_DO        , //Input from IOL1 (Tile 0)
                   TO          => ntRef_ntIOL1_TO        ,
                   
                   DIN         => ntRef_ntIOB1_DIN       ,   //output
                   DIFFI_OUT   => ntRef_ntIOB1_DIFFI_OUT
                 )
        @[tile_0_sx+2,sy+1];
        

    //
    // Instantiate the IOL2 @[1,2] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", tile_0_sx+1, sy+2);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL2_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL2_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL2_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL2_RX_DATA         ,
                   DO              => ntRef_ntIOL2_DO              ,
                   TO              => ntRef_ntIOL2_TO              ,
                   ODDR_COUT       => ntRef_ntIOL2_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL2_IDDR_COUT       ,

                   TX_DATA[0]        => <wire S_IA0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,   // IOL2 <- CIM
                   TX_DATA[1]        => <wire S_IA1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[2]        => <wire S_IA2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[3]        => <wire S_IA3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[4]        => <wire S_IA4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[5]        => <wire S_IB0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[0]        => <wire S_IB1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[1]        => <wire S_IB2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[2]        => <wire S_IB3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[3]        => <wire S_IB4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_STS_CLR       => <wire S_IC0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[0]     => <wire S_IC1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[1]     => <wire S_IC2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[2]     => <wire S_IC3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_CTRL[0]       => <wire S_IC4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_CTRL[1]       => <wire S_ID0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   SLIP              => <wire S_ID1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   SYSCLK            => <wire S_ICLK of <device CIM @[tile_0_sx+3, sy+2]>>   ,
                   CE                => <wire S_ICE of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   LRS               => <wire S_IRS of <device CIM @[tile_0_sx+3, sy+2]>>    ,

                   DIN               => ntRef_ntIOB2_DIN                                     ,   // IOL2 <- IOB2
                   IOCLK             => ntRef_ntIOMUX2_OUT                                       // IOL2 <- IOMUX2
                 )
        @[tile_0_sx+1,sy+2];
        
    // Hook up the outputs of CIM <- IOL2
    connect
        (          
            <pin S_IY0   of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_IODLY_OV       ,
            <pin S_IY1   of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA_DD       ,
            <pin S_IY2   of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[0]    ,
            <pin S_IY3   of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[1]    ,
            <pin S_IQ0   of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[2]    ,
            <pin S_IQ1   of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[3]    ,
            <pin S_IQ2   of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[4]    ,
            <pin S_IQ3   of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[5]    ,
            <pin A_IY6AB of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL2_DPI_STS[0]     ,
            <pin A_IY6CD of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL2_DPI_STS[1]
        );  
        
    //
    // Instantiate the IOB2 @[2,2] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LB_%d_%d", tile_0_sx+2, sy+2);
    device IOB_LB *strVar
        port map (
                   DO         => ntRef_ntIOL2_DO    ,  //Input from IOL2 (Tile 0)
                   TO         => ntRef_ntIOL2_TO     ,
                   
                   DIN        => ntRef_ntIOB2_DIN     ,  //output
                   DIFFI_OUT     => ntRef_ntIOB2_DIFFI_OUT  
                 )
        @[tile_0_sx+2,sy+2];
        
    //
    // Layout IOL3 in the tile #1
    //
    // Allocate the wires driven by IOL3
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL3_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL3_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL3_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    sprintf(strVar, "ntRX_DATA_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL3_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL3_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL3_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", tile_1_sx+1, sy+1);                             
    &wire ntRef_ntIOL3_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", tile_1_sx+1, sy+1);                             
    &wire ntRef_ntIOL3_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 
    
    sprintf(strVar, "ntDO_OUT_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL3_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL3_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    //
    // Layout IOB3(IOB_A) in the tile #1
    //
    // Allocate the wires driven by IOB3
    //
    sprintf(strVar, "ntDIN_%d_%d", tile_1_sx+2, sy+1);
    &wire ntRef_ntIOB3_DIN = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFO_OUT_%d_%d", tile_1_sx+2, sy+1);
    &wire ntRef_ntIOB3_DIFFO_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", tile_1_sx+2, sy+1);
    &wire ntRef_ntIOB3_DIFFI_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX3 in the tile #1
    //
    // Allocate the wires driven by IOMUX3
    //
    sprintf(strVar, "ntOUT_%d_%d", tile_1_sx+3, sy);
    &wire ntRef_ntIOMUX3_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX3 @[3,0] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", tile_1_sx+3, sy);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX3_OUT
                 )
        @[tile_1_sx+3,sy];

    //
    // Instantiate the IOL3 @[1,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", tile_1_sx+1, sy+1);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL3_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL3_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL3_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL3_RX_DATA         ,
                   DO              => ntRef_ntIOL3_DO              ,
                   TO              => ntRef_ntIOL3_TO              ,
                   ODDR_COUT       => ntRef_ntIOL3_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL3_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL3_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL3_TO_OUT          ,
                  
                   TX_DATA[0]      => <wire A_IA0 of <device CIM @[tile_1_sx+3, sy+2]>>    ,      //IOL3 <- CIM (tile 1)
                   TX_DATA[1]      => <wire A_IA1 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TX_DATA[2]      => <wire A_IA2 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TX_DATA[3]      => <wire A_IA3 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TX_DATA[4]      => <wire A_IA4 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TX_DATA[5]      => <wire A_IB0 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TS_CTRL[0]      => <wire A_IB1 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TS_CTRL[1]      => <wire A_IB2 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TS_CTRL[2]      => <wire A_IB3 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TS_CTRL[3]      => <wire A_IB4 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   DPI_STS_CLR     => <wire A_IC0 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   IODLY_CTRL[0]   => <wire A_IC1 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   IODLY_CTRL[1]   => <wire A_IC2 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   IODLY_CTRL[2]   => <wire A_IC3 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   DPI_CTRL[0]     => <wire A_IC4 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   DPI_CTRL[1]     => <wire A_ID0 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   SLIP            => <wire A_ID1 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   SYSCLK          => <wire A_ICLK of <device CIM @[tile_1_sx+3, sy+2]>>   ,
                   CE              => <wire A_ICE of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   LRS             => <wire A_IRS of <device CIM @[tile_1_sx+3, sy+2]>>    ,

                   DIN             => ntRef_ntIOB3_DIN                                     ,   //IOL3 <- IOB3 (Tile 1) 
                   IOCLK           => ntRef_ntIOMUX3_OUT                                      // IOL3 <- IOMUX3

                 )
        @[tile_1_sx+1,sy+1];

    // Hook up the outputs of IOL3 -> CIM (TILE 1)
    connect
        (            
            <pin A_IY0   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_IODLY_OV       , 
            <pin A_IY1   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA_DD       ,
            <pin A_IY2   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[0]    ,
            <pin A_IY3   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[1]    ,
            <pin A_IQ0   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[2]    ,
            <pin A_IQ1   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[3]    ,
            <pin A_IQ2   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[4]    ,
            <pin A_IQ3   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[5]    ,
            <pin S_IY6AB of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_DPI_STS[0]     ,
            <pin S_IY6CD of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_DPI_STS[1]
        );

    //
    // Instantiate the IOB3 @[2,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_A_%d_%d", tile_1_sx+2, sy+1);
    device IOB_A *strVar
        port map (
                   DO          => ntRef_ntIOL3_DO         ,   //Input from IOL3 (Tile 1)
                   TO          => ntRef_ntIOL3_TO         ,
                   
                   DIN         => ntRef_ntIOB3_DIN        ,   //output
                   DIFFO_OUT   => ntRef_ntIOB3_DIFFO_OUT  ,
                   DIFFI_OUT   => ntRef_ntIOB3_DIFFI_OUT
                 )
        @[tile_1_sx+2,sy+1];

};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-2CIM block tiles in horizontal direction. 
             Each IO block takes the size of 2 tiles(TILE 0 and TILE 1). 
             
             The 4cim - 6io is like this original:
             ------------  ------------  ------------  ------------
              IOL  IOB_B                  IOL IOB_B     IOL IOB_B     
              IOL  IOB_A   IOL IOB_A                    IOL IOB_A
             ------------  ------------  ------------  ------------
               TILE 0        TILE 1        TILE 2        TILE 3
             
             There is one IO placed in pre-tile for assemble a IO pair in tile 1.
             --------|----------|----------|---------  ---------|---------|---------|---------   ---------|---------|---------|---------  
                        IOL4[1,2] IOB4[2,2]  C[3,2]                                   C[3,2]                IOL6[1,2] IOB6[2,2]  C[3,2] 
                                                         V[0,1]                                     V[0,1]  IOL5[1,1] IOB5[2,1]  
                                                         G[0,0]   R[1,0]    I[2,0]                  G[0,0]  R[1,0]    I[2,0]      
             --------|----------|---------|---------   ---------|---------|---------|---------   ---------|---------|---------|---------   

                             TILE 1                                     TILE 2                               TILE 3  
                             
             In this function,we describe as :
             --------|----------|----------|---------  ---------|---------|---------|---------   ---------|---------|---------|---------  
                        IOL1[1,2] IOB1[2,2]  C[3,2]                                   C[3,2]                IOL3[1,2] IOB3[2,2]  C[3,2]
                                            IOMUX1[3,1]  V[0,1]                                     V[0,1]  IOL2[1,1] IOB2[2,1]  IOMUX3[3,1]
                                                         G[0,0]   R[1,0]    I[2,0]                  G[0,0]  R[1,0]    I[2,0]     IOMUX2[3,0] 
             --------|----------|---------|---------   ---------|---------|---------|---------   ---------|---------|---------|---------   

                             TILE PRE                                     TILE 0                               TILE 1  

             The 4cim - 6io is like this in actual:
             ------------  ------------  ------------  ------------
              IOL  IOB_B   IOL IOB_B                    IOL IOB_B      
              IOL  IOB_A   IOL IOB_A                    IOL IOB_A
             ------------  ------------  ------------  ------------                
              
            ]

  Revision History:

*****************************************************************************************/
function place_io_bab_ftt_2cim_h_tile ( unsigned int tx, ty)
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // The wires are spread out in 2 tiles. Pre-calculate the lower-left corner of all 2 tiles
    unsigned int tile_pre_sx = (tx - 1)   * TILE_NUM_SITE_X;
    unsigned int tile_0_sx   =  tx        * TILE_NUM_SITE_X;
    unsigned int tile_1_sx   = (tx + 1)   * TILE_NUM_SITE_X;
    
    //
    // Layout IOL1 in the tile #pre
    //
    // Allocate the wires driven by IOL1
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", tile_pre_sx+1, sy+2);
    &wire ntRef_ntIOL1_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", tile_pre_sx+1, sy+2);
    &wire ntRef_ntIOL1_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", tile_pre_sx+1, sy+2);
    &wire ntRef_ntIOL1_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", tile_pre_sx+1, sy+2);
    &wire ntRef_ntIOL1_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", tile_pre_sx+1, sy+2);
    &wire ntRef_ntIOL1_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", tile_pre_sx+1, sy+2);
    &wire ntRef_ntIOL1_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;    
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", tile_pre_sx+1, sy+2);                             
    &wire ntRef_ntIOL1_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", tile_pre_sx+1, sy+2);                             
    &wire ntRef_ntIOL1_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;   
    
    //
    // Layout IOB1(IOB_B) in the tile #pre
    //
    // Allocate the wires driven by IOB1 
    //
    sprintf(strVar, "ntDIN_%d_%d", tile_pre_sx+2, sy+2);
    &wire ntRef_ntIOB1_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", tile_pre_sx+2, sy+2);
    &wire ntRef_ntIOB1_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX1 in the tile #pre
    //
    // Allocate the wires driven by IOMUX1 
    //
    sprintf(strVar, "ntOUT_%d_%d", tile_pre_sx+3, sy+1);
    &wire ntRef_ntIOMUX1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX1 @[3,1] in tile #pre. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", tile_pre_sx+3, sy+1);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX1_OUT
                 )
        @[tile_pre_sx+3,sy+1];
    
    //
    // Layout IOL2 in the tile #1
    //
    // Allocate the wires driven by IOL2
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL2_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL2_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL2_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    sprintf(strVar, "ntRX_DATA_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL2_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL2_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL2_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", tile_1_sx+1, sy+1);                             
    &wire ntRef_ntIOL2_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", tile_1_sx+1, sy+1);                             
    &wire ntRef_ntIOL2_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntDO_OUT_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL2_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL2_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOB2(IOB_A) in the tile #1
    //
    // Allocate the wires driven by IOB2 
    //
    sprintf(strVar, "ntDIN_%d_%d", tile_1_sx+2, sy+1);
    &wire ntRef_ntIOB2_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    sprintf(strVar, "ntDIFFO_OUT_%d_%d", tile_1_sx+2, sy+1);
    &wire ntRef_ntIOB2_DIFFO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", tile_1_sx+2, sy+1);
    &wire ntRef_ntIOB2_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX2 in the tile #1
    //
    // Allocate the wires driven by IOMUX2 
    //
    sprintf(strVar, "ntOUT_%d_%d", tile_1_sx+3, sy);
    &wire ntRef_ntIOMUX2_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX2 @[3,0] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", tile_1_sx+3, sy);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX2_OUT
                 )
        @[tile_1_sx+3,sy];
        
    //
    // Instantiate the IOL1 @[1,2] in tile #pre. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", tile_pre_sx+1, sy+2);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL1_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL1_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL1_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL1_RX_DATA         ,
                   DO              => ntRef_ntIOL1_DO              ,
                   TO              => ntRef_ntIOL1_TO              ,
                   ODDR_COUT       => ntRef_ntIOL1_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL1_IDDR_COUT       ,
                 
                   TX_DATA[0]       => <wire A_IA0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,      // IOL1 <- SIB
                   TX_DATA[1]       => <wire A_IA1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[2]       => <wire A_IA2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[3]       => <wire A_IA3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[4]       => <wire A_IA4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[5]       => <wire A_IB0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[0]       => <wire A_IB1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[1]       => <wire A_IB2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[2]       => <wire A_IB3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[3]       => <wire A_IB4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_STS_CLR      => <wire A_IC0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[0]    => <wire A_IC1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[1]    => <wire A_IC2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[2]    => <wire A_IC3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_CTRL[0]      => <wire A_IC4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_CTRL[1]      => <wire A_ID0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   SLIP             => <wire A_ID1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   SYSCLK           => <wire A_ICLK of <device CIM @[tile_0_sx+3, sy+2]>>   ,
                   CE               => <wire A_ICE of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   LRS              => <wire A_IRS of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   
                   DIN              => ntRef_ntIOB1_DIN                                     , // IOL1 <- IOB1
                   IOCLK            => ntRef_ntIOMUX1_OUT                                     // IOL1 <- IOMUX1
                 )
        @[tile_pre_sx+1,sy+2];
        
    // Hook up the outputs of IOL1 -> SRB (TILE 0)
    connect
        (           
            <pin A_IY0   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_IODLY_OV      , 
            <pin A_IY1   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA_DD      ,
            <pin A_IY2   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[0]   ,
            <pin A_IY3   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[1]   ,
            <pin A_IQ0   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[2]   ,
            <pin A_IQ1   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[3]   ,
            <pin A_IQ2   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[4]   ,
            <pin A_IQ3   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[5]   ,
            <pin A_IY6AB of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_DPI_STS[0]    ,
            <pin A_IY6CD of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_DPI_STS[1]
        );
        
    //
    // Instantiate the IOB1 @[2,2] in tile #pre. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LB_%d_%d", tile_pre_sx+2, sy+2);
    device IOB_LB *strVar
        port map (
                   DO         => ntRef_ntIOL1_DO     , //Input from IOL1 (Tile 0)
                   TO         => ntRef_ntIOL1_TO      ,
                   
                   DIN        => ntRef_ntIOB1_DIN      ,   //output
                   DIFFI_OUT     => ntRef_ntIOB1_DIFFI_OUT  
                 )
        @[tile_pre_sx+2,sy+2];
        

    //
    // Instantiate the IOL2 @[1,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", tile_1_sx+1, sy+1);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL2_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL2_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL2_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL2_RX_DATA         ,
                   DO              => ntRef_ntIOL2_DO              ,
                   TO              => ntRef_ntIOL2_TO              ,
                   ODDR_COUT       => ntRef_ntIOL2_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL2_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL2_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL2_TO_OUT          ,

                   TX_DATA[0]        => <wire S_IA0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,   // IOL2 <- SIB
                   TX_DATA[1]        => <wire S_IA1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[2]        => <wire S_IA2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[3]        => <wire S_IA3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[4]        => <wire S_IA4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[5]        => <wire S_IB0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[0]        => <wire S_IB1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[1]        => <wire S_IB2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[2]        => <wire S_IB3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[3]        => <wire S_IB4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_STS_CLR       => <wire S_IC0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[0]     => <wire S_IC1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[1]     => <wire S_IC2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[2]     => <wire S_IC3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_CTRL[0]       => <wire S_IC4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_CTRL[1]       => <wire S_ID0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   SLIP              => <wire S_ID1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   SYSCLK            => <wire S_ICLK of <device CIM @[tile_0_sx+3, sy+2]>>   ,
                   CE                => <wire S_ICE of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   LRS               => <wire S_IRS of <device CIM @[tile_0_sx+3, sy+2]>>    ,

                   DIN               => ntRef_ntIOB2_DIN                                     , // IOL2 <- IOB2
                   IOCLK             => ntRef_ntIOMUX2_OUT                                     // IOL2 <- IOMUX2
                 )
        @[tile_1_sx+1,sy+1];
        
    // Hook up the outputs of SRB <- IOL2
    connect
        (          
            <pin S_IY0 of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_IODLY_OV       ,
            <pin S_IY1 of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA_DD       ,
            <pin S_IY2 of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[0]    ,
            <pin S_IY3 of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[1]    ,
            <pin S_IQ0 of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[2]    ,
            <pin S_IQ1 of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[3]    ,
            <pin S_IQ2 of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[4]    ,
            <pin S_IQ3 of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[5]    ,
            <pin A_IY6AB of <device CIM @[tile_1_sx+3,sy+2]>> => ntRef_ntIOL2_DPI_STS[0]     ,
            <pin A_IY6CD of <device CIM @[tile_1_sx+3,sy+2]>> => ntRef_ntIOL2_DPI_STS[1]
        );  
        
    //
    // Instantiate the IOB2 @[2,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_A_%d_%d", tile_1_sx+2, sy+1);
    device IOB_A *strVar
        port map (
                   DO          => ntRef_ntIOL2_DO        ,  //Input from IOL2 (Tile 1)
                   TO          => ntRef_ntIOL2_TO        ,
                   
                   DIN         => ntRef_ntIOB2_DIN       ,  //output
                   DIFFO_OUT   => ntRef_ntIOB2_DIFFO_OUT ,
                   DIFFI_OUT   => ntRef_ntIOB2_DIFFI_OUT 
                 )
        @[tile_1_sx+2,sy+1];
        
    //
    // Layout IOL3 in the tile #1
    //
    // Allocate the wires driven by IOL3
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", tile_1_sx+1, sy+2);
    &wire ntRef_ntIOL3_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", tile_1_sx+1, sy+2);
    &wire ntRef_ntIOL3_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", tile_1_sx+1, sy+2);
    &wire ntRef_ntIOL3_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    sprintf(strVar, "ntRX_DATA_%d_%d", tile_1_sx+1, sy+2);
    &wire ntRef_ntIOL3_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", tile_1_sx+1, sy+2);
    &wire ntRef_ntIOL3_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", tile_1_sx+1, sy+2);
    &wire ntRef_ntIOL3_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", tile_1_sx+1, sy+2);                             
    &wire ntRef_ntIOL3_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", tile_1_sx+1, sy+2);                             
    &wire ntRef_ntIOL3_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 

    //
    // Layout IOB3 in the tile #1
    //
    // Allocate the wires driven by IOB3
    //
    sprintf(strVar, "ntDIN_%d_%d", tile_1_sx+2, sy+2);
    &wire ntRef_ntIOB3_DIN = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", tile_1_sx+2, sy+2);
    &wire ntRef_ntIOB3_DIFFI_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX3 in the tile #1
    //
    // Allocate the wires driven by IOMUX3
    //
    sprintf(strVar, "ntOUT_%d_%d", tile_1_sx+3, sy+1);
    &wire ntRef_ntIOMUX3_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX3 @[3,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", tile_1_sx+3, sy+1);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX3_OUT
                 )
        @[tile_1_sx+3,sy+1];
        
    //
    // Instantiate the IOL3 @[1,2] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", tile_1_sx+1, sy+2);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL3_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL3_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL3_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL3_RX_DATA         ,
                   DO              => ntRef_ntIOL3_DO              ,
                   TO              => ntRef_ntIOL3_TO              ,
                   ODDR_COUT       => ntRef_ntIOL3_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL3_IDDR_COUT       ,
                  
                   TX_DATA[0]      => <wire A_IA0 of <device CIM @[tile_1_sx+3, sy+2]>>    ,      //IOL3 <- CIM (tile 1)
                   TX_DATA[1]      => <wire A_IA1 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TX_DATA[2]      => <wire A_IA2 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TX_DATA[3]      => <wire A_IA3 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TX_DATA[4]      => <wire A_IA4 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TX_DATA[5]      => <wire A_IB0 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TS_CTRL[0]      => <wire A_IB1 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TS_CTRL[1]      => <wire A_IB2 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TS_CTRL[2]      => <wire A_IB3 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TS_CTRL[3]      => <wire A_IB4 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   DPI_STS_CLR     => <wire A_IC0 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   IODLY_CTRL[0]   => <wire A_IC1 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   IODLY_CTRL[1]   => <wire A_IC2 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   IODLY_CTRL[2]   => <wire A_IC3 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   DPI_CTRL[0]     => <wire A_IC4 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   DPI_CTRL[1]     => <wire A_ID0 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   SLIP            => <wire A_ID1 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   SYSCLK          => <wire A_ICLK of <device CIM @[tile_1_sx+3, sy+2]>>   ,
                   CE              => <wire A_ICE of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   LRS             => <wire A_IRS of <device CIM @[tile_1_sx+3, sy+2]>>    ,

                   DIN             => ntRef_ntIOB3_DIN                                     ,  //IOL3 <- IOB3 (Tile 1)
                   IOCLK           => ntRef_ntIOMUX3_OUT                                      // IOL3 <- IOMUX3 

                 )
        @[tile_1_sx+1,sy+2];

    // Hook up the outputs of IOL3 -> CIM (TILE 1)
    connect
        (            
            <pin A_IY0   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_IODLY_OV       , 
            <pin A_IY1   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA_DD       ,
            <pin A_IY2   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[0]    ,
            <pin A_IY3   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[1]    ,
            <pin A_IQ0   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[2]    ,
            <pin A_IQ1   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[3]    ,
            <pin A_IQ2   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[4]    ,
            <pin A_IQ3   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[5]    ,
            <pin S_IY6AB of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_DPI_STS[0]     ,
            <pin S_IY6CD of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_DPI_STS[1]
        );

    //
    // Instantiate the IOB3 @[2,2] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_B_%d_%d", tile_1_sx+2, sy+2);
    device IOB_B *strVar
        port map (
                   DO           => ntRef_ntIOL3_DO        ,   //Input from IOL3 (Tile 1)
                   TO           => ntRef_ntIOL3_TO        ,
                   
                   DIN          => ntRef_ntIOB3_DIN       ,   //output
                   DIFFI_OUT    => ntRef_ntIOB3_DIFFI_OUT
                 )
        @[tile_1_sx+2,sy+2];

};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-2CIM block tiles in horizontal direction. 
             Each IO block takes the size of 2 tiles(TILE 0 and TILE 1). 
             
             The 4cim - 6io is like this original:
             ------------  ------------  ------------  ------------
              IOL  IOB_B                  IOL IOB_B     IOL IOB_B     
              IOL  IOB_A   IOL IOB_A                    IOL IOB_A
             ------------  ------------  ------------  ------------
               TILE 0        TILE 1        TILE 2        TILE 3
             
             There is one IO placed in pre-tile for assemble a IO pair in tile 1.
             --------|----------|----------|---------  ---------|---------|---------|---------   ---------|---------|---------|---------  
                        IOL4[1,2] IOB4[2,2]  C[3,2]                                   C[3,2]                IOL6[1,2] IOB6[2,2]  C[3,2] 
                                                         V[0,1]                                     V[0,1]  IOL5[1,1] IOB5[2,1]  
                                                         G[0,0]   R[1,0]    I[2,0]                  G[0,0]  R[1,0]    I[2,0]      
             --------|----------|---------|---------   ---------|---------|---------|---------   ---------|---------|---------|---------   

                             TILE 1                                     TILE 2                               TILE 3  
                             
             In this function,we describe as :
             --------|----------|----------|---------  ---------|---------|---------|---------   ---------|---------|---------|---------  
                        IOL1[1,2] IOB1[2,2]  C[3,2]                                   C[3,2]                IOL3[1,2] IOB3[2,2]  C[3,2]
                                             IOMUX1[3,1] V[0,1]                                     V[0,1]  IOL2[1,1] IOB2[2,1] IOMUX3[3,1]
                                                         G[0,0]   R[1,0]    I[2,0]                  G[0,0]  R[1,0]    I[2,0]    IOMUX2[3,0]  
             --------|----------|---------|---------   ---------|---------|---------|---------   ---------|---------|---------|---------   

                             TILE PRE                                     TILE 0                               TILE 1  

             The 4cim - 6io is like this in actual:
             ------------  ------------  ------------  ------------
              IOL  IOB_B   IOL IOB_B                    IOL IOB_B      
              IOL  IOB_A   IOL IOB_A                    IOL IOB_A
             ------------  ------------  ------------  ------------                
              
            ]

  Revision History:

*****************************************************************************************/
function place_io_bab_tff_2cim_h_tile ( unsigned int tx, ty)
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // The wires are spread out in 2 tiles. Pre-calculate the lower-left corner of all 2 tiles
    unsigned int tile_pre_sx = (tx - 1)   * TILE_NUM_SITE_X;
    unsigned int tile_0_sx   =  tx        * TILE_NUM_SITE_X;
    unsigned int tile_1_sx   = (tx + 1)   * TILE_NUM_SITE_X;
    
    //
    // Layout IOL1 in the tile #pre
    //
    // Allocate the wires driven by IOL1
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", tile_pre_sx+1, sy+2);
    &wire ntRef_ntIOL1_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", tile_pre_sx+1, sy+2);
    &wire ntRef_ntIOL1_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", tile_pre_sx+1, sy+2);
    &wire ntRef_ntIOL1_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", tile_pre_sx+1, sy+2);
    &wire ntRef_ntIOL1_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", tile_pre_sx+1, sy+2);
    &wire ntRef_ntIOL1_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", tile_pre_sx+1, sy+2);
    &wire ntRef_ntIOL1_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;    
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", tile_pre_sx+1, sy+2);                             
    &wire ntRef_ntIOL1_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", tile_pre_sx+1, sy+2);                             
    &wire ntRef_ntIOL1_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
        
    //
    // Layout IOB1(IOB_B) in the tile #pre
    //
    // Allocate the wires driven by IOB1 
    //
    sprintf(strVar, "ntDIN_%d_%d", tile_pre_sx+2, sy+2);
    &wire ntRef_ntIOB1_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", tile_pre_sx+2, sy+2);
    &wire ntRef_ntIOB1_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX1 in the tile #pre
    //
    // Allocate the wires driven by IOMUX1 
    //
    sprintf(strVar, "ntOUT_%d_%d", tile_pre_sx+3, sy+1);
    &wire ntRef_ntIOMUX1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX1 @[3,1] in tile #pre. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", tile_pre_sx+3, sy+1);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX1_OUT
                 )
        @[tile_pre_sx+3,sy+1];
    
    //
    // Layout IOL2 in the tile #1
    //
    // Allocate the wires driven by IOL2
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL2_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL2_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL2_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    sprintf(strVar, "ntRX_DATA_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL2_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL2_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL2_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", tile_1_sx+1, sy+1);                             
    &wire ntRef_ntIOL2_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", tile_1_sx+1, sy+1);                             
    &wire ntRef_ntIOL2_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 
    
    sprintf(strVar, "ntDO_OUT_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL2_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntIOL2_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 
    
    //
    // Layout IOB2(IOB_A) in the tile #1
    //
    // Allocate the wires driven by IOB2 
    //
    sprintf(strVar, "ntDIN_%d_%d", tile_1_sx+2, sy+1);
    &wire ntRef_ntIOB2_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", tile_1_sx+2, sy+1);
    &wire ntRef_ntIOB2_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX2 in the tile #1
    //
    // Allocate the wires driven by IOMUX2 
    //
    sprintf(strVar, "ntOUT_%d_%d", tile_1_sx+3, sy);
    &wire ntRef_ntIOMUX2_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX2 @[3,0] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", tile_1_sx+3, sy);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX2_OUT
                 )
        @[tile_1_sx+3,sy];
        
    //
    // Instantiate the IOL1 @[1,2] in tile #pre. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", tile_pre_sx+1, sy+2);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL1_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL1_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL1_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL1_RX_DATA         ,
                   DO              => ntRef_ntIOL1_DO              ,
                   TO              => ntRef_ntIOL1_TO              ,
                   ODDR_COUT       => ntRef_ntIOL1_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL1_IDDR_COUT       ,
                   
                 
                   TX_DATA[0]       => <wire A_IA0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,      // IOL1 <- SIB
                   TX_DATA[1]       => <wire A_IA1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[2]       => <wire A_IA2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[3]       => <wire A_IA3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[4]       => <wire A_IA4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[5]       => <wire A_IB0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[0]       => <wire A_IB1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[1]       => <wire A_IB2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[2]       => <wire A_IB3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[3]       => <wire A_IB4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_STS_CLR      => <wire A_IC0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[0]    => <wire A_IC1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[1]    => <wire A_IC2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[2]    => <wire A_IC3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_CTRL[0]      => <wire A_IC4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_CTRL[1]      => <wire A_ID0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   SLIP             => <wire A_ID1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   SYSCLK           => <wire A_ICLK of <device CIM @[tile_0_sx+3, sy+2]>>   ,
                   CE               => <wire A_ICE of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   LRS              => <wire A_IRS of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   
                   DIN              => ntRef_ntIOB1_DIN                                     , // IOL1 <- IOB1
                   IOCLK            => ntRef_ntIOMUX1_OUT                                     // IOL1 <- IOMUX1
                 )
        @[tile_pre_sx+1,sy+2];
        
    // Hook up the outputs of IOL1 -> SRB (TILE 0)
    connect
        (           
            <pin A_IY0   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_IODLY_OV      , 
            <pin A_IY1   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA_DD      ,
            <pin A_IY2   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[0]   ,
            <pin A_IY3   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[1]   ,
            <pin A_IQ0   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[2]   ,
            <pin A_IQ1   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[3]   ,
            <pin A_IQ2   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[4]   ,
            <pin A_IQ3   of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[5]   ,
            <pin A_IY6AB of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_DPI_STS[0]    ,
            <pin A_IY6CD of <device CIM @[tile_0_sx+3,sy+2]>> => ntRef_ntIOL1_DPI_STS[1]
        );
        
    //
    // Instantiate the IOB1 @[2,2] in tile #pre. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_B_%d_%d", tile_pre_sx+2, sy+2);
    device IOB_B *strVar
        port map (
                   DO         => ntRef_ntIOL1_DO     , //Input from IOL1 (Tile 0)
                   TO         => ntRef_ntIOL1_TO      ,
                   
                   DIN        => ntRef_ntIOB1_DIN      ,   //output
                   DIFFI_OUT     => ntRef_ntIOB1_DIFFI_OUT  
                 )
        @[tile_pre_sx+2,sy+2];
        

    //
    // Instantiate the IOL2 @[1,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", tile_1_sx+1, sy+1);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL2_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL2_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL2_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL2_RX_DATA         ,
                   DO              => ntRef_ntIOL2_DO              ,
                   TO              => ntRef_ntIOL2_TO              ,
                   ODDR_COUT       => ntRef_ntIOL2_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL2_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL2_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL2_TO_OUT          ,

                   TX_DATA[0]        => <wire S_IA0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,   // IOL2 <- SIB
                   TX_DATA[1]        => <wire S_IA1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[2]        => <wire S_IA2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[3]        => <wire S_IA3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[4]        => <wire S_IA4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TX_DATA[5]        => <wire S_IB0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[0]        => <wire S_IB1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[1]        => <wire S_IB2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[2]        => <wire S_IB3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   TS_CTRL[3]        => <wire S_IB4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_STS_CLR       => <wire S_IC0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[0]     => <wire S_IC1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[1]     => <wire S_IC2 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   IODLY_CTRL[2]     => <wire S_IC3 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_CTRL[0]       => <wire S_IC4 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   DPI_CTRL[1]       => <wire S_ID0 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   SLIP              => <wire S_ID1 of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   SYSCLK            => <wire S_ICLK of <device CIM @[tile_0_sx+3, sy+2]>>   ,
                   CE                => <wire S_ICE of <device CIM @[tile_0_sx+3, sy+2]>>    ,
                   LRS               => <wire S_IRS of <device CIM @[tile_0_sx+3, sy+2]>>    ,

                   DIN               => ntRef_ntIOB2_DIN                                     , // IOL2 <- IOB2
                   IOCLK             => ntRef_ntIOMUX2_OUT                                     // IOL2 <- IOMUX2
                 )
        @[tile_1_sx+1,sy+1];
        
    // Hook up the outputs of SRB <- IOL2
    connect
        (          
            <pin S_IY0 of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_IODLY_OV       ,
            <pin S_IY1 of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA_DD       ,
            <pin S_IY2 of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[0]    ,
            <pin S_IY3 of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[1]    ,
            <pin S_IQ0 of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[2]    ,
            <pin S_IQ1 of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[3]    ,
            <pin S_IQ2 of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[4]    ,
            <pin S_IQ3 of <device CIM @[tile_0_sx+3,sy+2]>>   => ntRef_ntIOL2_RX_DATA[5]    ,
            <pin A_IY6AB of <device CIM @[tile_1_sx+3,sy+2]>> => ntRef_ntIOL2_DPI_STS[0]     ,
            <pin A_IY6CD of <device CIM @[tile_1_sx+3,sy+2]>> => ntRef_ntIOL2_DPI_STS[1]
        );  
        
    //
    // Instantiate the IOB2 @[2,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LA_%d_%d", tile_1_sx+2, sy+1);
    device IOB_LA *strVar
        port map (
                   DO          => ntRef_ntIOL2_DO        ,  //Input from IOL2 (Tile 1)
                   TO          => ntRef_ntIOL2_TO        ,
                   
                   DIN         => ntRef_ntIOB2_DIN       ,  //output
                   DIFFI_OUT   => ntRef_ntIOB2_DIFFI_OUT 
                 )
        @[tile_1_sx+2,sy+1];
        
    //
    // Layout IOL3 in the tile #1
    //
    // Allocate the wires driven by IOL3
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", tile_1_sx+1, sy+2);
    &wire ntRef_ntIOL3_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", tile_1_sx+1, sy+2);
    &wire ntRef_ntIOL3_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", tile_1_sx+1, sy+2);
    &wire ntRef_ntIOL3_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    sprintf(strVar, "ntRX_DATA_%d_%d", tile_1_sx+1, sy+2);
    &wire ntRef_ntIOL3_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", tile_1_sx+1, sy+2);
    &wire ntRef_ntIOL3_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", tile_1_sx+1, sy+2);
    &wire ntRef_ntIOL3_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", tile_1_sx+1, sy+2);                             
    &wire ntRef_ntIOL3_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", tile_1_sx+1, sy+2);                             
    &wire ntRef_ntIOL3_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 

    //
    // Layout IOB3 in the tile #1
    //
    // Allocate the wires driven by IOB3
    //
    sprintf(strVar, "ntDIN_%d_%d", tile_1_sx+2, sy+2);
    &wire ntRef_ntIOB3_DIN = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", tile_1_sx+2, sy+2);
    &wire ntRef_ntIOB3_DIFFI_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX3 in the tile #1
    //
    // Allocate the wires driven by IOMUX3
    //
    sprintf(strVar, "ntOUT_%d_%d", tile_1_sx+3, sy+1);
    &wire ntRef_ntIOMUX3_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX3 @[3,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", tile_1_sx+3, sy+1);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX3_OUT
                 )
        @[tile_1_sx+3,sy+1];
       
    //
    // Instantiate the IOL3 @[1,2] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", tile_1_sx+1, sy+2);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL3_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL3_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL3_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL3_RX_DATA         ,
                   DO              => ntRef_ntIOL3_DO              ,
                   TO              => ntRef_ntIOL3_TO              ,
                   ODDR_COUT       => ntRef_ntIOL3_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL3_IDDR_COUT       ,
                  
                   TX_DATA[0]      => <wire A_IA0 of <device CIM @[tile_1_sx+3, sy+2]>>    ,      //IOL3 <- CIM (tile 1)
                   TX_DATA[1]      => <wire A_IA1 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TX_DATA[2]      => <wire A_IA2 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TX_DATA[3]      => <wire A_IA3 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TX_DATA[4]      => <wire A_IA4 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TX_DATA[5]      => <wire A_IB0 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TS_CTRL[0]      => <wire A_IB1 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TS_CTRL[1]      => <wire A_IB2 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TS_CTRL[2]      => <wire A_IB3 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   TS_CTRL[3]      => <wire A_IB4 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   DPI_STS_CLR     => <wire A_IC0 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   IODLY_CTRL[0]   => <wire A_IC1 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   IODLY_CTRL[1]   => <wire A_IC2 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   IODLY_CTRL[2]   => <wire A_IC3 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   DPI_CTRL[0]     => <wire A_IC4 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   DPI_CTRL[1]     => <wire A_ID0 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   SLIP            => <wire A_ID1 of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   SYSCLK          => <wire A_ICLK of <device CIM @[tile_1_sx+3, sy+2]>>   ,
                   CE              => <wire A_ICE of <device CIM @[tile_1_sx+3, sy+2]>>    ,
                   LRS             => <wire A_IRS of <device CIM @[tile_1_sx+3, sy+2]>>    ,

                   DIN             => ntRef_ntIOB3_DIN                                     , //IOL3 <- IOB3 (Tile 1) 
                   IOCLK           => ntRef_ntIOMUX3_OUT                                     // IOL3 <- IOMUX3

                 )
        @[tile_1_sx+1,sy+2];

    // Hook up the outputs of IOL3 -> CIM (TILE 1)
    connect
        (            
            <pin A_IY0   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_IODLY_OV       , 
            <pin A_IY1   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA_DD       ,
            <pin A_IY2   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[0]    ,
            <pin A_IY3   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[1]    ,
            <pin A_IQ0   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[2]    ,
            <pin A_IQ1   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[3]    ,
            <pin A_IQ2   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[4]    ,
            <pin A_IQ3   of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_RX_DATA[5]    ,
            <pin S_IY6AB of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_DPI_STS[0]     ,
            <pin S_IY6CD of <device CIM @[tile_1_sx+3,sy+2]>>   => ntRef_ntIOL3_DPI_STS[1]
        );

    //
    // Instantiate the IOB3 @[2,2] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LB_%d_%d", tile_1_sx+2, sy+2);
    device IOB_LB *strVar
        port map (
                   DO           => ntRef_ntIOL3_DO        ,   //Input from IOL3 (Tile 1)
                   TO           => ntRef_ntIOL3_TO        ,
                   
                   DIN          => ntRef_ntIOB3_DIN       ,   //output
                   DIFFI_OUT    => ntRef_ntIOB3_DIFFI_OUT
                 )
        @[tile_1_sx+2,sy+2];

};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-2CIM block tiles in horizontal direction. 
             Each IO block takes the size of 2 tiles. 
             
             ---------|---------|---------|---------  ---------|---------|----------|---------    ---------|---------|---------|---------  
                        IOL1[1,2] IOB1[2,2]  C[3,2]                       IOMUX5[2,2] C[3,2]                IOL3[1,2]  IOB3[2,2]  C[3,2]
                V[0,1]                      IOMUX1[3,1] V[0,1]            IOMUX4[2,1] DQSMUX[3,1]   V[0,1]  IOL2[1,1]  IOB2[2,1]  IOMUX3[3,1]
                G[0,0]  R[1,0]    I[2,0]                G[0,0]  R[1,0]    I[2,0]      DQS[3,0]      G[0,0]  R[1,0]     I[2,0]     IOMUX2[3,0]
             ---------|---------|---------|---------  ---------|---------|----------|---------    ---------|---------|---------|---------   
               
                             TILE PRE                                  TILE 0                                    TILE 1                     
              
            ]

  Revision History:

*****************************************************************************************/
function place_io_dqs_2cim_h_tile ( unsigned int tx, ty, shift)
{
    string strVar;
    
    // Layout devices in 2 tiles. 
    place_io_bab_ftt_2cim_h_tile (tx, ty);
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // The wires are spread out in 2 tiles. Pre-calculate the lower-left corner of all 2 tiles
    unsigned int tile_0_sx =  tx              * TILE_NUM_SITE_X;
    unsigned int tile_1_sx = (tx + 1)         * TILE_NUM_SITE_X;
    unsigned int tile_3_sx = (tx - 1) * TILE_NUM_SITE_X;
    
    //
    // Layout IOMUX4 in the tile #0
    //
    // Allocate the wires driven by IOMUX4
    //
    sprintf(strVar, "ntOUT_%d_%d", tile_0_sx+2, sy+1);
    &wire ntRef_ntIOMUX4_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX4 @[2,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", tile_0_sx+2, sy+1);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX4_OUT
                 )
        @[tile_0_sx+2,sy+1];
        
    //
    // Layout IOMUX5 in the tile #0
    //
    // Allocate the wires driven by IOMUX5
    //
    sprintf(strVar, "ntOUT_%d_%d", tile_0_sx+2, sy+2);
    &wire ntRef_ntIOMUX5_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX5 @[2,2] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", tile_0_sx+2, sy+2);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX5_OUT
                 )
        @[tile_0_sx+2,sy+2];
        
    
    //
    // Layout DQS in the tile #0
    //
    // Allocate the wires driven by DQS
    //
    sprintf(strVar, "ntDQS_GATE_TRAINING_STATUS_%d_%d", tile_0_sx+3, sy);
    &wire ntRef_ntDQS_GATE_TRAINING_STATUS = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRDEL_OV_%d_%d", tile_0_sx+3, sy);
    &wire ntRef_ntRDEL_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntWL_OV_%d_%d", tile_0_sx+3, sy);
    &wire ntRef_ntWL_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntREAD_VALID_%d_%d", tile_0_sx+3, sy);
    &wire ntRef_ntREAD_VALID = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntSAMPLE_CLK_DIV_%d_%d", tile_0_sx+3, sy);
    &wire ntRef_ntSAMPLE_CLK_DIV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDQSI_DEL_%d_%d", tile_0_sx+3, sy);
    &wire ntRef_ntDQSI_DEL = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntSAMPLE_CLK_%d_%d", tile_0_sx+3, sy);
    &wire ntRef_ntSAMPLE_CLK = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntPROBE_CLK_%d_%d", tile_0_sx+3, sy);
    &wire ntRef_ntPROBE_CLK = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntWCLK_%d_%d", tile_0_sx+3, sy);
    &wire ntRef_ntWCLK = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntWCLK_DEL_%d_%d", tile_0_sx+3, sy);
    &wire ntRef_ntWCLK_DEL = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntIFIFO_WADDR_%d_%d", tile_0_sx+3, sy);
    &wire ntRef_ntIFIFO_WADDR[2:0] = wire *strVar[2:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntIFIFO_RADDR_%d_%d", tile_0_sx+3, sy);
    &wire ntRef_ntIFIFO_RADDR[2:0] = wire *strVar[2:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout DQSMUX in the tile #0
    //
    // Allocate the wires driven by DQSMUX
    //
    sprintf(strVar, "ntDQS_MUX_DLL_CODE_%d_%d", tile_0_sx+3, sy+1);
    &wire ntRef_ntDQS_MUX_DLL_CODE[7:0] = wire *strVar[7:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the DQS_MUX @[3,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "DQS_MUX_%d_%d", tile_0_sx+3, sy+1);
    device DQS_MUX *strVar 
        port map (
                     DLL_CODE => ntRef_ntDQS_MUX_DLL_CODE
                 )
        @[tile_0_sx+3,sy+1];

    //
    // Instantiate the DQS @[3,0] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "DQS_%d_%d", tile_0_sx+3, sy);
    device DQS *strVar 
        port map (
                     DQS_GATE_TRAINING_STATUS => ntRef_ntDQS_GATE_TRAINING_STATUS  ,
                     RDEL_OV                  => ntRef_ntRDEL_OV             ,
                     WL_OV                    => ntRef_ntWL_OV               ,
                     READ_VALID               => ntRef_ntREAD_VALID          ,
                     SAMPLE_CLK_DIV           => ntRef_ntSAMPLE_CLK_DIV      ,
                     DQSI_DEL                 => ntRef_ntDQSI_DEL            ,
                     SAMPLE_CLK               => ntRef_ntSAMPLE_CLK          ,
                     PROBE_CLK                => ntRef_ntPROBE_CLK           ,
                     WCLK                     => ntRef_ntWCLK                ,
                     WCLK_DEL                 => ntRef_ntWCLK_DEL            ,
                     IFIFO_WADDR              => ntRef_ntIFIFO_WADDR         ,
                     IFIFO_RADDR              => ntRef_ntIFIFO_RADDR         ,
                     
                     RDEL_CTRL[0]         => <wire S_IA0 of <device CIM  @[tile_1_sx+3, sy+2]>>     ,
                     RDEL_CTRL[1]         => <wire S_IA1 of <device CIM  @[tile_1_sx+3, sy+2]>>     ,
                     RDEL_CTRL[2]         => <wire S_IA2 of <device CIM  @[tile_1_sx+3, sy+2]>>     ,
                     DQS_GATE_CTRL[0]     => <wire S_IA3 of <device CIM  @[tile_1_sx+3, sy+2]>>     ,
                     DQS_GATE_CTRL[1]     => <wire S_IA4 of <device CIM  @[tile_1_sx+3, sy+2]>>     ,
                     DQS_GATE_CTRL[2]     => <wire S_IB0 of <device CIM  @[tile_1_sx+3, sy+2]>>     ,
                     DQS_GATE_CTRL[3]     => <wire S_IB1 of <device CIM  @[tile_1_sx+3, sy+2]>>     ,
                     READ_CLK_CTRL[0]     => <wire S_IB2 of <device CIM  @[tile_1_sx+3, sy+2]>>     ,
                     READ_CLK_CTRL[1]     => <wire S_IB3 of <device CIM  @[tile_1_sx+3, sy+2]>>     ,
                     READ_CLK_CTRL[2]     => <wire S_IB4 of <device CIM  @[tile_1_sx+3, sy+2]>>     ,
                     CLK1_STEP[0]         => <wire S_IC0 of <device CIM  @[tile_1_sx+3, sy+2]>>     ,
                     CLK1_STEP[1]         => <wire S_IC1 of <device CIM  @[tile_1_sx+3, sy+2]>>     ,
                     CLK1_STEP[2]         => <wire S_IC2 of <device CIM  @[tile_1_sx+3, sy+2]>>     ,
                     CLK1_STEP[3]         => <wire S_IC3 of <device CIM  @[tile_1_sx+3, sy+2]>>     ,
                     CLK1_STEP[4]         => <wire S_IC4 of <device CIM  @[tile_1_sx+3, sy+2]>>     ,
                     CLK1_STEP[5]         => <wire S_ID0 of <device CIM  @[tile_1_sx+3, sy+2]>>     ,
                     CLK1_STEP[6]         => <wire S_ID1 of <device CIM  @[tile_1_sx+3, sy+2]>>     ,
                     CLK1_STEP[7]         => <wire S_ID2 of <device CIM  @[tile_1_sx+3, sy+2]>>     ,
                     CLKGATE              => <wire S_ID3 of <device CIM  @[tile_1_sx+3, sy+2]>>     ,
                     SYSCLK               => <wire S_ICLK of <device CIM @[tile_1_sx+3, sy+2]>>     ,
                     RST                  => <wire S_IRS  of <device CIM @[tile_1_sx+3, sy+2]>>     ,
                                                                                                    
                     WL_CTRL[0]           => <wire S_IA0 of <device CIM @[tile_3_sx+3, sy+2]>>     ,
                     WL_CTRL[1]           => <wire S_IA1 of <device CIM @[tile_3_sx+3, sy+2]>>     ,
                     WL_CTRL[2]           => <wire S_IA2 of <device CIM @[tile_3_sx+3, sy+2]>>     ,
                     DCC_CLK_CTRL[0]      => <wire S_IA3 of <device CIM @[tile_3_sx+3, sy+2]>>     ,
                     DCC_CLK_CTRL[1]      => <wire S_IA4 of <device CIM @[tile_3_sx+3, sy+2]>>     ,
                     DCC_CLK_CTRL[2]      => <wire S_IB0 of <device CIM @[tile_3_sx+3, sy+2]>>     ,
                     IOCLK_SEL[0]         => <wire S_IB1 of <device CIM @[tile_3_sx+3, sy+2]>>     ,
                     IOCLK_SEL[1]         => <wire S_IB2 of <device CIM @[tile_3_sx+3, sy+2]>>     ,
                     IOCLK_SEL[2]         => <wire S_IB3 of <device CIM @[tile_3_sx+3, sy+2]>>     ,
                     IOCLK_SEL[3]         => <wire S_IB4 of <device CIM @[tile_3_sx+3, sy+2]>>     ,
                     WL_STEP[0]           => <wire S_IC0 of <device CIM @[tile_3_sx+3, sy+2]>>     ,
                     WL_STEP[1]           => <wire S_IC1 of <device CIM @[tile_3_sx+3, sy+2]>>     ,
                     WL_STEP[2]           => <wire S_IC2 of <device CIM @[tile_3_sx+3, sy+2]>>     ,
                     WL_STEP[3]           => <wire S_IC3 of <device CIM @[tile_3_sx+3, sy+2]>>     ,
                     WL_STEP[4]           => <wire S_IC4 of <device CIM @[tile_3_sx+3, sy+2]>>     ,
                     WL_STEP[5]           => <wire S_ID0 of <device CIM @[tile_3_sx+3, sy+2]>>     ,
                     WL_STEP[6]           => <wire S_ID1 of <device CIM @[tile_3_sx+3, sy+2]>>     ,
                     WL_STEP[7]           => <wire S_ID2 of <device CIM @[tile_3_sx+3, sy+2]>>     ,
                     SAMPLE_CLK_SLIP      => <wire S_ID3 of <device CIM @[tile_3_sx+3, sy+2]>>     ,
                     
                     DLL_CODE             => ntRef_ntDQS_MUX_DLL_CODE                              ,
                     IOCLK[0]             => ntRef_ntIOMUX4_OUT                                    ,
                     IOCLK[1]             => ntRef_ntIOMUX5_OUT
                 )
        @[tile_0_sx+3,sy];
        
    // Hook up the outputs of DQS (TILE 1) -> CIM (TILE 1)
    connect
        (                     
            <pin S_IY0 of <device CIM @[tile_1_sx+3,sy+2]>> => ntRef_ntDQS_GATE_TRAINING_STATUS   , 
            <pin S_IY1 of <device CIM @[tile_1_sx+3,sy+2]>> => ntRef_ntREAD_VALID                 ,  
            <pin S_IY2 of <device CIM @[tile_1_sx+3,sy+2]>> => ntRef_ntRDEL_OV                    ,
            <pin S_IY3 of <device CIM @[tile_1_sx+3,sy+2]>> => ntRef_ntWL_OV                     
        ); 
        
};


/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-4CIM block tiles in horizontal direction. 
             
  ---------|---------|---------|---------  --------|----------|----------|---------  ---------|---------|---------|---------  ---------|---------|---------|---------  
              IOL1[1,2] IOB1[2,2]                    IOL3[1,2] IOB3[2,2]                                                                IOL5[1,2] IOB5[2,2]  
     V[0,1]   IOL2[1,1] IOB2[2,1]            V[0,1]  IOL4[1,1] IOB4[2,1]               V[0,1]                                   V[0,1]  IOL6[1,1] IOB6[2,1]  
     G[0,0]   R[1,0]    I[2,0]               G[0,0]  R[1,0]    I[2,0]                  G[0,0]  R[1,0]    I[2,0]                 G[0,0]  R[1,0]    I[2,0]
  ---------|---------|---------|---------  --------|----------|---------|---------   ---------|---------|---------|---------  ---------|---------|---------|---------   

                  TILE 0                                     TILE 1                               TILE 2                    
              
            ]

  Revision History:

*****************************************************************************************/
function place_io_4cim_6io_ttfftt_h_tile ( unsigned int tx, ty)
{
    place_io_aba_ttf_2cim_h_tile(tx,   ty);
    place_io_bab_ftt_2cim_h_tile(tx+2, ty);
    
    const unsigned int r_tile_x0[] = { tx, tx+3 };
    
    unsigned int tile_x;
    
    foreach tile_x ( r_tile_x0 )
    {
        connect
            (
                <pin DIFFI_IN of <device IOB_A @([tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1])>>   => <wire DIFFI_OUT of <device IOB_B @[tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2]>>   ,
                <pin DIFFO_IN of <device IOB_B @([tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2])>>   => <wire DIFFO_OUT of <device IOB_A @[tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1]>>   ,
                <pin DIFFI_IN of <device IOB_B @([tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2])>>   => <wire DIFFI_OUT of <device IOB_A @[tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1]>>   ,
                                
                <pin ODDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>  => <wire ODDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2]>>   ,
                <pin IDDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>  => <wire IDDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2]>>   ,
                
                <pin ODDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire ODDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>   ,
                <pin IDDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire IDDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>   ,
                
                <pin DO_IN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire DO_OUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>   ,
                <pin TO_IN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire TO_OUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>
        
            );
    }

    const unsigned int r_tile_x1[] = { tx+1 };
    
    foreach tile_x ( r_tile_x1 )
    {
        connect
            (
                <pin DIFFI_IN of <device IOB_LA @([tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1])>>   => <wire DIFFI_OUT of <device IOB_LB @[tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2]>>   ,
                <pin DIFFI_IN of <device IOB_LB @([tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2])>>   => <wire DIFFI_OUT of <device IOB_LA @[tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1]>>   ,
                                
                <pin ODDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>  => <wire ODDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2]>>   ,
                <pin IDDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>  => <wire IDDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2]>>   ,
                
                <pin ODDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire ODDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>   ,
                <pin IDDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire IDDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>   ,
                
                <pin DO_IN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire DO_OUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>   ,
                <pin TO_IN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire TO_OUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>
            );
    }
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-4CIM block tiles in horizontal direction. 
             
  ---------|---------|---------|---------  --------|----------|----------|---------  ---------|---------|---------|---------  ---------|---------|---------|---------  
              IOL1[1,2] IOB1[2,2]                    IOL3[1,2] IOB3[2,2]                                                                IOL5[1,2] IOB5[2,2]  
     V[0,1]   IOL2[1,1] IOB2[2,1]            V[0,1]  IOL4[1,1] IOB4[2,1]               V[0,1]                                   V[0,1]  IOL6[1,1] IOB6[2,1]  
     G[0,0]   R[1,0]    I[2,0]               G[0,0]  R[1,0]    I[2,0]                  G[0,0]  R[1,0]    I[2,0]                 G[0,0]  R[1,0]    I[2,0]
  ---------|---------|---------|---------  --------|----------|---------|---------   ---------|---------|---------|---------  ---------|---------|---------|---------   

                  TILE 0                                     TILE 1                               TILE 2                    
              
            ]

  Revision History:

*****************************************************************************************/
function place_io_4cim_6io_ffttff_h_tile ( unsigned int tx, ty)
{
    place_io_aba_fft_2cim_h_tile(tx,   ty);
    place_io_bab_tff_2cim_h_tile(tx+2, ty);
    
    const unsigned int r_tile_x0[] = { tx, tx+3 };
    
    unsigned int tile_x;
    
    foreach tile_x ( r_tile_x0 )
    {
        connect
            (
                <pin DIFFI_IN of <device IOB_LA @([tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1])>>   => <wire DIFFI_OUT of <device IOB_LB @[tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2]>>   ,
                <pin DIFFI_IN of <device IOB_LB @([tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2])>>   => <wire DIFFI_OUT of <device IOB_LA @[tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1]>>   ,
                                
                <pin ODDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>  => <wire ODDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2]>>   ,
                <pin IDDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>  => <wire IDDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2]>>   ,
                
                <pin ODDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire ODDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>   ,
                <pin IDDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire IDDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>   ,
                
                <pin DO_IN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire DO_OUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>   ,
                <pin TO_IN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire TO_OUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>
        
            );
    }

    const unsigned int r_tile_x1[] = { tx+1 };
    
    foreach tile_x ( r_tile_x1 )
    {
        connect
            (
                <pin DIFFI_IN of <device IOB_A @([tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1])>>   => <wire DIFFI_OUT of <device IOB_B @[tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2]>>   ,
                <pin DIFFO_IN of <device IOB_B @([tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2])>>   => <wire DIFFO_OUT of <device IOB_A @[tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1]>>   ,
                <pin DIFFI_IN of <device IOB_B @([tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2])>>   => <wire DIFFI_OUT of <device IOB_A @[tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1]>>   ,
                                
                <pin ODDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>  => <wire ODDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2]>>   ,
                <pin IDDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>  => <wire IDDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2]>>   ,
                
                <pin ODDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire ODDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>   ,
                <pin IDDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire IDDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>   ,
                
                <pin DO_IN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire DO_OUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>   ,
                <pin TO_IN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire TO_OUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>
            );
    }
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-4CIM block tiles in horizontal direction. 
             
  ---------|---------|---------|---------  --------|----------|----------|---------  ---------|---------|---------|---------  ---------|---------|---------|---------  
              IOL1[1,2] IOB1[2,2]                    IOL3[1,2] IOB3[2,2]                                                                IOL5[1,2] IOB5[2,2]  
     V[0,1]   IOL2[1,1] IOB2[2,1]            V[0,1]  IOL4[1,1] IOB4[2,1]               V[0,1]                                   V[0,1]  IOL6[1,1] IOB6[2,1]  
     G[0,0]   R[1,0]    I[2,0]               G[0,0]  R[1,0]    I[2,0]                  G[0,0]  R[1,0]    I[2,0]    DQS[3,0]     G[0,0]  R[1,0]    I[2,0]     
  ---------|---------|---------|---------  --------|----------|---------|---------   ---------|---------|---------|---------  ---------|---------|---------|---------   

                  TILE 0                                     TILE 1                               TILE 2                    
              
            ]

  Revision History:

*****************************************************************************************/
function place_io_4cim_6io_dqs_h_tile ( unsigned int tx, ty, shift)
{
    place_io_aba_ttf_2cim_h_tile(tx,   ty);
    place_io_dqs_2cim_h_tile(tx+2, ty, shift);
    
    const unsigned int r_tile_x0[] = { tx, tx+3 };
    
    unsigned int tile_x;
    
    foreach tile_x ( r_tile_x0 )
    {
        connect
            (
                <pin DIFFI_IN of <device IOB_A @([tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1])>>   => <wire DIFFI_OUT of <device IOB_B @[tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2]>>   ,
                <pin DIFFO_IN of <device IOB_B @([tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2])>>   => <wire DIFFO_OUT of <device IOB_A @[tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1]>>   ,
                <pin DIFFI_IN of <device IOB_B @([tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2])>>   => <wire DIFFI_OUT of <device IOB_A @[tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1]>>   ,
                                
                <pin ODDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>  => <wire ODDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2]>>   ,
                <pin IDDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>  => <wire IDDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2]>>   ,
                
                <pin ODDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire ODDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>   ,
                <pin IDDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire IDDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>   ,
                
                <pin DO_IN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire DO_OUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>   ,
                <pin TO_IN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire TO_OUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>
        
            );
    }
    
    const unsigned int r_tile_x1[] = { tx+1 };
    
    foreach tile_x ( r_tile_x1 )
    {
        connect
            (
                <pin DIFFI_IN of <device IOB_LA @([tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1])>>   => <wire DIFFI_OUT of <device IOB_LB @[tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2]>>   ,
                <pin DIFFI_IN of <device IOB_LB @([tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2])>>   => <wire DIFFI_OUT of <device IOB_LA @[tile_x*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1]>>   ,
                                
                <pin ODDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>  => <wire ODDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2]>>   ,
                <pin IDDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>  => <wire IDDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2]>>   ,
                
                <pin ODDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire ODDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>   ,
                <pin IDDR_CIN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire IDDR_COUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>   ,
                
                <pin DO_IN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire DO_OUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>   ,
                <pin TO_IN of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire TO_OUT of <device IOL @[tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>
            );
    }
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-8CIM block tiles in horizontal direction. 
             Each IO block takes the size of 8 tiles. 

            ]

  Revision History:

*****************************************************************************************/
function place_io_8cim_h_tile ( unsigned int tx, ty, shift )
{
    place_io_4cim_6io_ffttff_h_tile(tx, ty);
    place_io_4cim_6io_dqs_h_tile(tx+4, ty, shift);
    
    const unsigned int l_tile_x[] = { tx, tx+1, tx+3, tx+4, tx+5, tx+7 };
    unsigned int tile_x;

    foreach tile_x ( l_tile_x )
    {       
        connect
        (
            <pin SAMPLE_CLK  of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>  => <wire SAMPLE_CLK  of <device DQS @[(tx+6)*TILE_NUM_SITE_X+3, ty*TILE_NUM_SITE_Y]>>,
            <pin PROBE_CLK   of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>  => <wire PROBE_CLK   of <device DQS @[(tx+6)*TILE_NUM_SITE_X+3, ty*TILE_NUM_SITE_Y]>>,
            <pin WCLK        of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>  => <wire WCLK        of <device DQS @[(tx+6)*TILE_NUM_SITE_X+3, ty*TILE_NUM_SITE_Y]>>,
            <pin WCLK_DEL    of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>  => <wire WCLK_DEL    of <device DQS @[(tx+6)*TILE_NUM_SITE_X+3, ty*TILE_NUM_SITE_Y]>>,
            <pin IFIFO_WADDR of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>  => <wire IFIFO_WADDR of <device DQS @[(tx+6)*TILE_NUM_SITE_X+3, ty*TILE_NUM_SITE_Y]>>,
            <pin IFIFO_RADDR of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>  => <wire IFIFO_RADDR of <device DQS @[(tx+6)*TILE_NUM_SITE_X+3, ty*TILE_NUM_SITE_Y]>>,
            <pin DQSI_DEL    of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>  => <wire DQSI_DEL    of <device DQS @[(tx+6)*TILE_NUM_SITE_X+3, ty*TILE_NUM_SITE_Y]>>,
                        
            <pin SAMPLE_CLK  of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire SAMPLE_CLK  of <device DQS @[(tx+6)*TILE_NUM_SITE_X+3, ty*TILE_NUM_SITE_Y]>>,
            <pin PROBE_CLK   of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire PROBE_CLK   of <device DQS @[(tx+6)*TILE_NUM_SITE_X+3, ty*TILE_NUM_SITE_Y]>>,
            <pin WCLK        of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire WCLK        of <device DQS @[(tx+6)*TILE_NUM_SITE_X+3, ty*TILE_NUM_SITE_Y]>>,
            <pin WCLK_DEL    of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire WCLK_DEL    of <device DQS @[(tx+6)*TILE_NUM_SITE_X+3, ty*TILE_NUM_SITE_Y]>>,
            <pin IFIFO_WADDR of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire IFIFO_WADDR of <device DQS @[(tx+6)*TILE_NUM_SITE_X+3, ty*TILE_NUM_SITE_Y]>>,
            <pin IFIFO_RADDR of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire IFIFO_RADDR of <device DQS @[(tx+6)*TILE_NUM_SITE_X+3, ty*TILE_NUM_SITE_Y]>>,
            <pin DQSI_DEL    of <device IOL @([tile_x*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>  => <wire DQSI_DEL    of <device DQS @[(tx+6)*TILE_NUM_SITE_X+3, ty*TILE_NUM_SITE_Y]>>
        );
    }
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO_L-2CIM block tiles in vertical direction. 
             Each IO block takes the size of 2 tiles. (EAST EDGE)
             
             ----------|----------|----------|----------    
                         IOL2[1,2]  IOB2[2,2]  C[3,2]
               V[0,1]    IOL1[1,1]  IOB1[2,1]  IOMUX2[3,1]    
               G[0,0]    R[1,0]     I[2,0]     IOMUX1[3,0]            TILE 0   
             ----------|----------|----------|----------      
                                               C[3,2]
               V[0,1]    IOL3[1,1]  IOB3[2,1]
               G[0,0]    R[1,0]     I[2,0]     IOMUX3[3,0]            TILE 1 
             ----------|----------|----------|----------

            ]

  Revision History:

*****************************************************************************************/
function place_io_aba_ttf_2cim_v_tile ( unsigned int tx, ty)
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // The wires are spread out in 2 tiles. Pre-calculate the lower-left corner of all 2 tiles
    unsigned int tile_0_sy =  ty              * TILE_NUM_SITE_Y;
    unsigned int tile_1_sy = (ty - 1)         * TILE_NUM_SITE_Y;
    
    //
    // Layout IOL1 in the tile #0
    //
    // Allocate the wires driven by IOL1
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
   
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", sx+1, tile_0_sy+1);                             
    &wire ntRef_ntIOL1_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", sx+1, tile_0_sy+1);                             
    &wire ntRef_ntIOL1_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_0_sy+1);                             
    &wire ntRef_ntIOL1_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_0_sy+1);                             
    &wire ntRef_ntIOL1_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;     

    //
    // Layout IOB1 in the tile #0
    //
    // Allocate the wires driven by IOB1 
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_0_sy+1);
    &wire ntRef_ntIOB1_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFO_OUT_%d_%d", sx+2, tile_0_sy+1);
    &wire ntRef_ntIOB1_DIFFO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_0_sy+1);
    &wire ntRef_ntIOB1_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOL2 in the tile #0
    //
    // Allocate the wires driven by IOL2
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", sx+1, tile_0_sy+2);                             
    &wire ntRef_ntIOL2_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", sx+1, tile_0_sy+2);                             
    &wire ntRef_ntIOL2_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_0_sy+2);                             
    &wire ntRef_ntIOL2_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_0_sy+2);                             
    &wire ntRef_ntIOL2_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOB2 in the tile #0
    //
    // Allocate the wires driven by IOB2 
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_0_sy+2);
    &wire ntRef_ntIOB2_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_0_sy+2);
    &wire ntRef_ntIOB2_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX1 in the tile #0
    //
    // Allocate the wires driven by IOMUX1 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+3, tile_0_sy);
    &wire ntRef_ntIOMUX1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX1 @[3,0] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+3, tile_0_sy);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX1_OUT
                 )
        @[sx+3,tile_0_sy];
        
    //
    // Layout IOMUX2 in the tile #0
    //
    // Allocate the wires driven by IOMUX2 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+3, tile_0_sy+1);
    &wire ntRef_ntIOMUX2_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX2 @[3,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+3, tile_0_sy+1);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX2_OUT
                 )
        @[sx+3,tile_0_sy+1];
    
    
    //
    // Instantiate the IOL1 @[1,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", sx+1, tile_0_sy+1);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL1_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL1_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL1_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL1_RX_DATA         ,
                   DO              => ntRef_ntIOL1_DO              ,
                   TO              => ntRef_ntIOL1_TO              ,
                   ODDR_COUT       => ntRef_ntIOL1_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL1_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL1_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL1_TO_OUT          ,
                   
                   TX_DATA[0]       => <wire A_IA0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,      // IOL1 <- SIB
                   TX_DATA[1]       => <wire A_IA1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[2]       => <wire A_IA2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[3]       => <wire A_IA3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[4]       => <wire A_IA4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[5]       => <wire A_IB0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[0]       => <wire A_IB1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[1]       => <wire A_IB2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[2]       => <wire A_IB3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[3]       => <wire A_IB4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_STS_CLR      => <wire A_IC0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[0]    => <wire A_IC1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[1]    => <wire A_IC2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[2]    => <wire A_IC3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[0]      => <wire A_IC4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[1]      => <wire A_ID0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SLIP             => <wire A_ID1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SYSCLK           => <wire A_ICLK of <device CIM @[sx+3, tile_0_sy+2]>>   ,
                   CE               => <wire A_ICE of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   LRS              => <wire A_IRS of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   
                   DIN             => ntRef_ntIOB1_DIN                                      , // IOL1 <- IOB1
                   IOCLK           => ntRef_ntIOMUX1_OUT                                      // IOL1 <- IOMUX1
                 )
        @[sx+1,tile_0_sy+1];
        
    // Hook up the outputs of IOL1 -> SRB (TILE 0)
    connect
        (
            <pin A_IY0   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_IODLY_OV      , 
            <pin A_IY1   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA_DD      ,
            <pin A_IY2   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[0]   ,
            <pin A_IY3   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[1]   ,
            <pin A_IQ0   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[2]   ,
            <pin A_IQ1   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[3]   ,
            <pin A_IQ2   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[4]   ,
            <pin A_IQ3   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[5]   ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_DPI_STS[0]    ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_DPI_STS[1]
        );
        
    //
    // Instantiate the IOB1 @[2,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_A_%d_%d", sx+2, tile_0_sy+1);
    device IOB_A *strVar
        port map (
                   DO          => ntRef_ntIOL1_DO          , //Input from IOL1 (Tile 0)
                   TO          => ntRef_ntIOL1_TO          ,
                   
                   DIN         => ntRef_ntIOB1_DIN         ,   //output
                   DIFFO_OUT   => ntRef_ntIOB1_DIFFO_OUT   ,
                   DIFFI_OUT   => ntRef_ntIOB1_DIFFI_OUT
                 )
        @[sx+2,tile_0_sy+1];
        

    //
    // Instantiate the IOL2 @[1,2] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", sx+1, tile_0_sy+2);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL2_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL2_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL2_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL2_RX_DATA         ,
                   DO              => ntRef_ntIOL2_DO              ,
                   TO              => ntRef_ntIOL2_TO              ,
                   ODDR_COUT       => ntRef_ntIOL2_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL2_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL2_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL2_TO_OUT          ,
                   
                   TX_DATA[0]        => <wire S_IA0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,   // IOL2 <- SIB
                   TX_DATA[1]        => <wire S_IA1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[2]        => <wire S_IA2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[3]        => <wire S_IA3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[4]        => <wire S_IA4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[5]        => <wire S_IB0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[0]        => <wire S_IB1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[1]        => <wire S_IB2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[2]        => <wire S_IB3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[3]        => <wire S_IB4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_STS_CLR       => <wire S_IC0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[0]     => <wire S_IC1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[1]     => <wire S_IC2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[2]     => <wire S_IC3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[0]       => <wire S_IC4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[1]       => <wire S_ID0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SLIP              => <wire S_ID1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SYSCLK            => <wire S_ICLK of <device CIM @[sx+3, tile_0_sy+2]>>   ,
                   CE                => <wire S_ICE of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   LRS               => <wire S_IRS of <device CIM @[sx+3, tile_0_sy+2]>>    ,

                   DIN               => ntRef_ntIOB2_DIN                                     , // IOL2 <- IOB2
                   IOCLK             => ntRef_ntIOMUX2_OUT                                     // IOL2 <- IOMUX2
                 )
        @[sx+1, tile_0_sy+2];
        
    // Hook up the outputs of SRB <- IOL2
    connect
        (         
            <pin S_IY0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_IODLY_OV       ,
            <pin S_IY1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA_DD       ,
            <pin S_IY2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[0]    ,
            <pin S_IY3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[1]    ,
            <pin S_IQ0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[2]    ,
            <pin S_IQ1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[3]    ,
            <pin S_IQ2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[4]    ,
            <pin S_IQ3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[5]    ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntIOL2_DPI_STS[0]     ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntIOL2_DPI_STS[1]
        );  
        
    //
    // Instantiate the IOB2 @[2,2] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_B_%d_%d", sx+2, tile_0_sy+2);
    device IOB_B *strVar
        port map (
                   DO          => ntRef_ntIOL2_DO         ,  //Input from IOL2 (Tile 0)
                   TO          => ntRef_ntIOL2_TO         ,
                   
                   DIN         => ntRef_ntIOB2_DIN        ,  //output
                   DIFFI_OUT   => ntRef_ntIOB2_DIFFI_OUT    
                 )
        @[sx+2,tile_0_sy+2];
        
    //
    // Layout IOL3 in the tile #1
    //
    // Allocate the wires driven by IOL3
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", sx+1, tile_1_sy+1);                             
    &wire ntRef_ntIOL3_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", sx+1, tile_1_sy+1);                             
    &wire ntRef_ntIOL3_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 

    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_1_sy+1);                             
    &wire ntRef_ntIOL3_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_1_sy+1);                             
    &wire ntRef_ntIOL3_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOB3 in the tile #1
    //
    // Allocate the wires driven by IOB3
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntIOB3_DIN = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntIOB3_DIFFI_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX3 in the tile #1
    //
    // Allocate the wires driven by IOMUX3 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntIOMUX3_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX3 @[3,0] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+3, tile_1_sy);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX3_OUT
                 )
        @[sx+3,tile_1_sy];
           
    //
    // Instantiate the IOL3 @[1,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", sx+1, tile_1_sy+1);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL3_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL3_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL3_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL3_RX_DATA         ,
                   DO              => ntRef_ntIOL3_DO              ,
                   TO              => ntRef_ntIOL3_TO              ,
                   ODDR_COUT       => ntRef_ntIOL3_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL3_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL3_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL3_TO_OUT          ,

                   TX_DATA[0]      => <wire A_IA0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,      //IOL3 <- SIB (tile 1)
                   TX_DATA[1]      => <wire A_IA1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TX_DATA[2]      => <wire A_IA2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TX_DATA[3]      => <wire A_IA3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TX_DATA[4]      => <wire A_IA4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TX_DATA[5]      => <wire A_IB0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TS_CTRL[0]      => <wire A_IB1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TS_CTRL[1]      => <wire A_IB2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TS_CTRL[2]      => <wire A_IB3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TS_CTRL[3]      => <wire A_IB4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DPI_STS_CLR     => <wire A_IC0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   IODLY_CTRL[0]   => <wire A_IC1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   IODLY_CTRL[1]   => <wire A_IC2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   IODLY_CTRL[2]   => <wire A_IC3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DPI_CTRL[0]     => <wire A_IC4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DPI_CTRL[1]     => <wire A_ID0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   SLIP            => <wire A_ID1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   SYSCLK          => <wire A_ICLK of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                   CE              => <wire A_ICE of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   LRS             => <wire A_IRS of <device CIM @[sx+3, tile_1_sy+2]>>    ,

                   DIN             => ntRef_ntIOB3_DIN                                     ,  // IOL3 <- IOB3 (Tile 1) 
                   IOCLK           => ntRef_ntIOMUX3_OUT                                      // IOL3 <- IOMUX3

                 )
        @[sx+1,tile_1_sy+1];

    // Hook up the outputs of IOL3 -> SRB (TILE 1)
    connect
        (
            <pin A_IY0   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_IODLY_OV       , 
            <pin A_IY1   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA_DD       ,
            <pin A_IY2   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[0]    ,
            <pin A_IY3   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[1]    ,
            <pin A_IQ0   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[2]    ,
            <pin A_IQ1   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[3]    ,
            <pin A_IQ2   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[4]    ,
            <pin A_IQ3   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[5]    ,
            <pin S_IY6AB of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_DPI_STS[0]     ,
            <pin S_IY6CD of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_DPI_STS[1]
        );

    //
    // Instantiate the IOB3 @[2,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LA_%d_%d", sx+2, tile_1_sy+1);
    device IOB_LA *strVar
        port map (
                   DO         => ntRef_ntIOL3_DO        ,   //Input from IOL3 (Tile 1)
                   TO         => ntRef_ntIOL3_TO        ,
                   
                   DIN        => ntRef_ntIOB3_DIN       ,   //output
                   DIFFI_OUT  => ntRef_ntIOB3_DIFFI_OUT
                 )
        @[sx+2,tile_1_sy+1];

};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO_L-2CIM block tiles in vertical direction. 
             Each IO block takes the size of 2 tiles. (EAST EDGE)
             
             ----------|----------|----------|----------    
                         IOL2[1,2]  IOB2[2,2]  C[3,2]
               V[0,1]    IOL1[1,1]  IOB1[2,1]  IOMUX2[3,1]
               G[0,0]    R[1,0]     I[2,0]     IOMUX1[3,0]            TILE 0   
             ----------|----------|----------|----------      
                                               C[3,2]
               V[0,1]    IOL3[1,1]  IOB3[2,1]
               G[0,0]    R[1,0]     I[2,0]     IOMUX3[3,0]            TILE 1 
             ----------|----------|----------|----------

            ]

  Revision History:

*****************************************************************************************/
function place_io_aba_fft_2cim_v_tile ( unsigned int tx, ty)
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // The wires are spread out in 2 tiles. Pre-calculate the lower-left corner of all 2 tiles
    unsigned int tile_0_sy =  ty              * TILE_NUM_SITE_Y;
    unsigned int tile_1_sy = (ty - 1)         * TILE_NUM_SITE_Y;
    
    //
    // Layout IOL1 in the tile #0
    //
    // Allocate the wires driven by IOL1
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
   
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", sx+1, tile_0_sy+1);                             
    &wire ntRef_ntIOL1_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", sx+1, tile_0_sy+1);                             
    &wire ntRef_ntIOL1_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_0_sy+1);                             
    &wire ntRef_ntIOL1_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_0_sy+1);                             
    &wire ntRef_ntIOL1_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOB1 in the tile #0
    //
    // Allocate the wires driven by IOB1 
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_0_sy+1);
    &wire ntRef_ntIOB1_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_0_sy+1);
    &wire ntRef_ntIOB1_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOL2 in the tile #0
    //
    // Allocate the wires driven by IOL2
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", sx+1, tile_0_sy+2);                             
    &wire ntRef_ntIOL2_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", sx+1, tile_0_sy+2);                             
    &wire ntRef_ntIOL2_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_0_sy+2);                             
    &wire ntRef_ntIOL2_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_0_sy+2);                             
    &wire ntRef_ntIOL2_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOB2 in the tile #0
    //
    // Allocate the wires driven by IOB2 
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_0_sy+2);
    &wire ntRef_ntIOB2_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_0_sy+2);
    &wire ntRef_ntIOB2_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX1 in the tile #0
    //
    // Allocate the wires driven by IOMUX1 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+3, tile_0_sy);
    &wire ntRef_ntIOMUX1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX1 @[3,0] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+3, tile_0_sy);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX1_OUT
                 )
        @[sx+3,tile_0_sy];
        
    //
    // Layout IOMUX2 in the tile #0
    //
    // Allocate the wires driven by IOMUX2 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+3, tile_0_sy+1);
    &wire ntRef_ntIOMUX2_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX2 @[3,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+3, tile_0_sy+1);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX2_OUT
                 )
        @[sx+3,tile_0_sy+1];
    
    
    //
    // Instantiate the IOL1 @[1,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", sx+1, tile_0_sy+1);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL1_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL1_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL1_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL1_RX_DATA         ,
                   DO              => ntRef_ntIOL1_DO              ,
                   TO              => ntRef_ntIOL1_TO              ,
                   ODDR_COUT       => ntRef_ntIOL1_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL1_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL1_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL1_TO_OUT          ,
                   
                   
                   TX_DATA[0]       => <wire A_IA0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,      // IOL1 <- SIB
                   TX_DATA[1]       => <wire A_IA1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[2]       => <wire A_IA2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[3]       => <wire A_IA3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[4]       => <wire A_IA4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[5]       => <wire A_IB0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[0]       => <wire A_IB1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[1]       => <wire A_IB2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[2]       => <wire A_IB3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[3]       => <wire A_IB4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_STS_CLR      => <wire A_IC0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[0]    => <wire A_IC1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[1]    => <wire A_IC2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[2]    => <wire A_IC3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[0]      => <wire A_IC4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[1]      => <wire A_ID0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SLIP             => <wire A_ID1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SYSCLK           => <wire A_ICLK of <device CIM @[sx+3, tile_0_sy+2]>>   ,
                   CE               => <wire A_ICE of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   LRS              => <wire A_IRS of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   
                   DIN              => ntRef_ntIOB1_DIN                                     , // IOL1 <- IOB1
                   IOCLK            => ntRef_ntIOMUX1_OUT                                     // IOL1 <- IOMUX1
                 )
        @[sx+1,tile_0_sy+1];
        
    // Hook up the outputs of IOL1 -> SRB (TILE 0)
    connect
        (
            <pin A_IY0   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_IODLY_OV      , 
            <pin A_IY1   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA_DD      ,
            <pin A_IY2   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[0]   ,
            <pin A_IY3   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[1]   ,
            <pin A_IQ0   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[2]   ,
            <pin A_IQ1   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[3]   ,
            <pin A_IQ2   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[4]   ,
            <pin A_IQ3   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[5]   ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_DPI_STS[0]    ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_DPI_STS[1]
        );
        
    //
    // Instantiate the IOB1 @[2,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LA_%d_%d", sx+2, tile_0_sy+1);
    device IOB_LA *strVar
        port map (
                   DO          => ntRef_ntIOL1_DO          , //Input from IOL1 (Tile 0)
                   TO          => ntRef_ntIOL1_TO          ,
                   
                   DIN         => ntRef_ntIOB1_DIN         ,   //output
                   DIFFI_OUT   => ntRef_ntIOB1_DIFFI_OUT
                 )
        @[sx+2,tile_0_sy+1];
        

    //
    // Instantiate the IOL2 @[1,2] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", sx+1, tile_0_sy+2);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL2_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL2_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL2_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL2_RX_DATA         ,
                   DO              => ntRef_ntIOL2_DO              ,
                   TO              => ntRef_ntIOL2_TO              ,
                   ODDR_COUT       => ntRef_ntIOL2_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL2_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL2_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL2_TO_OUT          ,
                   
                   TX_DATA[0]        => <wire S_IA0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,   // IOL2 <- SIB
                   TX_DATA[1]        => <wire S_IA1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[2]        => <wire S_IA2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[3]        => <wire S_IA3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[4]        => <wire S_IA4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[5]        => <wire S_IB0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[0]        => <wire S_IB1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[1]        => <wire S_IB2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[2]        => <wire S_IB3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[3]        => <wire S_IB4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_STS_CLR       => <wire S_IC0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[0]     => <wire S_IC1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[1]     => <wire S_IC2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[2]     => <wire S_IC3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[0]       => <wire S_IC4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[1]       => <wire S_ID0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SLIP              => <wire S_ID1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SYSCLK            => <wire S_ICLK of <device CIM @[sx+3, tile_0_sy+2]>>   ,
                   CE                => <wire S_ICE of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   LRS               => <wire S_IRS of <device CIM @[sx+3, tile_0_sy+2]>>    ,

                   DIN               => ntRef_ntIOB2_DIN                                     , // IOL2 <- IOB2
                   IOCLK             => ntRef_ntIOMUX2_OUT                                     // IOL2 <- IOMUX2
                 )
        @[sx+1, tile_0_sy+2];
        
    // Hook up the outputs of SRB <- IOL2
    connect
        (         
            <pin S_IY0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_IODLY_OV       ,
            <pin S_IY1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA_DD       ,
            <pin S_IY2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[0]    ,
            <pin S_IY3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[1]    ,
            <pin S_IQ0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[2]    ,
            <pin S_IQ1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[3]    ,
            <pin S_IQ2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[4]    ,
            <pin S_IQ3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[5]    ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntIOL2_DPI_STS[0]     ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntIOL2_DPI_STS[1]
        );  
        
    //
    // Instantiate the IOB2 @[2,2] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LB_%d_%d", sx+2, tile_0_sy+2);
    device IOB_LB *strVar
        port map (
                   DO          => ntRef_ntIOL2_DO         ,  //Input from IOL2 (Tile 0)
                   TO          => ntRef_ntIOL2_TO         ,
                   
                   DIN         => ntRef_ntIOB2_DIN        ,  //output
                   DIFFI_OUT   => ntRef_ntIOB2_DIFFI_OUT    
                 )
        @[sx+2,tile_0_sy+2];
        
    //
    // Layout IOL3 in the tile #1
    //
    // Allocate the wires driven by IOL3
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", sx+1, tile_1_sy+1);                             
    &wire ntRef_ntIOL3_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", sx+1, tile_1_sy+1);                             
    &wire ntRef_ntIOL3_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_1_sy+1);                             
    &wire ntRef_ntIOL3_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_1_sy+1);                             
    &wire ntRef_ntIOL3_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    //
    // Layout IOB3 in the tile #1
    //
    // Allocate the wires driven by IOB3
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntIOB3_DIN = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFO_OUT_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntIOB3_DIFFO_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntIOB3_DIFFI_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX3 in the tile #1
    //
    // Allocate the wires driven by IOMUX3 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntIOMUX3_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX3 @[3,0] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+3, tile_1_sy);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX3_OUT
                 )
        @[sx+3,tile_1_sy];
           
    //
    // Instantiate the IOL3 @[1,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", sx+1, tile_1_sy+1);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL3_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL3_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL3_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL3_RX_DATA         ,
                   DO              => ntRef_ntIOL3_DO              ,
                   TO              => ntRef_ntIOL3_TO              ,
                   ODDR_COUT       => ntRef_ntIOL3_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL3_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL3_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL3_TO_OUT          ,

                   TX_DATA[0]      => <wire A_IA0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,      //IOL3 <- SIB (tile 1)
                   TX_DATA[1]      => <wire A_IA1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TX_DATA[2]      => <wire A_IA2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TX_DATA[3]      => <wire A_IA3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TX_DATA[4]      => <wire A_IA4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TX_DATA[5]      => <wire A_IB0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TS_CTRL[0]      => <wire A_IB1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TS_CTRL[1]      => <wire A_IB2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TS_CTRL[2]      => <wire A_IB3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TS_CTRL[3]      => <wire A_IB4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DPI_STS_CLR     => <wire A_IC0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   IODLY_CTRL[0]   => <wire A_IC1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   IODLY_CTRL[1]   => <wire A_IC2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   IODLY_CTRL[2]   => <wire A_IC3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DPI_CTRL[0]     => <wire A_IC4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DPI_CTRL[1]     => <wire A_ID0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   SLIP            => <wire A_ID1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   SYSCLK          => <wire A_ICLK of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                   CE              => <wire A_ICE of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   LRS             => <wire A_IRS of <device CIM @[sx+3, tile_1_sy+2]>>    ,

                   DIN             => ntRef_ntIOB3_DIN                                     ,  //IOL3 <- IOB3 (Tile 1) 
                   IOCLK           => ntRef_ntIOMUX3_OUT                                      // IOL3 <- IOMUX3

                 )
        @[sx+1,tile_1_sy+1];

    // Hook up the outputs of IOL3 -> SRB (TILE 1)
    connect
        (
            <pin A_IY0   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_IODLY_OV       , 
            <pin A_IY1   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA_DD       ,
            <pin A_IY2   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[0]    ,
            <pin A_IY3   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[1]    ,
            <pin A_IQ0   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[2]    ,
            <pin A_IQ1   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[3]    ,
            <pin A_IQ2   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[4]    ,
            <pin A_IQ3   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[5]    ,
            <pin S_IY6AB of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_DPI_STS[0]     ,
            <pin S_IY6CD of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_DPI_STS[1]
        );

    //
    // Instantiate the IOB3 @[2,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_A_%d_%d", sx+2, tile_1_sy+1);
    device IOB_A *strVar
        port map (
                   DO         => ntRef_ntIOL3_DO        ,   //Input from IOL3 (Tile 1)
                   TO         => ntRef_ntIOL3_TO        ,
                   
                   DIN        => ntRef_ntIOB3_DIN       ,   //output
                   DIFFO_OUT  => ntRef_ntIOB3_DIFFO_OUT ,
                   DIFFI_OUT  => ntRef_ntIOB3_DIFFI_OUT
                 )
        @[sx+2,tile_1_sy+1];

};


/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO_L-2CIM block tiles in vertical direction. 
             Each IO block takes the size of 2 tiles. (EAST EDGE)
             
             ----------|----------|----------|----------    
                         IOL1[1,2]  IOB1[2,2]  C[3,2]
               V[0,1]                          IOMUX1[3,1]
               G[0,0]    R[1,0]     I[2,0]                 TILE PRE  
             ----------|----------|----------|----------    
                                               C[3,2]
               V[0,1]          
               G[0,0]    R[1,0]     I[2,0]                 TILE 0   
             ----------|----------|----------|----------      
                         IOL3[1,2]  IOB3[2,2]  C[3,2]
               V[0,1]    IOL2[1,1]  IOB2[2,1]  IOMUX3[3,1]
               G[0,0]    R[1,0]     I[2,0]     IOMUX2[3,0] TILE 1 
             ----------|----------|----------|----------

            ]

  Revision History:

*****************************************************************************************/
function place_io_bab_tff_2cim_v_tile ( unsigned int tx, ty)
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // The wires are spread out in 2 tiles. Pre-calculate the lower-left corner of all 2 tiles
    unsigned int tile_pre_sy = (ty + 1)         * TILE_NUM_SITE_Y;    
    unsigned int tile_0_sy   =  ty              * TILE_NUM_SITE_Y;
    unsigned int tile_1_sy   = (ty - 1)         * TILE_NUM_SITE_Y;
    
    //
    // Layout IOL1 in the tile #pre
    //
    // Allocate the wires driven by IOL1
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
   
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", sx+1, tile_pre_sy+2);                             
    &wire ntRef_ntIOL1_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", sx+1, tile_pre_sy+2);                             
    &wire ntRef_ntIOL1_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_pre_sy+2);                             
    &wire ntRef_ntIOL1_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_pre_sy+2);                             
    &wire ntRef_ntIOL1_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    //
    // Layout IOB1 in the tile #pre
    //
    // Allocate the wires driven by IOB1 
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_pre_sy+2);
    &wire ntRef_ntIOB1_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_pre_sy+2);
    &wire ntRef_ntIOB1_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX1 in the tile #pre
    //
    // Allocate the wires driven by IOMUX1
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+3, tile_pre_sy+1);
    &wire ntRef_ntIOMUX1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX1 @[3,1] in tile #pre. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+3, tile_pre_sy+1);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX1_OUT
                 )
        @[sx+3,tile_pre_sy+1];
    
    //
    // Layout IOL2 in the tile #1
    //
    // Allocate the wires driven by IOL2
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", sx+1, tile_1_sy+1);                             
    &wire ntRef_ntIOL2_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", sx+1, tile_1_sy+1);                             
    &wire ntRef_ntIOL2_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_1_sy+1);                             
    &wire ntRef_ntIOL2_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_1_sy+1);                             
    &wire ntRef_ntIOL2_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOB2 in the tile #1
    //
    // Allocate the wires driven by IOB2 
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntIOB2_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntIOB2_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX2 in the tile #1
    //
    // Allocate the wires driven by IOMUX2 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntIOMUX2_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX2 @[3,0] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+3, tile_1_sy);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX2_OUT
                 )
        @[sx+3,tile_1_sy];
        
    //
    // Layout IOMUX3 in the tile #1
    //
    // Allocate the wires driven by IOMUX3 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+3, tile_1_sy+1);
    &wire ntRef_ntIOMUX3_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX3 @[3,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+3, tile_1_sy+1);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX3_OUT
                 )
        @[sx+3,tile_1_sy+1];
        
    //
    // Instantiate the IOL1 @[1,2] in tile #PRE. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", sx+1, tile_pre_sy+2);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL1_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL1_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL1_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL1_RX_DATA         ,
                   DO              => ntRef_ntIOL1_DO              ,
                   TO              => ntRef_ntIOL1_TO              ,
                   ODDR_COUT       => ntRef_ntIOL1_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL1_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL1_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL1_TO_OUT          ,
                   
                   TX_DATA[0]       => <wire A_IA0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,      // IOL1 <- SIB
                   TX_DATA[1]       => <wire A_IA1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[2]       => <wire A_IA2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[3]       => <wire A_IA3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[4]       => <wire A_IA4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[5]       => <wire A_IB0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[0]       => <wire A_IB1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[1]       => <wire A_IB2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[2]       => <wire A_IB3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[3]       => <wire A_IB4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_STS_CLR      => <wire A_IC0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[0]    => <wire A_IC1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[1]    => <wire A_IC2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[2]    => <wire A_IC3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[0]      => <wire A_IC4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[1]      => <wire A_ID0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SLIP             => <wire A_ID1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SYSCLK           => <wire A_ICLK of <device CIM @[sx+3, tile_0_sy+2]>>   ,
                   CE               => <wire A_ICE of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   LRS              => <wire A_IRS of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   
                   DIN              => ntRef_ntIOB1_DIN                                     , // IOL1 <- IOB1
                   IOCLK            => ntRef_ntIOMUX1_OUT                                     // IOL1 <- IOMUX1
                 )
        @[sx+1,tile_pre_sy+2];
        
    // Hook up the outputs of IOL1 -> SRB (TILE 0)
    connect
        (
            <pin A_IY0   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_IODLY_OV      , 
            <pin A_IY1   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA_DD      ,
            <pin A_IY2   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[0]   ,
            <pin A_IY3   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[1]   ,
            <pin A_IQ0   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[2]   ,
            <pin A_IQ1   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[3]   ,
            <pin A_IQ2   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[4]   ,
            <pin A_IQ3   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[5]   ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_DPI_STS[0]    ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_DPI_STS[1]
        );
        
    //
    // Instantiate the IOB1 @[2,2] in tile #pre. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_B_%d_%d", sx+2, tile_pre_sy+2);
    device IOB_B *strVar
        port map (
                   DO         => ntRef_ntIOL1_DO        , //Input from IOL1 (Tile 1)
                   TO         => ntRef_ntIOL1_TO         ,
                   
                   DIN        => ntRef_ntIOB1_DIN         ,   //output
                   DIFFI_OUT     => ntRef_ntIOB1_DIFFI_OUT  
                 )
        @[sx+2,tile_pre_sy+2];
        

    //
    // Instantiate the IOL2 @[1,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", sx+1, tile_1_sy+1);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL2_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL2_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL2_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL2_RX_DATA         ,
                   DO              => ntRef_ntIOL2_DO              ,
                   TO              => ntRef_ntIOL2_TO              ,
                   ODDR_COUT       => ntRef_ntIOL2_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL2_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL2_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL2_TO_OUT          ,
                   
                   TX_DATA[0]        => <wire S_IA0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,   // IOL2 <- SIB
                   TX_DATA[1]        => <wire S_IA1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[2]        => <wire S_IA2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[3]        => <wire S_IA3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[4]        => <wire S_IA4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[5]        => <wire S_IB0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[0]        => <wire S_IB1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[1]        => <wire S_IB2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[2]        => <wire S_IB3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[3]        => <wire S_IB4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_STS_CLR       => <wire S_IC0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[0]     => <wire S_IC1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[1]     => <wire S_IC2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[2]     => <wire S_IC3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[0]       => <wire S_IC4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[1]       => <wire S_ID0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SLIP              => <wire S_ID1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SYSCLK            => <wire S_ICLK of <device CIM @[sx+3, tile_0_sy+2]>>   ,
                   CE                => <wire S_ICE of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   LRS               => <wire S_IRS of <device CIM @[sx+3, tile_0_sy+2]>>    ,

                   DIN               => ntRef_ntIOB2_DIN                                     ,  // IOL2 <- IOB2
                   IOCLK             => ntRef_ntIOMUX2_OUT                                      // IOL2 <- IOMUX2
                 )
        @[sx+1, tile_1_sy+1];
        
    // Hook up the outputs of SRB <- IOL2
    connect
        (         
            <pin S_IY0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_IODLY_OV       ,
            <pin S_IY1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA_DD       ,
            <pin S_IY2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[0]    ,
            <pin S_IY3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[1]    ,
            <pin S_IQ0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[2]    ,
            <pin S_IQ1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[3]    ,
            <pin S_IQ2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[4]    ,
            <pin S_IQ3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[5]    ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntIOL2_DPI_STS[0]     ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntIOL2_DPI_STS[1]
        );  
        
    //
    // Instantiate the IOB2 @[2,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LA_%d_%d", sx+2, tile_1_sy+1);
    device IOB_LA *strVar
        port map (
                   DO          => ntRef_ntIOL2_DO        ,  //Input from IOL2 (Tile 0)
                   TO          => ntRef_ntIOL2_TO        ,
                   
                   DIN         => ntRef_ntIOB2_DIN       ,  //output
                   DIFFI_OUT   => ntRef_ntIOB2_DIFFI_OUT  
                 )
        @[sx+2,tile_1_sy+1];
        
    //
    // Layout IOL3 in the tile #1
    //
    // Allocate the wires driven by IOL3
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_1_sy+2);
    &wire ntRef_ntIOL3_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_1_sy+2);
    &wire ntRef_ntIOL3_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_1_sy+2);
    &wire ntRef_ntIOL3_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_1_sy+2);
    &wire ntRef_ntIOL3_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_1_sy+2);
    &wire ntRef_ntIOL3_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_1_sy+2);
    &wire ntRef_ntIOL3_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", sx+1, tile_1_sy+2);                             
    &wire ntRef_ntIOL3_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", sx+1, tile_1_sy+2);                             
    &wire ntRef_ntIOL3_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_1_sy+2);                             
    &wire ntRef_ntIOL3_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_1_sy+2);                             
    &wire ntRef_ntIOL3_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 

    //
    // Layout IOB3 in the tile #1
    //
    // Allocate the wires driven by IOB3
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_1_sy+2);
    &wire ntRef_ntIOB3_DIN = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_1_sy+2);
    &wire ntRef_ntIOB3_DIFFI_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
       
    //
    // Instantiate the IOL3 @[1,2] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", sx+1, tile_1_sy+2);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL3_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL3_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL3_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL3_RX_DATA         ,
                   DO              => ntRef_ntIOL3_DO              ,
                   TO              => ntRef_ntIOL3_TO              ,
                   ODDR_COUT       => ntRef_ntIOL3_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL3_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL3_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL3_TO_OUT          ,

                   TX_DATA[0]      => <wire A_IA0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,      //IOL3 <- SIB (tile 1)
                   TX_DATA[1]      => <wire A_IA1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TX_DATA[2]      => <wire A_IA2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TX_DATA[3]      => <wire A_IA3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TX_DATA[4]      => <wire A_IA4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TX_DATA[5]      => <wire A_IB0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TS_CTRL[0]      => <wire A_IB1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TS_CTRL[1]      => <wire A_IB2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TS_CTRL[2]      => <wire A_IB3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TS_CTRL[3]      => <wire A_IB4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DPI_STS_CLR     => <wire A_IC0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   IODLY_CTRL[0]   => <wire A_IC1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   IODLY_CTRL[1]   => <wire A_IC2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   IODLY_CTRL[2]   => <wire A_IC3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DPI_CTRL[0]     => <wire A_IC4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DPI_CTRL[1]     => <wire A_ID0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   SLIP            => <wire A_ID1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   SYSCLK          => <wire A_ICLK of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                   CE              => <wire A_ICE of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   LRS             => <wire A_IRS of <device CIM @[sx+3, tile_1_sy+2]>>    ,

                   DIN             => ntRef_ntIOB3_DIN                                     ,  // IOL3 <- IOB3 (Tile 1) 
                   IOCLK           => ntRef_ntIOMUX3_OUT                                      // IOL3 <- IOMUX3

                 )
        @[sx+1,tile_1_sy+2];

    // Hook up the outputs of IOL3 -> SRB (TILE 1)
    connect
        (
            <pin A_IY0   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_IODLY_OV       , 
            <pin A_IY1   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA_DD       ,
            <pin A_IY2   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[0]    ,
            <pin A_IY3   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[1]    ,
            <pin A_IQ0   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[2]    ,
            <pin A_IQ1   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[3]    ,
            <pin A_IQ2   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[4]    ,
            <pin A_IQ3   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[5]    ,
            <pin S_IY6AB of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_DPI_STS[0]     ,
            <pin S_IY6CD of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_DPI_STS[1]
        );

    //
    // Instantiate the IOB3 @[2,2] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LB_%d_%d", sx+2, tile_1_sy+2);
    device IOB_LB *strVar
        port map (
                   DO         => ntRef_ntIOL3_DO    ,   //Input from IOL3 (Tile 1)
                   TO         => ntRef_ntIOL3_TO     ,
                   
                   DIN        => ntRef_ntIOB3_DIN     ,   //output
                   DIFFI_OUT  => ntRef_ntIOB3_DIFFI_OUT
                 )
        @[sx+2,tile_1_sy+2];

};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO_L-2CIM block tiles in vertical direction. 
             Each IO block takes the size of 2 tiles. (EAST EDGE)
             
             ----------|----------|----------|----------    
                         IOL1[1,2]  IOB1[2,2]  C[3,2]
               V[0,1]                          IOMUX1[3,1]
               G[0,0]    R[1,0]     I[2,0]                 TILE PRE  
             ----------|----------|----------|----------    
                                               C[3,2]
               V[0,1]          
               G[0,0]    R[1,0]     I[2,0]                 TILE 0   
             ----------|----------|----------|----------      
                         IOL3[1,2]  IOB3[2,2]  C[3,2]
               V[0,1]    IOL2[1,1]  IOB2[2,1]  IOMUX3[3,1]
               G[0,0]    R[1,0]     I[2,0]     IOMUX2[3,0] TILE 1 
             ----------|----------|----------|----------

            ]

  Revision History:

*****************************************************************************************/
function place_io_bab_ftt_2cim_v_tile ( unsigned int tx, ty)
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // The wires are spread out in 2 tiles. Pre-calculate the lower-left corner of all 2 tiles
    unsigned int tile_pre_sy = (ty + 1)         * TILE_NUM_SITE_Y;    
    unsigned int tile_0_sy   =  ty              * TILE_NUM_SITE_Y;
    unsigned int tile_1_sy   = (ty - 1)         * TILE_NUM_SITE_Y;
    
    //
    // Layout IOL1 in the tile #pre
    //
    // Allocate the wires driven by IOL1
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
   
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", sx+1, tile_pre_sy+2);                             
    &wire ntRef_ntIOL1_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", sx+1, tile_pre_sy+2);                             
    &wire ntRef_ntIOL1_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_pre_sy+2);                             
    &wire ntRef_ntIOL1_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_pre_sy+2);                             
    &wire ntRef_ntIOL1_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    //
    // Layout IOB1 in the tile #pre
    //
    // Allocate the wires driven by IOB1 
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_pre_sy+2);
    &wire ntRef_ntIOB1_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_pre_sy+2);
    &wire ntRef_ntIOB1_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX1 in the tile #pre
    //
    // Allocate the wires driven by IOMUX1
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+3, tile_pre_sy+1);
    &wire ntRef_ntIOMUX1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX1 @[3,1] in tile #pre. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+3, tile_pre_sy+1);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX1_OUT
                 )
        @[sx+3,tile_pre_sy+1];
    
    //
    // Layout IOL2 in the tile #1
    //
    // Allocate the wires driven by IOL2
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", sx+1, tile_1_sy+1);                             
    &wire ntRef_ntIOL2_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", sx+1, tile_1_sy+1);                             
    &wire ntRef_ntIOL2_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_1_sy+1);                             
    &wire ntRef_ntIOL2_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_1_sy+1);                             
    &wire ntRef_ntIOL2_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOB2 in the tile #1
    //
    // Allocate the wires driven by IOB2 
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntIOB2_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFO_OUT_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntIOB2_DIFFO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntIOB2_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    //
    // Layout IOMUX2 in the tile #1
    //
    // Allocate the wires driven by IOMUX2 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntIOMUX2_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX2 @[3,0] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+3, tile_1_sy);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX2_OUT
                 )
        @[sx+3,tile_1_sy];
        
    //
    // Layout IOMUX3 in the tile #1
    //
    // Allocate the wires driven by IOMUX3 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+3, tile_1_sy+1);
    &wire ntRef_ntIOMUX3_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX3 @[3,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+3, tile_1_sy+1);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX3_OUT
                 )
        @[sx+3,tile_1_sy+1];
        
    //
    // Instantiate the IOL1 @[1,2] in tile #PRE. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", sx+1, tile_pre_sy+2);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL1_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL1_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL1_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL1_RX_DATA         ,
                   DO              => ntRef_ntIOL1_DO              ,
                   TO              => ntRef_ntIOL1_TO              ,
                   ODDR_COUT       => ntRef_ntIOL1_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL1_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL1_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL1_TO_OUT          ,
                   
                   TX_DATA[0]       => <wire A_IA0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,      // IOL1 <- SIB
                   TX_DATA[1]       => <wire A_IA1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[2]       => <wire A_IA2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[3]       => <wire A_IA3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[4]       => <wire A_IA4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[5]       => <wire A_IB0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[0]       => <wire A_IB1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[1]       => <wire A_IB2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[2]       => <wire A_IB3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[3]       => <wire A_IB4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_STS_CLR      => <wire A_IC0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[0]    => <wire A_IC1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[1]    => <wire A_IC2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[2]    => <wire A_IC3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[0]      => <wire A_IC4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[1]      => <wire A_ID0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SLIP             => <wire A_ID1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SYSCLK           => <wire A_ICLK of <device CIM @[sx+3, tile_0_sy+2]>>   ,
                   CE               => <wire A_ICE of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   LRS              => <wire A_IRS of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   
                   DIN              => ntRef_ntIOB1_DIN                                     ,  // IOL1 <- IOB1
                   IOCLK            => ntRef_ntIOMUX1_OUT                                      // IOL1 <- IOMUX1
                 )
        @[sx+1,tile_pre_sy+2];
        
    // Hook up the outputs of IOL1 -> SRB (TILE 0)
    connect
        (
            <pin A_IY0   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_IODLY_OV      , 
            <pin A_IY1   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA_DD      ,
            <pin A_IY2   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[0]   ,
            <pin A_IY3   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[1]   ,
            <pin A_IQ0   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[2]   ,
            <pin A_IQ1   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[3]   ,
            <pin A_IQ2   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[4]   ,
            <pin A_IQ3   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[5]   ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_DPI_STS[0]    ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_DPI_STS[1]
        );
        
    //
    // Instantiate the IOB1 @[2,2] in tile #pre. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LB_%d_%d", sx+2, tile_pre_sy+2);
    device IOB_LB *strVar
        port map (
                   DO         => ntRef_ntIOL1_DO        , //Input from IOL1 (Tile 1)
                   TO         => ntRef_ntIOL1_TO         ,
                   
                   DIN        => ntRef_ntIOB1_DIN         ,   //output
                   DIFFI_OUT     => ntRef_ntIOB1_DIFFI_OUT  
                 )
        @[sx+2,tile_pre_sy+2];
        

    //
    // Instantiate the IOL2 @[1,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", sx+1, tile_1_sy+1);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL2_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL2_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL2_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL2_RX_DATA         ,
                   DO              => ntRef_ntIOL2_DO              ,
                   TO              => ntRef_ntIOL2_TO              ,
                   ODDR_COUT       => ntRef_ntIOL2_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL2_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL2_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL2_TO_OUT          ,
                   
                   TX_DATA[0]        => <wire S_IA0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,   // IOL2 <- SIB
                   TX_DATA[1]        => <wire S_IA1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[2]        => <wire S_IA2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[3]        => <wire S_IA3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[4]        => <wire S_IA4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[5]        => <wire S_IB0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[0]        => <wire S_IB1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[1]        => <wire S_IB2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[2]        => <wire S_IB3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[3]        => <wire S_IB4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_STS_CLR       => <wire S_IC0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[0]     => <wire S_IC1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[1]     => <wire S_IC2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[2]     => <wire S_IC3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[0]       => <wire S_IC4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[1]       => <wire S_ID0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SLIP              => <wire S_ID1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SYSCLK            => <wire S_ICLK of <device CIM @[sx+3, tile_0_sy+2]>>   ,
                   CE                => <wire S_ICE of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   LRS               => <wire S_IRS of <device CIM @[sx+3, tile_0_sy+2]>>    ,

                   DIN               => ntRef_ntIOB2_DIN                                     , // IOL2 <- IOB2
                   IOCLK             => ntRef_ntIOMUX2_OUT                                     // IOL2 <- IOMUX2
                 )
        @[sx+1, tile_1_sy+1];
        
    // Hook up the outputs of SRB <- IOL2
    connect
        (         
            <pin S_IY0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_IODLY_OV       ,
            <pin S_IY1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA_DD       ,
            <pin S_IY2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[0]    ,
            <pin S_IY3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[1]    ,
            <pin S_IQ0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[2]    ,
            <pin S_IQ1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[3]    ,
            <pin S_IQ2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[4]    ,
            <pin S_IQ3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[5]    ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntIOL2_DPI_STS[0]     ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntIOL2_DPI_STS[1]
        );  
        
    //
    // Instantiate the IOB2 @[2,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_A_%d_%d", sx+2, tile_1_sy+1);
    device IOB_A *strVar
        port map (
                   DO          => ntRef_ntIOL2_DO        ,  //Input from IOL2 (Tile 0)
                   TO          => ntRef_ntIOL2_TO        ,
                   
                   DIN         => ntRef_ntIOB2_DIN       ,  //output
                   DIFFO_OUT   => ntRef_ntIOB2_DIFFO_OUT ,  
                   DIFFI_OUT   => ntRef_ntIOB2_DIFFI_OUT  
                 )
        @[sx+2,tile_1_sy+1];
        
    //
    // Layout IOL3 in the tile #1
    //
    // Allocate the wires driven by IOL3
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_1_sy+2);
    &wire ntRef_ntIOL3_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_1_sy+2);
    &wire ntRef_ntIOL3_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_1_sy+2);
    &wire ntRef_ntIOL3_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_1_sy+2);
    &wire ntRef_ntIOL3_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_1_sy+2);
    &wire ntRef_ntIOL3_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_1_sy+2);
    &wire ntRef_ntIOL3_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", sx+1, tile_1_sy+2);                             
    &wire ntRef_ntIOL3_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", sx+1, tile_1_sy+2);                             
    &wire ntRef_ntIOL3_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_1_sy+2);                             
    &wire ntRef_ntIOL3_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_1_sy+2);                             
    &wire ntRef_ntIOL3_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 

    //
    // Layout IOB3 in the tile #1
    //
    // Allocate the wires driven by IOB3
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_1_sy+2);
    &wire ntRef_ntIOB3_DIN = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_1_sy+2);
    &wire ntRef_ntIOB3_DIFFI_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
       
    //
    // Instantiate the IOL3 @[1,2] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", sx+1, tile_1_sy+2);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL3_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL3_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL3_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL3_RX_DATA         ,
                   DO              => ntRef_ntIOL3_DO              ,
                   TO              => ntRef_ntIOL3_TO              ,
                   ODDR_COUT       => ntRef_ntIOL3_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL3_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL3_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL3_TO_OUT          ,

                   TX_DATA[0]      => <wire A_IA0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,      //IOL3 <- SIB (tile 1)
                   TX_DATA[1]      => <wire A_IA1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TX_DATA[2]      => <wire A_IA2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TX_DATA[3]      => <wire A_IA3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TX_DATA[4]      => <wire A_IA4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TX_DATA[5]      => <wire A_IB0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TS_CTRL[0]      => <wire A_IB1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TS_CTRL[1]      => <wire A_IB2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TS_CTRL[2]      => <wire A_IB3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TS_CTRL[3]      => <wire A_IB4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DPI_STS_CLR     => <wire A_IC0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   IODLY_CTRL[0]   => <wire A_IC1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   IODLY_CTRL[1]   => <wire A_IC2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   IODLY_CTRL[2]   => <wire A_IC3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DPI_CTRL[0]     => <wire A_IC4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   DPI_CTRL[1]     => <wire A_ID0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   SLIP            => <wire A_ID1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   SYSCLK          => <wire A_ICLK of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                   CE              => <wire A_ICE of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   LRS             => <wire A_IRS of <device CIM @[sx+3, tile_1_sy+2]>>    ,

                   DIN             => ntRef_ntIOB3_DIN                                     ,  //IOL3 <- IOB3 (Tile 1) 
                   IOCLK           => ntRef_ntIOMUX3_OUT                                      // IOL3 <- IOMUX3

                 )
        @[sx+1,tile_1_sy+2];

    // Hook up the outputs of IOL3 -> SRB (TILE 1)
    connect
        (
            <pin A_IY0   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_IODLY_OV       , 
            <pin A_IY1   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA_DD       ,
            <pin A_IY2   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[0]    ,
            <pin A_IY3   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[1]    ,
            <pin A_IQ0   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[2]    ,
            <pin A_IQ1   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[3]    ,
            <pin A_IQ2   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[4]    ,
            <pin A_IQ3   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[5]    ,
            <pin S_IY6AB of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_DPI_STS[0]     ,
            <pin S_IY6CD of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_DPI_STS[1]
        );

    //
    // Instantiate the IOB3 @[2,2] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_B_%d_%d", sx+2, tile_1_sy+2);
    device IOB_B *strVar
        port map (
                   DO         => ntRef_ntIOL3_DO    ,   //Input from IOL3 (Tile 1)
                   TO         => ntRef_ntIOL3_TO     ,
                   
                   DIN        => ntRef_ntIOB3_DIN     ,   //output
                   DIFFI_OUT  => ntRef_ntIOB3_DIFFI_OUT
                 )
        @[sx+2,tile_1_sy+2];

};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-DQS-2CIM block tiles. 
             Each IO block takes the size of 2 tiles. 
             
             ---------|---------|---------|---------    
                       IOL2[1,2] IOB2[2,2]  C[3,2]
               V[0,1]  IOL1[1,1] IOB1[2,1]  IOMUX2[3,1]
               G[0,0]  R[1,0]    I[2,0]     IOMUX1[3,0]           TILE 0   
             ---------|---------|----------|---------      
                                 IOMUX4[2,2] C[3,2]
               V[0,1]            IOMUX3[2,1] DQS_MUX[3,1]
               G[0,0]  R[1,0]    I[2,0]      DQS[3,0]             TILE 1 
             ---------|---------|----------|---------
                                                                           
              
            ]

  Revision History:

*****************************************************************************************/
function place_io_dqs_tt_2cim_v_tile ( unsigned int tx, ty)
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // The wires are spread out in 2 tiles. Pre-calculate the lower-left corner of all 2 tiles
    unsigned int tile_0_sy =  ty              * TILE_NUM_SITE_Y;
    unsigned int tile_1_sy = (ty - 1)         * TILE_NUM_SITE_Y;
    
    //
    // Layout IOL1 in the tile #0
    //
    // Allocate the wires driven by IOL1
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", sx+1, tile_0_sy+1);                             
    &wire ntRef_ntIOL1_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", sx+1, tile_0_sy+1);                             
    &wire ntRef_ntIOL1_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  

    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_0_sy+1);                             
    &wire ntRef_ntIOL1_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_0_sy+1);                             
    &wire ntRef_ntIOL1_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;   
    
    //
    // Layout IOB1 in the tile #0
    //
    // Allocate the wires driven by IOB1 
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_0_sy+1);
    &wire ntRef_ntIOB1_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    sprintf(strVar, "ntDIFFO_OUT_%d_%d", sx+2, tile_0_sy+1);
    &wire ntRef_ntIOB1_DIFFO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_0_sy+1);
    &wire ntRef_ntIOB1_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX1 in the tile #0
    //
    // Allocate the wires driven by IOMUX1 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+3, tile_0_sy);
    &wire ntRef_ntIOMUX1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX1 @[3,0] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+3, tile_0_sy);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX1_OUT
                 )
        @[sx+3,tile_0_sy];
        
    //
    // Layout IOMUX2 in the tile #0
    //
    // Allocate the wires driven by IOMUX2 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+3, tile_0_sy+1);
    &wire ntRef_ntIOMUX2_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX2 @[3,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+3, tile_0_sy+1);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX2_OUT
                 )
        @[sx+3,tile_0_sy+1];
    
    //
    // Instantiate the IOL1 @[1,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", sx+1, tile_0_sy+1);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL1_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL1_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL1_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL1_RX_DATA         ,
                   DO              => ntRef_ntIOL1_DO              ,
                   TO              => ntRef_ntIOL1_TO              ,
                   ODDR_COUT       => ntRef_ntIOL1_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL1_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL1_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL1_TO_OUT          ,
                   
                   TX_DATA[0]       => <wire A_IA0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,      // IOL1 <- SIB
                   TX_DATA[1]       => <wire A_IA1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[2]       => <wire A_IA2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[3]       => <wire A_IA3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[4]       => <wire A_IA4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[5]       => <wire A_IB0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[0]       => <wire A_IB1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[1]       => <wire A_IB2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[2]       => <wire A_IB3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[3]       => <wire A_IB4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_STS_CLR      => <wire A_IC0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[0]    => <wire A_IC1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[1]    => <wire A_IC2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[2]    => <wire A_IC3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[0]      => <wire A_IC4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[1]      => <wire A_ID0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SLIP             => <wire A_ID1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SYSCLK           => <wire A_ICLK of <device CIM @[sx+3, tile_0_sy+2]>>   ,
                   CE               => <wire A_ICE of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   LRS              => <wire A_IRS of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   
                   DIN              => ntRef_ntIOB1_DIN                                     ,  // IOL1 <- IOB1
                   IOCLK            => ntRef_ntIOMUX1_OUT                                      // IOL1 <- IOMUX1
                 )
        @[sx+1,tile_0_sy+1];
        
    // Hook up the outputs of IOL1 -> SRB (TILE 0)
    connect
        (
            <pin A_IY0 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_IODLY_OV      , 
            <pin A_IY1 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA_DD      ,
            <pin A_IY2 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[0]   ,
            <pin A_IY3 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[1]   ,
            <pin A_IQ0 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[2]   ,
            <pin A_IQ1 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[3]   ,
            <pin A_IQ2 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[4]   ,
            <pin A_IQ3 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[5]   ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_DPI_STS[0]  ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_DPI_STS[1]
        );

    //
    // Instantiate the IOB1 @[2,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_A_%d_%d", sx+2, tile_0_sy+1);
    device IOB_A *strVar
        port map (
                   DO         => ntRef_ntIOL1_DO          ,   //Input from IOL1 (Tile 0)
                   TO         => ntRef_ntIOL1_TO          ,
                   
                   DIN        => ntRef_ntIOB1_DIN         ,   //output
                   DIFFO_OUT  => ntRef_ntIOB1_DIFFO_OUT   ,
                   DIFFI_OUT  => ntRef_ntIOB1_DIFFI_OUT
                 )
        @[sx+2,tile_0_sy+1];

    //
    // Layout DQS in the tile #1
    //
    // Allocate the wires driven by DQS
    //
    sprintf(strVar, "ntDQS_GATE_TRAINING_STATUS_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntDQS_GATE_TRAINING_STATUS = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRDEL_OV_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntRDEL_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntWL_OV_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntWL_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntREAD_VALID_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntREAD_VALID = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntSAMPLE_CLK_DIV_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntSAMPLE_CLK_DIV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDQSI_DEL_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntDQSI_DEL = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntSAMPLE_CLK_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntSAMPLE_CLK = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntPROBE_CLK_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntPROBE_CLK = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntWCLK_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntWCLK = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntWCLK_DEL_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntWCLK_DEL = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntIFIFO_WADDR_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntIFIFO_WADDR[2:0] = wire *strVar[2:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntIFIFO_RADDR_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntIFIFO_RADDR[2:0] = wire *strVar[2:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout DQS_MUX in the tile #1
    //
    // Allocate the wires driven by DQS_MUX
    //
    sprintf(strVar, "ntDQS_MUX_DLL_CODE_%d_%d", sx+3, tile_1_sy+1);
    &wire ntRef_ntDQS_MUX_DLL_CODE[7:0] = wire *strVar[7:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the DQS_MUX @[3,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "DQS_MUX_%d_%d", sx+3, tile_1_sy+1);
    device DQS_MUX *strVar 
        port map (
                     DLL_CODE => ntRef_ntDQS_MUX_DLL_CODE
                 )
        @[sx+3, tile_1_sy+1];
        
    //
    // Layout IOMUX3 in the tile #1
    //
    // Allocate the wires driven by IOMUX3 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntIOMUX3_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX3 @[2,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+2, tile_1_sy+1);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX3_OUT
                 )
        @[sx+2,tile_1_sy+1];
        
    //
    // Layout IOMUX4 in the tile #1
    //
    // Allocate the wires driven by IOMUX4
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+2, tile_1_sy+2);
    &wire ntRef_ntIOMUX4_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX4 @[2,2] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+2, tile_1_sy+2);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX4_OUT
                 )
        @[sx+2,tile_1_sy+2];
    
    //
    // Instantiate the DQS @[3,0] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "DQS_%d_%d", sx+3, tile_1_sy);
    device DQS *strVar
        port map (
                     DQS_GATE_TRAINING_STATUS => ntRef_ntDQS_GATE_TRAINING_STATUS  ,
                     RDEL_OV                  => ntRef_ntRDEL_OV             ,
                     WL_OV                    => ntRef_ntWL_OV               ,
                     READ_VALID               => ntRef_ntREAD_VALID          ,
                     SAMPLE_CLK_DIV           => ntRef_ntSAMPLE_CLK_DIV      ,
                     DQSI_DEL                 => ntRef_ntDQSI_DEL            ,
                     SAMPLE_CLK               => ntRef_ntSAMPLE_CLK          ,
                     PROBE_CLK                => ntRef_ntPROBE_CLK           ,
                     WCLK                     => ntRef_ntWCLK                ,
                     WCLK_DEL                 => ntRef_ntWCLK_DEL            ,
                     IFIFO_WADDR              => ntRef_ntIFIFO_WADDR         ,
                     IFIFO_RADDR              => ntRef_ntIFIFO_RADDR         ,
                     
                     RDEL_CTRL[0]             => <wire A_IA0 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     RDEL_CTRL[1]             => <wire A_IA1 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     RDEL_CTRL[2]             => <wire A_IA2 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     DQS_GATE_CTRL[0]         => <wire A_IA3 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     DQS_GATE_CTRL[1]         => <wire A_IA4 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     DQS_GATE_CTRL[2]         => <wire A_IB0 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     DQS_GATE_CTRL[3]         => <wire A_IB1 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     READ_CLK_CTRL[0]         => <wire A_IB2 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     READ_CLK_CTRL[1]         => <wire A_IB3 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     READ_CLK_CTRL[2]         => <wire A_IB4 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     CLK1_STEP[0]             => <wire A_IC0 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     CLK1_STEP[1]             => <wire A_IC1 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     CLK1_STEP[2]             => <wire A_IC2 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     CLK1_STEP[3]             => <wire A_IC3 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     CLK1_STEP[4]             => <wire A_IC4 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     CLK1_STEP[5]             => <wire A_ID0 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     CLK1_STEP[6]             => <wire A_ID1 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     CLK1_STEP[7]             => <wire A_ID2 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     CLKGATE                  => <wire A_ID3 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     SYSCLK                   => <wire A_ICLK of <device CIM @[sx+3, tile_1_sy+2]>>  ,
                     RST                      => <wire A_IRS  of <device CIM @[sx+3, tile_1_sy+2]>>  ,
                     WL_CTRL[0]               => <wire S_IA0 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_CTRL[1]               => <wire S_IA1 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_CTRL[2]               => <wire S_IA2 of <device CIM @[sx+3, tile_1_sy+2]>>   ,            
                     DCC_CLK_CTRL[0]          => <wire S_IA3 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     DCC_CLK_CTRL[1]          => <wire S_IA4 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     DCC_CLK_CTRL[2]          => <wire S_IB0 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     IOCLK_SEL[0]             => <wire S_IB1 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     IOCLK_SEL[1]             => <wire S_IB2 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     IOCLK_SEL[2]             => <wire S_IB3 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     IOCLK_SEL[3]             => <wire S_IB4 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_STEP[0]               => <wire S_IC0 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_STEP[1]               => <wire S_IC1 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_STEP[2]               => <wire S_IC2 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_STEP[3]               => <wire S_IC3 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_STEP[4]               => <wire S_IC4 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_STEP[5]               => <wire S_ID0 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_STEP[6]               => <wire S_ID1 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_STEP[7]               => <wire S_ID2 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     SAMPLE_CLK_SLIP          => <wire S_ID3 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     
                     DLL_CODE                 => ntRef_ntDQS_MUX_DLL_CODE                            ,
                     IOCLK[0]                 => ntRef_ntIOMUX3_OUT                                  ,
                     IOCLK[1]                 => ntRef_ntIOMUX4_OUT
                 )
        @[sx+3,tile_1_sy];
        
    // Hook up the outputs of DQS (TILE 0) -> SRB (TILE 1)
    connect
        (                     
            <pin A_IY1 of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDQS_GATE_TRAINING_STATUS  ,
            <pin A_IY2 of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntREAD_VALID                ,
            <pin A_IY3 of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntRDEL_OV                   ,
            <pin A_IQ0 of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntWL_OV                     
        );
        
    //
    // Layout IOL2 in the tile #0
    //
    // Allocate the wires driven by IOL2
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", sx+1, tile_0_sy+2);                             
    &wire ntRef_ntIOL2_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", sx+1, tile_0_sy+2);                             
    &wire ntRef_ntIOL2_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_0_sy+2);                             
    &wire ntRef_ntIOL2_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_0_sy+2);                             
    &wire ntRef_ntIOL2_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 

    //
    // Layout IOB2 in the tile #0
    //
    // Allocate the wires driven by IOB3
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_0_sy+2);
    &wire ntRef_ntIOB2_DIN = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_0_sy+2);
    &wire ntRef_ntIOB2_DIFFI_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    //
    // Instantiate the IOL2 @[1,2] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", sx+1, tile_0_sy+2);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL2_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL2_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL2_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL2_RX_DATA         ,
                   DO              => ntRef_ntIOL2_DO              ,
                   TO              => ntRef_ntIOL2_TO              ,
                   ODDR_COUT       => ntRef_ntIOL2_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL2_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL2_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL2_TO_OUT          ,

                   TX_DATA[0]      => <wire S_IA0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,      //IOL3 <- SIB (tile 1)
                   TX_DATA[1]      => <wire S_IA1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[2]      => <wire S_IA2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[3]      => <wire S_IA3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[4]      => <wire S_IA4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[5]      => <wire S_IB0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[0]      => <wire S_IB1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[1]      => <wire S_IB2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[2]      => <wire S_IB3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[3]      => <wire S_IB4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_STS_CLR     => <wire S_IC0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[0]   => <wire S_IC1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[1]   => <wire S_IC2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[2]   => <wire S_IC3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[0]     => <wire S_IC4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[1]     => <wire S_ID0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SLIP            => <wire S_ID1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SYSCLK          => <wire S_ICLK of <device CIM @[sx+3, tile_0_sy+2]>>   ,
                   CE              => <wire S_ICE of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   LRS             => <wire S_IRS of <device CIM @[sx+3, tile_0_sy+2]>>    ,

                   DIN             => ntRef_ntIOB2_DIN                                     ,  // IOL3 <- IOB3 (Tile 1) 
                   IOCLK           => ntRef_ntIOMUX2_OUT                                      // IOL2 <- IOMUX2

                 )
        @[sx+1,tile_0_sy+2];

    // Hook up the outputs of IOL2 -> SRB (TILE 1)
    connect
        (
            <pin S_IY0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_IODLY_OV       , 
            <pin S_IY1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA_DD       ,
            <pin S_IY2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[0]    ,
            <pin S_IY3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[1]    ,
            <pin S_IQ0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[2]    ,
            <pin S_IQ1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[3]    ,
            <pin S_IQ2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[4]    ,
            <pin S_IQ3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[5]    ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntIOL2_DPI_STS[0]     ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntIOL2_DPI_STS[1]
        );

    //
    // Instantiate the IOB2 @[2,2] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_B_%d_%d", sx+2, tile_0_sy+2);
    device IOB_B *strVar
        port map (
                   DO           => ntRef_ntIOL2_DO     ,   //Input from IOL3 (Tile 1)
                   TO           => ntRef_ntIOL2_TO      ,
                   
                   DIN          => ntRef_ntIOB2_DIN      ,   //output
                   DIFFI_OUT       => ntRef_ntIOB2_DIFFI_OUT
                 )
        @[sx+2,tile_0_sy+2];
    
    //Hook up IOB_A <-> IOB_B, IOL_A <-> IOL_B
    connect
        (
            <pin DIFFI_IN of <device IOB_A @([tx*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1])>>     => <wire DIFFI_OUT of <device IOB_B @[tx*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2]>>     ,
            <pin DIFFO_IN of <device IOB_B @([tx*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2])>>     => <wire DIFFO_OUT of <device IOB_A @[tx*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1]>>     ,
            <pin DIFFI_IN of <device IOB_B @([tx*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2])>>     => <wire DIFFI_OUT of <device IOB_A @[tx*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1]>>     ,
                        
            <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>      => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>    ,
            <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>      => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>    ,
            
            <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>      => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2]>>    ,
            <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>      => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2]>>    ,
            
            <pin DO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>      => <wire DO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>    ,
            <pin TO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>      => <wire TO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>> 
            
            
        );

};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-DQS-2CIM block tiles. 
             Each IO block takes the size of 2 tiles. 
             
             ---------|---------|---------|---------    
                       IOL2[1,2] IOB2[2,2]  C[3,2]
               V[0,1]  IOL1[1,1] IOB1[2,1]  IOMUX2[3,1]  
               G[0,0]  R[1,0]    I[2,0]     IOMUX1[3,0]          TILE 0   
             ---------|---------|---------|---------      
                                            C[3,2]
               V[0,1]                       DQS_MUX[3,1]
               G[0,0]  R[1,0]    I[2,0]     DQS[3,0]             TILE 1 
             ---------|---------|---------|---------
                                                                           
              
            ]

  Revision History:

*****************************************************************************************/
function place_io_dqs_ff_2cim_v_tile ( unsigned int tx, ty)
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // The wires are spread out in 2 tiles. Pre-calculate the lower-left corner of all 2 tiles
    unsigned int tile_0_sy =  ty              * TILE_NUM_SITE_Y;
    unsigned int tile_1_sy = (ty - 1)         * TILE_NUM_SITE_Y;
    
    //
    // Layout IOL1 in the tile #0
    //
    // Allocate the wires driven by IOL1
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", sx+1, tile_0_sy+1);                             
    &wire ntRef_ntIOL1_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", sx+1, tile_0_sy+1);                             
    &wire ntRef_ntIOL1_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_0_sy+1);                             
    &wire ntRef_ntIOL1_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_0_sy+1);                             
    &wire ntRef_ntIOL1_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    //
    // Layout IOB1 in the tile #0
    //
    // Allocate the wires driven by IOB1 
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_0_sy+1);
    &wire ntRef_ntIOB1_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_0_sy+1);
    &wire ntRef_ntIOB1_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX1 in the tile #0
    //
    // Allocate the wires driven by IOMUX1 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+3, tile_0_sy);
    &wire ntRef_ntIOMUX1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX1 @[3,0] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+3, tile_0_sy);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX1_OUT
                 )
        @[sx+3,tile_0_sy];
        
        
    //
    // Layout IOMUX2 in the tile #0
    //
    // Allocate the wires driven by IOMUX2 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+3, tile_0_sy+1);
    &wire ntRef_ntIOMUX2_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX2 @[3,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+3, tile_0_sy+1);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX2_OUT
                 )
        @[sx+3,tile_0_sy+1];
    
    //
    // Instantiate the IOL1 @[1,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", sx+1, tile_0_sy+1);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL1_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL1_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL1_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL1_RX_DATA         ,
                   DO              => ntRef_ntIOL1_DO              ,
                   TO              => ntRef_ntIOL1_TO              ,
                   ODDR_COUT       => ntRef_ntIOL1_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL1_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL1_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL1_TO_OUT          ,
                   
                   TX_DATA[0]       => <wire A_IA0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,      // IOL1 <- SIB
                   TX_DATA[1]       => <wire A_IA1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[2]       => <wire A_IA2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[3]       => <wire A_IA3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[4]       => <wire A_IA4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[5]       => <wire A_IB0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[0]       => <wire A_IB1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[1]       => <wire A_IB2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[2]       => <wire A_IB3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[3]       => <wire A_IB4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_STS_CLR      => <wire A_IC0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[0]    => <wire A_IC1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[1]    => <wire A_IC2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[2]    => <wire A_IC3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[0]      => <wire A_IC4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[1]      => <wire A_ID0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SLIP             => <wire A_ID1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SYSCLK           => <wire A_ICLK of <device CIM @[sx+3, tile_0_sy+2]>>   ,
                   CE               => <wire A_ICE of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   LRS              => <wire A_IRS of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   
                   DIN              => ntRef_ntIOB1_DIN                                     ,  // IOL1 <- IOB1
                   IOCLK            => ntRef_ntIOMUX1_OUT                                      // IOL1 <- IOMUX1
                 )
        @[sx+1,tile_0_sy+1];
        
    // Hook up the outputs of IOL1 -> SRB (TILE 0)
    connect
        (
            <pin A_IY0 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_IODLY_OV      , 
            <pin A_IY1 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA_DD      ,
            <pin A_IY2 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[0]   ,
            <pin A_IY3 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[1]   ,
            <pin A_IQ0 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[2]   ,
            <pin A_IQ1 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[3]   ,
            <pin A_IQ2 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[4]   ,
            <pin A_IQ3 of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[5]   ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_DPI_STS[0]  ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_DPI_STS[1]
        );

    //
    // Instantiate the IOB1 @[2,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LA_%d_%d", sx+2, tile_0_sy+1);
    device IOB_LA *strVar
        port map (
                   DO         => ntRef_ntIOL1_DO          ,   //Input from IOL1 (Tile 0)
                   TO         => ntRef_ntIOL1_TO          ,
                   
                   DIN        => ntRef_ntIOB1_DIN         ,   //output
                   DIFFI_OUT  => ntRef_ntIOB1_DIFFI_OUT
                 )
        @[sx+2,tile_0_sy+1];

    //
    // Layout DQS in the tile #1
    //
    // Allocate the wires driven by DQS
    //
    sprintf(strVar, "ntDQS_GATE_TRAINING_STATUS_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntDQS_GATE_TRAINING_STATUS = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRDEL_OV_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntRDEL_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntWL_OV_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntWL_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntREAD_VALID_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntREAD_VALID = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntSAMPLE_CLK_DIV_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntSAMPLE_CLK_DIV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDQSI_DEL_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntDQSI_DEL = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntSAMPLE_CLK_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntSAMPLE_CLK = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntPROBE_CLK_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntPROBE_CLK = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntWCLK_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntWCLK = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntWCLK_DEL_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntWCLK_DEL = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntIFIFO_WADDR_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntIFIFO_WADDR[2:0] = wire *strVar[2:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntIFIFO_RADDR_%d_%d", sx+3, tile_1_sy);
    &wire ntRef_ntIFIFO_RADDR[2:0] = wire *strVar[2:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout DQS_MUX in the tile #1
    //
    // Allocate the wires driven by DQS_MUX
    //
    sprintf(strVar, "ntDQS_MUX_DLL_CODE_%d_%d", sx+3, tile_1_sy+1);
    &wire ntRef_ntDQS_MUX_DLL_CODE[7:0] = wire *strVar[7:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the DQS_MUX @[3,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "DQS_MUX_%d_%d", sx+3, tile_1_sy+1);
    device DQS_MUX *strVar 
        port map (
                     DLL_CODE => ntRef_ntDQS_MUX_DLL_CODE
                 )
        @[sx+3, tile_1_sy+1];
        
    //
    // Layout IOMUX3 in the tile #1
    //
    // Allocate the wires driven by IOMUX3 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntIOMUX3_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX3 @[2,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+2, tile_1_sy+1);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX3_OUT
                 )
        @[sx+2,tile_1_sy+1];
        
    //
    // Layout IOMUX4 in the tile #1
    //
    // Allocate the wires driven by IOMUX4
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+2, tile_1_sy+2);
    &wire ntRef_ntIOMUX4_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX4 @[2,2] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+2, tile_1_sy+2);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX4_OUT
                 )
        @[sx+2,tile_1_sy+2];
    
    //
    // Instantiate the DQS @[3,0] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "DQS_%d_%d", sx+3, tile_1_sy);
    device DQS *strVar
        port map (
                     DQS_GATE_TRAINING_STATUS => ntRef_ntDQS_GATE_TRAINING_STATUS  ,
                     RDEL_OV                  => ntRef_ntRDEL_OV             ,
                     WL_OV                    => ntRef_ntWL_OV               ,
                     READ_VALID               => ntRef_ntREAD_VALID          ,
                     SAMPLE_CLK_DIV           => ntRef_ntSAMPLE_CLK_DIV      ,
                     DQSI_DEL                 => ntRef_ntDQSI_DEL            ,
                     SAMPLE_CLK               => ntRef_ntSAMPLE_CLK          ,
                     PROBE_CLK                => ntRef_ntPROBE_CLK           ,
                     WCLK                     => ntRef_ntWCLK                ,
                     WCLK_DEL                 => ntRef_ntWCLK_DEL            ,
                     IFIFO_WADDR              => ntRef_ntIFIFO_WADDR         ,
                     IFIFO_RADDR              => ntRef_ntIFIFO_RADDR         ,
                     
                     RDEL_CTRL[0]             => <wire A_IA0 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     RDEL_CTRL[1]             => <wire A_IA1 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     RDEL_CTRL[2]             => <wire A_IA2 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     DQS_GATE_CTRL[0]         => <wire A_IA3 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     DQS_GATE_CTRL[1]         => <wire A_IA4 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     DQS_GATE_CTRL[2]         => <wire A_IB0 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     DQS_GATE_CTRL[3]         => <wire A_IB1 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     READ_CLK_CTRL[0]         => <wire A_IB2 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     READ_CLK_CTRL[1]         => <wire A_IB3 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     READ_CLK_CTRL[2]         => <wire A_IB4 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     CLK1_STEP[0]             => <wire A_IC0 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     CLK1_STEP[1]             => <wire A_IC1 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     CLK1_STEP[2]             => <wire A_IC2 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     CLK1_STEP[3]             => <wire A_IC3 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     CLK1_STEP[4]             => <wire A_IC4 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     CLK1_STEP[5]             => <wire A_ID0 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     CLK1_STEP[6]             => <wire A_ID1 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     CLK1_STEP[7]             => <wire A_ID2 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     CLKGATE                  => <wire A_ID3 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     SYSCLK                   => <wire A_ICLK of <device CIM @[sx+3, tile_1_sy+2]>>  ,
                     RST                      => <wire A_IRS  of <device CIM @[sx+3, tile_1_sy+2]>>  ,
                     WL_CTRL[0]               => <wire S_IA0 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_CTRL[1]               => <wire S_IA1 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_CTRL[2]               => <wire S_IA2 of <device CIM @[sx+3, tile_1_sy+2]>>   ,            
                     DCC_CLK_CTRL[0]          => <wire S_IA3 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     DCC_CLK_CTRL[1]          => <wire S_IA4 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     DCC_CLK_CTRL[2]          => <wire S_IB0 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     IOCLK_SEL[0]             => <wire S_IB1 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     IOCLK_SEL[1]             => <wire S_IB2 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     IOCLK_SEL[2]             => <wire S_IB3 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     IOCLK_SEL[3]             => <wire S_IB4 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_STEP[0]               => <wire S_IC0 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_STEP[1]               => <wire S_IC1 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_STEP[2]               => <wire S_IC2 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_STEP[3]               => <wire S_IC3 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_STEP[4]               => <wire S_IC4 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_STEP[5]               => <wire S_ID0 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_STEP[6]               => <wire S_ID1 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     WL_STEP[7]               => <wire S_ID2 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     SAMPLE_CLK_SLIP          => <wire S_ID3 of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                     
                     DLL_CODE                 => ntRef_ntDQS_MUX_DLL_CODE                            ,
                     IOCLK[0]                 => ntRef_ntIOMUX3_OUT                                  ,
                     IOCLK[1]                 => ntRef_ntIOMUX4_OUT
                 )
        @[sx+3,tile_1_sy];
        
    // Hook up the outputs of DQS (TILE 0) -> SRB (TILE 1)
    connect
        (                     
            <pin A_IY1 of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntDQS_GATE_TRAINING_STATUS  ,
            <pin A_IY2 of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntREAD_VALID                ,
            <pin A_IY3 of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntRDEL_OV                   ,
            <pin A_IQ0 of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntWL_OV                     
        );
        
    //
    // Layout IOL2 in the tile #0
    //
    // Allocate the wires driven by IOL2
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", sx+1, tile_0_sy+2);                             
    &wire ntRef_ntIOL2_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", sx+1, tile_0_sy+2);                             
    &wire ntRef_ntIOL2_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_0_sy+2);                             
    &wire ntRef_ntIOL2_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_0_sy+2);                             
    &wire ntRef_ntIOL2_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 

    //
    // Layout IOB2 in the tile #0
    //
    // Allocate the wires driven by IOB3
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_0_sy+2);
    &wire ntRef_ntIOB2_DIN = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_0_sy+2);
    &wire ntRef_ntIOB2_DIFFI_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    //
    // Instantiate the IOL2 @[1,2] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", sx+1, tile_0_sy+2);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL2_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL2_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL2_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL2_RX_DATA         ,
                   DO              => ntRef_ntIOL2_DO              ,
                   TO              => ntRef_ntIOL2_TO              ,
                   ODDR_COUT       => ntRef_ntIOL2_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL2_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL2_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL2_TO_OUT          ,

                   TX_DATA[0]      => <wire S_IA0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,      //IOL3 <- SIB (tile 1)
                   TX_DATA[1]      => <wire S_IA1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[2]      => <wire S_IA2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[3]      => <wire S_IA3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[4]      => <wire S_IA4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TX_DATA[5]      => <wire S_IB0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[0]      => <wire S_IB1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[1]      => <wire S_IB2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[2]      => <wire S_IB3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL[3]      => <wire S_IB4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_STS_CLR     => <wire S_IC0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[0]   => <wire S_IC1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[1]   => <wire S_IC2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[2]   => <wire S_IC3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[0]     => <wire S_IC4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   DPI_CTRL[1]     => <wire S_ID0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SLIP            => <wire S_ID1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SYSCLK          => <wire S_ICLK of <device CIM @[sx+3, tile_0_sy+2]>>   ,
                   CE              => <wire S_ICE of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   LRS             => <wire S_IRS of <device CIM @[sx+3, tile_0_sy+2]>>    ,

                   DIN             => ntRef_ntIOB2_DIN                                     ,  // IOL3 <- IOB3 (Tile 1) 
                   IOCLK           => ntRef_ntIOMUX2_OUT                                      // IOL2 <- IOMUX2

                 )
        @[sx+1,tile_0_sy+2];

    // Hook up the outputs of IOL3 -> SRB (TILE 1)
    connect
        (
            <pin S_IY0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_IODLY_OV      , 
            <pin S_IY1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA_DD    ,
            <pin S_IY2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[0]    ,
            <pin S_IY3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[1]    ,
            <pin S_IQ0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[2]    ,
            <pin S_IQ1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[3]    ,
            <pin S_IQ2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[4]    ,
            <pin S_IQ3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[5]    ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntIOL2_DPI_STS[0]    ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntIOL2_DPI_STS[1]
        );

    //
    // Instantiate the IOB2 @[2,2] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LB_%d_%d", sx+2, tile_0_sy+2);
    device IOB_LB *strVar
        port map (
                   DO           => ntRef_ntIOL2_DO     ,   //Input from IOL3 (Tile 1)
                   TO           => ntRef_ntIOL2_TO      ,
                   
                   DIN          => ntRef_ntIOB2_DIN      ,   //output
                   DIFFI_OUT    => ntRef_ntIOB2_DIFFI_OUT
                 )
        @[sx+2,tile_0_sy+2];
    
    //Hook up IOB_A <-> IOB_B, IOL_A <-> IOL_B
    connect
        (
            <pin DIFFI_IN of <device IOB_LA @([tx*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1])>>     => <wire DIFFI_OUT of <device IOB_LB @[tx*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2]>>     ,
            <pin DIFFI_IN of <device IOB_LB @([tx*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2])>>     => <wire DIFFI_OUT of <device IOB_LA @[tx*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1]>>     ,
                        
            <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>      => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>    ,
            <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>      => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>    ,
            
            <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>      => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2]>>    ,
            <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1])>>      => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2]>>    ,
            
            <pin DO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>      => <wire DO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>>    ,
            <pin TO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+2])>>      => <wire TO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, ty*TILE_NUM_SITE_Y+1]>> 
        );

};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-1CIM block tiles. Each IO block takes
             the size of 1 tiles. (1CIM - 1IO) (EAST EDGE)
             
             ---------|---------|---------|---------    
                                            C[3,2]
                V[0,1]  IOL1[1,1] IOB1[2,1]
                G[0,0]  R[1,0]    I[2,0]    IOMUX1[3,0]       TILE 0   
             ---------|---------|---------|---------                                                                                 
              
            ]

  Revision History:

*****************************************************************************************/
function place_io_1cim_v_u_tile ( unsigned int tx, ty)
{    
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    //
    // Layout IOL1 in the tile #0
    //
    // Allocate the wires driven by IOL1
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, sy+1);
    &wire ntRef_ntIOL1_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, sy+1);
    &wire ntRef_ntIOL1_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, sy+1);
    &wire ntRef_ntIOL1_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, sy+1);
    &wire ntRef_ntIOL1_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, sy+1);
    &wire ntRef_ntIOL1_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, sy+1);
    &wire ntRef_ntIOL1_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", sx+1, sy+1);                             
    &wire ntRef_ntIOL1_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", sx+1, sy+1);                             
    &wire ntRef_ntIOL1_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, sy+1);                             
    &wire ntRef_ntIOL1_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, sy+1);                             
    &wire ntRef_ntIOL1_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 

    //
    // Layout IOB1 in the tile #0
    //
    // Allocate the wires driven by IOB1
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, sy+1);
    &wire ntRef_ntIOB1_DIN = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFO_OUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntIOB1_DIFFO_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntIOB1_DIFFI_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX1 in the tile #0
    //
    // Allocate the wires driven by IOMUX1 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+3, sy);
    &wire ntRef_ntIOMUX1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX1 @[3,0] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+3, sy);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX1_OUT
                 )
        @[sx+3,sy];
           
    //
    // Instantiate the IOL1 @[1,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", sx+1, sy+1);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL1_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL1_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL1_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL1_RX_DATA         ,
                   DO              => ntRef_ntIOL1_DO              ,
                   TO              => ntRef_ntIOL1_TO              ,
                   ODDR_COUT       => ntRef_ntIOL1_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL1_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL1_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL1_TO_OUT          ,
                   
                   TX_DATA[0]       => <wire A_IA0 of <device CIM @[sx+3, sy+2]>>    ,  //IOL1 <- SIB (tile 0)
                   TX_DATA[1]       => <wire A_IA1 of <device CIM @[sx+3, sy+2]>>    ,
                   TX_DATA[2]       => <wire A_IA2 of <device CIM @[sx+3, sy+2]>>    ,
                   TX_DATA[3]       => <wire A_IA3 of <device CIM @[sx+3, sy+2]>>    ,
                   TX_DATA[4]       => <wire A_IA4 of <device CIM @[sx+3, sy+2]>>    ,
                   TX_DATA[5]       => <wire A_IB0 of <device CIM @[sx+3, sy+2]>>    ,
                   TS_CTRL[0]       => <wire A_IB1 of <device CIM @[sx+3, sy+2]>>    ,
                   TS_CTRL[1]       => <wire A_IB2 of <device CIM @[sx+3, sy+2]>>    ,
                   TS_CTRL[2]       => <wire A_IB3 of <device CIM @[sx+3, sy+2]>>    ,
                   TS_CTRL[3]       => <wire A_IB4 of <device CIM @[sx+3, sy+2]>>    ,
                   DPI_STS_CLR      => <wire A_IC0 of <device CIM @[sx+3, sy+2]>>    ,
                   IODLY_CTRL[0]    => <wire A_IC1 of <device CIM @[sx+3, sy+2]>>    ,
                   IODLY_CTRL[1]    => <wire A_IC2 of <device CIM @[sx+3, sy+2]>>    ,
                   IODLY_CTRL[2]    => <wire A_IC3 of <device CIM @[sx+3, sy+2]>>    ,
                   DPI_CTRL[0]      => <wire A_IC4 of <device CIM @[sx+3, sy+2]>>    ,
                   DPI_CTRL[1]      => <wire A_ID0 of <device CIM @[sx+3, sy+2]>>    ,
                   SLIP             => <wire A_ID1 of <device CIM @[sx+3, sy+2]>>    ,
                   SYSCLK           => <wire A_ICLK of <device CIM @[sx+3, sy+2]>>   ,
                   CE               => <wire A_ICE of <device CIM @[sx+3, sy+2]>>    ,
                   LRS              => <wire A_IRS of <device CIM @[sx+3, sy+2]>>    ,

                   DIN              => ntRef_ntIOB1_DIN                              , // IOL1 <- IOB1 (Tile 0) 
                   IOCLK            => ntRef_ntIOMUX1_OUT                              // IOL1 <- IOMUX1

                 )
        @[sx+1,sy+1];

    // Hook up the outputs of IOL1 -> SRB (TILE 0)
    connect
        (
            <pin A_IY0   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_IODLY_OV     ,
            <pin A_IY1   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA_DD     ,
            <pin A_IY2   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[0]  ,
            <pin A_IY3   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[1]  ,
            <pin A_IQ0   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[2]  ,
            <pin A_IQ1   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[3]  ,
            <pin A_IQ2   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[4]  ,
            <pin A_IQ3   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[5]  ,
            <pin S_IY6AB of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_DPI_STS[0]   ,
            <pin S_IY6CD of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_DPI_STS[1]
        );

    //
    // Instantiate the IOB1 @[2,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_A_%d_%d", sx+2, sy+1);
    device IOB_A *strVar
        port map (
                   DO         => ntRef_ntIOL1_DO        ,   //Input from IOL1 (Tile 0)
                   TO         => ntRef_ntIOL1_TO        ,
                   
                   DIN        => ntRef_ntIOB1_DIN       ,   //output
                   DIFFO_OUT  => ntRef_ntIOB1_DIFFO_OUT ,
                   DIFFI_OUT  => ntRef_ntIOB1_DIFFI_OUT
                 )
        @[sx+2,sy+1];
};

/**VFunction******************************************************************************

  Author    [xiawei]

  Abstract  [This function places the devices within IO-1CIM block tiles. Each IO block takes
             the size of 1 tiles. (1CIM - 1IO) 
             
             ---------|---------|---------|---------    
                        IOL1[1,2] IOB1[2,2] C[3,2]
                V[0,1]                      IOMUX1[3,1]
                G[0,0]  R[1,0]    I[2,0]                 TILE 0  
             ---------|---------|---------|---------    
            ]

  Revision History:

*****************************************************************************************/
function place_io_1cim_v_b_tile ( unsigned int tx, ty)
{    
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
        
    //
    // Layout IOL1 in the tile #pre
    //
    // Allocate the wires driven by IOL1
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, sy+2);
    &wire ntRef_ntIOL1_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, sy+2);
    &wire ntRef_ntIOL1_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, sy+2);
    &wire ntRef_ntIOL1_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, sy+2);
    &wire ntRef_ntIOL1_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, sy+2);
    &wire ntRef_ntIOL1_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, sy+2);
    &wire ntRef_ntIOL1_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", sx+1, sy+2);                             
    &wire ntRef_ntIOL1_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", sx+1, sy+2);                             
    &wire ntRef_ntIOL1_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, sy+2);                             
    &wire ntRef_ntIOL1_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, sy+2);                             
    &wire ntRef_ntIOL1_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 

    //
    // Layout IOB1 in the tile #pre
    //
    // Allocate the wires driven by IOB1
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, sy+2);
    &wire ntRef_ntIOB1_DIN = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, sy+2);
    &wire ntRef_ntIOB1_DIFFI_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX1 in the tile #pre
    //
    // Allocate the wires driven by IOMUX1 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+3, sy+1);
    &wire ntRef_ntIOMUX1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX1 @[3,1] in tile #pre. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+3, sy+1);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX1_OUT
                 )
        @[sx+3,sy+1];
    
       
    //
    // Instantiate the IOL1 @[1,2] in tile #pre. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", sx+1, sy+2);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL1_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL1_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL1_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL1_RX_DATA         ,
                   DO              => ntRef_ntIOL1_DO              ,
                   TO              => ntRef_ntIOL1_TO              ,
                   ODDR_COUT       => ntRef_ntIOL1_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL1_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL1_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL1_TO_OUT          ,

                   TX_DATA[0]       => <wire A_IA0 of <device CIM @[sx+3, sy+2]>>     ,    //IOL1 <- SIB (tile 0)
                   TX_DATA[1]       => <wire A_IA1 of <device CIM @[sx+3, sy+2]>>     ,
                   TX_DATA[2]       => <wire A_IA2 of <device CIM @[sx+3, sy+2]>>     ,
                   TX_DATA[3]       => <wire A_IA3 of <device CIM @[sx+3, sy+2]>>     ,
                   TX_DATA[4]       => <wire A_IA4 of <device CIM @[sx+3, sy+2]>>     ,
                   TX_DATA[5]       => <wire A_IB0 of <device CIM @[sx+3, sy+2]>>     ,
                   TS_CTRL[0]       => <wire A_IB1 of <device CIM @[sx+3, sy+2]>>     ,
                   TS_CTRL[1]       => <wire A_IB2 of <device CIM @[sx+3, sy+2]>>     ,
                   TS_CTRL[2]       => <wire A_IB3 of <device CIM @[sx+3, sy+2]>>     ,
                   TS_CTRL[3]       => <wire A_IB4 of <device CIM @[sx+3, sy+2]>>     ,
                   DPI_STS_CLR      => <wire A_IC0 of <device CIM @[sx+3, sy+2]>>     ,
                   IODLY_CTRL[0]    => <wire A_IC1 of <device CIM @[sx+3, sy+2]>>     ,
                   IODLY_CTRL[1]    => <wire A_IC2 of <device CIM @[sx+3, sy+2]>>     ,
                   IODLY_CTRL[2]    => <wire A_IC3 of <device CIM @[sx+3, sy+2]>>     ,
                   DPI_CTRL[0]      => <wire A_IC4 of <device CIM @[sx+3, sy+2]>>     ,
                   DPI_CTRL[1]      => <wire A_ID0 of <device CIM @[sx+3, sy+2]>>     ,
                   SLIP             => <wire A_ID1 of <device CIM @[sx+3, sy+2]>>     ,
                   SYSCLK           => <wire A_ICLK of <device CIM @[sx+3, sy+2]>>    ,
                   CE               => <wire A_ICE of <device CIM @[sx+3, sy+2]>>     ,
                   LRS              => <wire A_IRS of <device CIM @[sx+3, sy+2]>>     ,

                   DIN              => ntRef_ntIOB1_DIN                               , // IOL1 <- IOB1 (Tile 0) 
                   IOCLK            => ntRef_ntIOMUX1_OUT                                // IOL1 <- IOMUX1

                 )
        @[sx+1,sy+2];

    // Hook up the outputs of IOL1 -> SRB (TILE 0)
    connect
        (            
            <pin A_IY0   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_IODLY_OV      ,
            <pin A_IY1   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA_DD      ,
            <pin A_IY2   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[0]   ,
            <pin A_IY3   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[1]   ,
            <pin A_IQ0   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[2]   ,
            <pin A_IQ1   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[3]   ,
            <pin A_IQ2   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[4]   ,
            <pin A_IQ3   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[5]   ,
            <pin S_IY6AB of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_DPI_STS[0]    ,
            <pin S_IY6CD of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_DPI_STS[1]
        );

    //
    // Instantiate the IOB1 @[2,2] in tile #pre. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LB_%d_%d", sx+2, sy+2);
    device IOB_LB *strVar
        port map (
                   DO         => ntRef_ntIOL1_DO      ,   //Input from IOL1 (Tile 0)
                   TO         => ntRef_ntIOL1_TO       ,

                   DIN        => ntRef_ntIOB1_DIN       ,   //output
                   DIFFI_OUT     => ntRef_ntIOB1_DIFFI_OUT
                 )
        @[sx+2,sy+2];
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-1CIM block tiles. Each IO block takes
             the size of 1 tiles. (1CIM - 1IO)  (EAST EDGE)
             
             ---------|---------|---------|---------    
                        IOL1[1,2] IOB1[2,2] C[3,2]
                V[0,1]                      IOMUX1[3,1]
                G[0,0]  R[1,0]    I[2,0]                 TILE PRE  
             ---------|---------|---------|---------    
                                            C[3,2]
                V[0,1]        
                G[0,0]  R[1,0]    I[2,0]                 TILE 0   
             ---------|---------|---------|---------                                                                                 
              
            ]

  Revision History:

*****************************************************************************************/
function place_io_1cim_v_d_tile ( unsigned int tx, ty)
{    
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    unsigned int tile_pre_sy = (ty + 1)         * TILE_NUM_SITE_Y;
        
    //
    // Layout IOL1 in the tile #pre
    //
    // Allocate the wires driven by IOL1
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_RX_DATA[5:0] = wire *strVar[5:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntODDR_COUT_%d_%d", sx+1, tile_pre_sy+2);                             
    &wire ntRef_ntIOL1_ODDR_COUT[16:0] = wire *strVar[16:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntIDDR_COUT_%d_%d", sx+1, tile_pre_sy+2);                             
    &wire ntRef_ntIOL1_IDDR_COUT[6:0] = wire *strVar[6:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;  
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_pre_sy+2);                             
    &wire ntRef_ntIOL1_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_pre_sy+2);                             
    &wire ntRef_ntIOL1_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ; 

    //
    // Layout IOB1 in the tile #pre
    //
    // Allocate the wires driven by IOB1
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_pre_sy+2);
    &wire ntRef_ntIOB1_DIN = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_pre_sy+2);
    &wire ntRef_ntIOB1_DIFFI_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOMUX1 in the tile #pre
    //
    // Allocate the wires driven by IOMUX1 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+3, tile_pre_sy+1);
    &wire ntRef_ntIOMUX1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the IOMUX1 @[3,1] in tile #pre. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOMUX_%d_%d", sx+3, tile_pre_sy+1);
    device IOMUX *strVar
        port map (
                     OUT => ntRef_ntIOMUX1_OUT
                 )
        @[sx+3,tile_pre_sy+1];
    
       
    //
    // Instantiate the IOL1 @[1,2] in tile #pre. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_%d_%d", sx+1, tile_pre_sy+2);
    device IOL *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL1_IODLY_OV        ,           // output
                   DPI_STS         => ntRef_ntIOL1_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL1_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL1_RX_DATA         ,
                   DO              => ntRef_ntIOL1_DO              ,
                   TO              => ntRef_ntIOL1_TO              ,
                   ODDR_COUT       => ntRef_ntIOL1_ODDR_COUT       ,
                   IDDR_COUT       => ntRef_ntIOL1_IDDR_COUT       ,
                   DO_OUT          => ntRef_ntIOL1_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL1_TO_OUT          ,

                   TX_DATA[0]       => <wire A_IA0 of <device CIM @[sx+3, sy+2]>>     ,    //IOL1 <- SIB (tile 0)
                   TX_DATA[1]       => <wire A_IA1 of <device CIM @[sx+3, sy+2]>>     ,
                   TX_DATA[2]       => <wire A_IA2 of <device CIM @[sx+3, sy+2]>>     ,
                   TX_DATA[3]       => <wire A_IA3 of <device CIM @[sx+3, sy+2]>>     ,
                   TX_DATA[4]       => <wire A_IA4 of <device CIM @[sx+3, sy+2]>>     ,
                   TX_DATA[5]       => <wire A_IB0 of <device CIM @[sx+3, sy+2]>>     ,
                   TS_CTRL[0]       => <wire A_IB1 of <device CIM @[sx+3, sy+2]>>     ,
                   TS_CTRL[1]       => <wire A_IB2 of <device CIM @[sx+3, sy+2]>>     ,
                   TS_CTRL[2]       => <wire A_IB3 of <device CIM @[sx+3, sy+2]>>     ,
                   TS_CTRL[3]       => <wire A_IB4 of <device CIM @[sx+3, sy+2]>>     ,
                   DPI_STS_CLR      => <wire A_IC0 of <device CIM @[sx+3, sy+2]>>     ,
                   IODLY_CTRL[0]    => <wire A_IC1 of <device CIM @[sx+3, sy+2]>>     ,
                   IODLY_CTRL[1]    => <wire A_IC2 of <device CIM @[sx+3, sy+2]>>     ,
                   IODLY_CTRL[2]    => <wire A_IC3 of <device CIM @[sx+3, sy+2]>>     ,
                   DPI_CTRL[0]      => <wire A_IC4 of <device CIM @[sx+3, sy+2]>>     ,
                   DPI_CTRL[1]      => <wire A_ID0 of <device CIM @[sx+3, sy+2]>>     ,
                   SLIP             => <wire A_ID1 of <device CIM @[sx+3, sy+2]>>     ,
                   SYSCLK           => <wire A_ICLK of <device CIM @[sx+3, sy+2]>>    ,
                   CE               => <wire A_ICE of <device CIM @[sx+3, sy+2]>>     ,
                   LRS              => <wire A_IRS of <device CIM @[sx+3, sy+2]>>     ,

                   DIN              => ntRef_ntIOB1_DIN                               , // IOL1 <- IOB1 (Tile 0) 
                   IOCLK            => ntRef_ntIOMUX1_OUT                                // IOL1 <- IOMUX1

                 )
        @[sx+1,tile_pre_sy+2];

    // Hook up the outputs of IOL1 -> SRB (TILE 0)
    connect
        (            
            <pin A_IY0   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_IODLY_OV      ,
            <pin A_IY1   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA_DD      ,
            <pin A_IY2   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[0]   ,
            <pin A_IY3   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[1]   ,
            <pin A_IQ0   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[2]   ,
            <pin A_IQ1   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[3]   ,
            <pin A_IQ2   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[4]   ,
            <pin A_IQ3   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[5]   ,
            <pin A_IY6AB of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_DPI_STS[0]    ,
            <pin A_IY6CD of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_DPI_STS[1]
        );

    //
    // Instantiate the IOB1 @[2,2] in tile #pre. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LB_%d_%d", sx+2, tile_pre_sy+2);
    device IOB_LB *strVar
        port map (
                   DO         => ntRef_ntIOL1_DO      ,   //Input from IOL1 (Tile 0)
                   TO         => ntRef_ntIOL1_TO       ,

                   DIN        => ntRef_ntIOB1_DIN       ,   //output
                   DIFFI_OUT     => ntRef_ntIOB1_DIFFI_OUT
                 )
        @[sx+2,tile_pre_sy+2];
};





/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-3CIM block tiles. Each IO block takes
             the size of 3 tiles. (North-EAST corner)

            ]

  Revision History:

*****************************************************************************************/
function place_io_3cim_4io_v_u_tile ( unsigned int tx, ty )
{
    place_io_1cim_v_u_tile (tx, ty);
    place_io_bab_tff_2cim_v_tile (tx, ty-1);

    const unsigned int r_tile_y0[] = { ty };
    
    unsigned int tile_y;
    
    foreach tile_y ( r_tile_y0 )
    {
        connect
            (
                <pin DIFFI_IN of <device IOB_A @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1])>>   => <wire DIFFI_OUT of <device IOB_B @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                <pin DIFFO_IN of <device IOB_B @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2])>>   => <wire DIFFO_OUT of <device IOB_A @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin DIFFI_IN of <device IOB_B @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2])>>   => <wire DIFFI_OUT of <device IOB_A @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                                
                <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>    => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>    => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                
                <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>    => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>    => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                
                <pin DO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>    => <wire DO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin TO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>    => <wire TO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>  
            );
    }
    
    const unsigned int r_tile_y1[] = { ty-2 };
    
    foreach tile_y ( r_tile_y1 )
    {
        connect
            (
                <pin DIFFI_IN of <device IOB_LA @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1])>>   => <wire DIFFI_OUT of <device IOB_LB @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                <pin DIFFI_IN of <device IOB_LB @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2])>>   => <wire DIFFI_OUT of <device IOB_LA @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                                
                <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>    => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>    => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                
                <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>    => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>    => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                
                <pin DO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>    => <wire DO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin TO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>    => <wire TO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>> 
            );
    } 
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-4CIM block tiles. Each IO block takes
             the size of 4 tiles. (EAST)

            ]

  Revision History:

*****************************************************************************************/
function place_io_4cim_6io_ttfftt_v_tile ( unsigned int tx, ty )
{
    place_io_aba_ttf_2cim_v_tile (tx, ty);
    place_io_bab_ftt_2cim_v_tile (tx, ty-2);
    
    const unsigned int r_tile_y0[] = { ty, ty-3 };
    
    unsigned int tile_y;
    
    foreach tile_y ( r_tile_y0 )
    {
        connect
            (
                <pin DIFFI_IN of <device IOB_A @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1])>>     => <wire DIFFI_OUT of <device IOB_B @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                <pin DIFFO_IN of <device IOB_B @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2])>>     => <wire DIFFO_OUT of <device IOB_A @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin DIFFI_IN of <device IOB_B @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2])>>     => <wire DIFFI_OUT of <device IOB_A @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                                
                <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                
                <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>      => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>      => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                
                <pin DO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire DO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin TO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire TO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   
            );
    }
    
    const unsigned int r_tile_y1[] = { ty-1 };  
    
    foreach tile_y ( r_tile_y1 )
    {
        connect
            (
                <pin DIFFI_IN of <device IOB_LA @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1])>>     => <wire DIFFI_OUT of <device IOB_LB @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                <pin DIFFI_IN of <device IOB_LB @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2])>>     => <wire DIFFI_OUT of <device IOB_LA @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                                
                <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                
                <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>      => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>      => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                
                <pin DO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire DO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin TO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire TO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>  
            );
    }
    
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-4CIM block tiles. Each IO block takes
             the size of 4 tiles. (EAST)

            ]

  Revision History:

*****************************************************************************************/
function place_io_4cim_6io_ffttff_v_tile ( unsigned int tx, ty )
{
    place_io_aba_fft_2cim_v_tile (tx, ty);
    place_io_bab_tff_2cim_v_tile (tx, ty-2);
    
    const unsigned int r_tile_y0[] = { ty-1 };
    
    unsigned int tile_y;
    
    foreach tile_y ( r_tile_y0 )
    {
        connect
            (
                <pin DIFFI_IN of <device IOB_A @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1])>>     => <wire DIFFI_OUT of <device IOB_B @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                <pin DIFFO_IN of <device IOB_B @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2])>>     => <wire DIFFO_OUT of <device IOB_A @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin DIFFI_IN of <device IOB_B @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2])>>     => <wire DIFFI_OUT of <device IOB_A @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                                
                <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                
                <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>      => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>      => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                
                <pin DO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire DO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin TO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire TO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>  
                
            );
    }
    
    const unsigned int r_tile_y1[] = {  ty, ty-3  };  
    
    foreach tile_y ( r_tile_y1 )
    {
        connect
            (
                <pin DIFFI_IN of <device IOB_LA @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1])>>     => <wire DIFFI_OUT of <device IOB_LB @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                <pin DIFFI_IN of <device IOB_LB @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2])>>     => <wire DIFFI_OUT of <device IOB_LA @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                                
                <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                
                <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>      => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>      => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                
                <pin DO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire DO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin TO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire TO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   
            );
    }
    
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-3CIM block tiles. Each IO block takes
             the size of 3 tiles. (SOUTH-EAST corner)

            ]

  Revision History:

*****************************************************************************************/
function place_io_3cim_4io_v_d_tile ( unsigned int tx, ty )
{
    place_io_aba_ttf_2cim_v_tile (tx, ty);
    place_io_1cim_v_d_tile (tx, ty-2);
    
    const unsigned int r_tile_y0[] = { ty };
    
    unsigned int tile_y;
    
    foreach tile_y ( r_tile_y0 )
    {
        connect
            (
                <pin DIFFI_IN of <device IOB_A @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1])>>    => <wire DIFFI_OUT of <device IOB_B @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2]>>  ,
                <pin DIFFO_IN of <device IOB_B @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2])>>    => <wire DIFFO_OUT of <device IOB_A @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1]>>  ,
                <pin DIFFI_IN of <device IOB_B @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2])>>    => <wire DIFFI_OUT of <device IOB_A @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1]>>  ,
                                
                <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                
                <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>      => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>      => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                
                <pin DO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire DO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin TO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire TO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>  
            );
    }
    
    const unsigned int r_tile_y1[] = { ty-1 };
    
    foreach tile_y ( r_tile_y1 )
    {
        connect
            (
                <pin DIFFI_IN of <device IOB_LA @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1])>>    => <wire DIFFI_OUT of <device IOB_LB @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2]>>  ,
                <pin DIFFI_IN of <device IOB_LB @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2])>>    => <wire DIFFI_OUT of <device IOB_LA @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1]>>  ,
                                
                <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                
                <pin ODDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>      => <wire ODDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                <pin IDDR_CIN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>      => <wire IDDR_COUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2]>>   ,
                
                <pin DO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire DO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin TO_IN of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire TO_OUT of <device IOL @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>  
            );
    }
    
};


/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-9CIM block tiles. Each IO block takes
             the size of 9 tiles. 

            ]

  Revision History:

*****************************************************************************************/
function place_io_9cim_v_u_tile ( unsigned int tx, ty )
{
    place_io_3cim_4io_v_u_tile(tx,ty);
    place_io_dqs_tt_2cim_v_tile (tx, ty-3);
    place_io_4cim_6io_ffttff_v_tile(tx, ty-5);

    const unsigned int l_tile_y[] = { ty, ty-2, ty-3, ty-5, ty-6, ty-8 };
    unsigned int tile_y;

    foreach tile_y ( l_tile_y )
    {
        connect
        (
            <pin SAMPLE_CLK  of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire SAMPLE_CLK  of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-4)*TILE_NUM_SITE_Y]>>,
            <pin PROBE_CLK   of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire PROBE_CLK   of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-4)*TILE_NUM_SITE_Y]>>,
            <pin WCLK        of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire WCLK        of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-4)*TILE_NUM_SITE_Y]>>,
            <pin WCLK_DEL    of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire WCLK_DEL    of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-4)*TILE_NUM_SITE_Y]>>,
            <pin IFIFO_WADDR of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire IFIFO_WADDR of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-4)*TILE_NUM_SITE_Y]>>,
            <pin IFIFO_RADDR of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire IFIFO_RADDR of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-4)*TILE_NUM_SITE_Y]>>,
            <pin DQSI_DEL    of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire DQSI_DEL    of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-4)*TILE_NUM_SITE_Y]>>,
                        
            <pin SAMPLE_CLK  of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire SAMPLE_CLK  of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-4)*TILE_NUM_SITE_Y]>>,
            <pin PROBE_CLK   of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire PROBE_CLK   of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-4)*TILE_NUM_SITE_Y]>>,
            <pin WCLK        of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire WCLK        of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-4)*TILE_NUM_SITE_Y]>>,
            <pin WCLK_DEL    of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire WCLK_DEL    of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-4)*TILE_NUM_SITE_Y]>>,
            <pin IFIFO_WADDR of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire IFIFO_WADDR of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-4)*TILE_NUM_SITE_Y]>>,
            <pin IFIFO_RADDR of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire IFIFO_RADDR of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-4)*TILE_NUM_SITE_Y]>>,
            <pin DQSI_DEL    of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire DQSI_DEL    of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-4)*TILE_NUM_SITE_Y]>>
        );
    }

};


/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-9CIM block tiles. Each IO block takes
             the size of 9 tiles. 

            ]

  Revision History:

*****************************************************************************************/
function place_io_9cim_v_d_tile ( unsigned int tx, ty )
{
    place_io_4cim_6io_ttfftt_v_tile(tx, ty);
    place_io_dqs_ff_2cim_v_tile (tx, ty-4);
    place_io_3cim_4io_v_d_tile(tx , ty-6);
    
    const unsigned int l_tile_y[] = { ty, ty-1, ty-3, ty-4, ty-6, ty-7 };
    unsigned int tile_y;

    foreach tile_y ( l_tile_y )
    {       
        connect
        (
            <pin SAMPLE_CLK  of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire SAMPLE_CLK  of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin PROBE_CLK   of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire PROBE_CLK   of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin WCLK        of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire WCLK        of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin WCLK_DEL    of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire WCLK_DEL    of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin IFIFO_WADDR of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire IFIFO_WADDR of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin IFIFO_RADDR of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire IFIFO_RADDR of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin DQSI_DEL    of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire DQSI_DEL    of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
                        
            <pin SAMPLE_CLK  of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire SAMPLE_CLK  of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin PROBE_CLK   of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire PROBE_CLK   of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin WCLK        of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire WCLK        of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin WCLK_DEL    of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire WCLK_DEL    of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin IFIFO_WADDR of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire IFIFO_WADDR of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin IFIFO_RADDR of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire IFIFO_RADDR of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin DQSI_DEL    of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire DQSI_DEL    of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>
        );
    }
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-10CIM block tiles. Each IO block takes
             the size of 10 tiles. 

            ]

  Revision History:

*****************************************************************************************/
function place_io_10cim_v_tile ( unsigned int tx, ty, unsigned int false_true_flag)
{
    if(false_true_flag == 0)
    {
        place_io_4cim_6io_ttfftt_v_tile(tx, ty);
        place_io_dqs_ff_2cim_v_tile (tx, ty-4);
        place_io_4cim_6io_ttfftt_v_tile(tx, ty-6);
    }
    else
    {
        place_io_4cim_6io_ffttff_v_tile(tx, ty);
        place_io_dqs_tt_2cim_v_tile (tx, ty-4);
        place_io_4cim_6io_ffttff_v_tile(tx, ty-6);
    }
    
    const unsigned int l_tile_y[] = { ty, ty-1, ty-3, ty-4, ty-6, ty-7, ty-9 };
    unsigned int tile_y;

    foreach tile_y ( l_tile_y )
    {
        connect
        (
            <pin SAMPLE_CLK  of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire SAMPLE_CLK  of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin PROBE_CLK   of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire PROBE_CLK   of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin WCLK        of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire WCLK        of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin WCLK_DEL    of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire WCLK_DEL    of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin IFIFO_WADDR of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire IFIFO_WADDR of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin IFIFO_RADDR of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire IFIFO_RADDR of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin DQSI_DEL    of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire DQSI_DEL    of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
                        
            <pin SAMPLE_CLK  of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire SAMPLE_CLK  of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin PROBE_CLK   of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire PROBE_CLK   of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin WCLK        of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire WCLK        of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin WCLK_DEL    of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire WCLK_DEL    of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin IFIFO_WADDR of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire IFIFO_WADDR of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin IFIFO_RADDR of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire IFIFO_RADDR of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>,
            <pin DQSI_DEL    of <device IOL @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>  => <wire DQSI_DEL    of <device DQS @[tx*TILE_NUM_SITE_X+3, (ty-5)*TILE_NUM_SITE_Y]>>
        );
    }
};



/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO_L-2CIM block tiles in vertical direction. 
             Each IO block takes the size of 2 tiles. (WEST EDGE)
             
             ----------|----------|----------|----------    
                         IOL2[1,2]  IOB2[2,2]  C[3,2]
               V[0,1]    IOL1[1,1]  IOB1[2,1]      
               G[0,0]    R[1,0]     I[2,0]                 TILE 0   
             ----------|----------|----------|----------      
                                               C[3,2]
               V[0,1]    IOL3[1,1]  IOB3[2,1]
               G[0,0]    R[1,0]     I[2,0]                 TILE 1 
             ----------|----------|----------|----------

            ]

  Revision History:

*****************************************************************************************/
function place_io_l_aba_2cim_v_tile ( unsigned int tx, ty)
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // The wires are spread out in 2 tiles. Pre-calculate the lower-left corner of all 2 tiles
    unsigned int tile_0_sy =  ty              * TILE_NUM_SITE_Y;
    unsigned int tile_1_sy = (ty - 1)         * TILE_NUM_SITE_Y;
    
    //
    // Layout IOL1 in the tile #0
    //
    // Allocate the wires driven by IOL1
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
   
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_RX_DATA[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_0_sy+1);
    &wire ntRef_ntIOL1_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    //
    // Layout IOB1 in the tile #0
    //
    // Allocate the wires driven by IOB1 
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_0_sy+1);
    &wire ntRef_ntIOB1_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_0_sy+1);
    &wire ntRef_ntIOB1_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOL2 in the tile #0
    //
    // Allocate the wires driven by IOL2
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_RX_DATA[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOB2 in the tile #0
    //
    // Allocate the wires driven by IOB2 
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_0_sy+2);
    &wire ntRef_ntIOB2_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_0_sy+2);
    &wire ntRef_ntIOB2_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    
    //
    // Instantiate the IOL1 @[1,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_L_%d_%d", sx+1, tile_0_sy+1);
    device IOL_L *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL1_IODLY_OV        ,           // output
                 //DPI_STS         => ntRef_ntIOL1_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL1_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL1_RX_DATA         ,
                   DO              => ntRef_ntIOL1_DO              ,
                   TO              => ntRef_ntIOL1_TO              ,
                   DO_OUT          => ntRef_ntIOL1_DO_OUT          , 
                   TO_OUT          => ntRef_ntIOL1_TO_OUT          ,
                   
                   TX_DATA[0]       => <wire A_IA0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,      // IOL1 <- SIB
                   TX_DATA[1]       => <wire A_IA1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[2]       => <wire A_IA2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[3]       => <wire A_IA3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[4]       => <wire A_IA4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[5]       => <wire A_IB0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL          => <wire A_IB1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TS_CTRL[1]       => <wire A_IB2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TS_CTRL[2]       => <wire A_IB3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TS_CTRL[3]       => <wire A_IB4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //DPI_STS_CLR      => <wire A_IC0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[0]    => <wire A_IC1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[1]    => <wire A_IC2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[2]    => <wire A_IC3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //DPI_CTRL[0]      => <wire A_IC4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //DPI_CTRL[1]      => <wire A_ID0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SLIP             => <wire A_ID1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SYSCLK           => <wire A_ICLK of <device CIM @[sx+3, tile_0_sy+2]>>   ,
                   CE               => <wire A_ICE of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   LRS              => <wire A_IRS of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   
                   DIN               => ntRef_ntIOB1_DIN                              // IOL1 <- IOB1
                 )
        @[sx+1,tile_0_sy+1];
        
    // Hook up the outputs of IOL1 -> SRB (TILE 0)
    connect
        (
            <pin A_IY0   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_IODLY_OV      , 
            <pin A_IY1   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA_DD      ,
            <pin A_IY2   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[0]   ,
            <pin A_IY3   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[1]   ,
          //<pin A_IQ0   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[2]   ,
          //<pin A_IQ1   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[3]   ,
          //<pin A_IQ2   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[4]   ,
          //<pin A_IQ3   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[5]   ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_DPI_STS[0]    ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_DPI_STS[1]
        );
        
    //
    // Instantiate the IOB1 @[2,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LA_%d_%d", sx+2, tile_0_sy+1);
    device IOB_LA *strVar
        port map (
                   DO         => ntRef_ntIOL1_DO    , //Input from IOL1 (Tile 0)
                   TO         => ntRef_ntIOL1_TO    ,
                   
                   DIN        => ntRef_ntIOB1_DIN   ,
                   DIFFI_OUT  => ntRef_ntIOB1_DIFFI_OUT 
                 )
        @[sx+2,tile_0_sy+1];
        

    //
    // Instantiate the IOL2 @[1,2] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_L_%d_%d", sx+1, tile_0_sy+2);
    device IOL_L *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL2_IODLY_OV        ,           // output
                 //DPI_STS         => ntRef_ntIOL2_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL2_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL2_RX_DATA         ,
                   DO              => ntRef_ntIOL2_DO              ,
                   TO              => ntRef_ntIOL2_TO              ,
                   
                   TX_DATA[0]        => <wire S_IA0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,   // IOL2 <- SIB
                   TX_DATA[1]        => <wire S_IA1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[2]        => <wire S_IA2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[3]        => <wire S_IA3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[4]        => <wire S_IA4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[5]        => <wire S_IB0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL           => <wire S_IB1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TS_CTRL[1]        => <wire S_IB2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TS_CTRL[2]        => <wire S_IB3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TS_CTRL[3]        => <wire S_IB4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //DPI_STS_CLR       => <wire S_IC0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[0]     => <wire S_IC1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[1]     => <wire S_IC2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[2]     => <wire S_IC3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //DPI_CTRL[0]       => <wire S_IC4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //DPI_CTRL[1]       => <wire S_ID0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SLIP              => <wire S_ID1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SYSCLK            => <wire S_ICLK of <device CIM @[sx+3, tile_0_sy+2]>>   ,
                   CE                => <wire S_ICE of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   LRS               => <wire S_IRS of <device CIM @[sx+3, tile_0_sy+2]>>    ,

                   DIN    => ntRef_ntIOB2_DIN                              // IOL2 <- IOB2
                 )
        @[sx+1, tile_0_sy+2];
        
    // Hook up the outputs of SRB <- IOL2
    connect
        (         
            <pin S_IY0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_IODLY_OV       ,
            <pin S_IY1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA_DD       ,
            <pin S_IY2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[0]    ,
            <pin S_IY3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[1]    ,
          //<pin S_IQ0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[2]    ,
          //<pin S_IQ1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[3]    ,
          //<pin S_IQ2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[4]    ,
          //<pin S_IQ3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[5]    ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntIOL2_DPI_STS[0]     ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntIOL2_DPI_STS[1]
        );  
        
    //
    // Instantiate the IOB2 @[2,2] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LB_%d_%d", sx+2, tile_0_sy+2);
    device IOB_LB *strVar
        port map (
                   DO          => ntRef_ntIOL2_DO    ,  //Input from IOL2 (Tile 0)
                   TO          => ntRef_ntIOL2_TO     ,
                   
                   DIN         => ntRef_ntIOB2_DIN     ,  //output
                   DIFFI_OUT      => ntRef_ntIOB2_DIFFI_OUT    
                 )
        @[sx+2,tile_0_sy+2];
        
    //
    // Layout IOL3 in the tile #1
    //
    // Allocate the wires driven by IOL3
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_RX_DATA[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL3_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    //
    // Layout IOB3 in the tile #1
    //
    // Allocate the wires driven by IOB3
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntIOB3_DIN = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntIOB3_DIFFI_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
           
    //
    // Instantiate the IOL3 @[1,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_L_%d_%d", sx+1, tile_1_sy+1);
    device IOL_L *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL3_IODLY_OV        ,           // output
                 //DPI_STS         => ntRef_ntIOL3_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL3_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL3_RX_DATA         ,
                   DO              => ntRef_ntIOL3_DO              ,
                   TO              => ntRef_ntIOL3_TO              ,
                   DO_OUT          => ntRef_ntIOL3_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL3_TO_OUT          ,

                   TX_DATA[0]      => <wire A_IA0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,      //IOL3 <- SIB (tile 1)
                   TX_DATA[1]      => <wire A_IA1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //TX_DATA[2]      => <wire A_IA2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //TX_DATA[3]      => <wire A_IA3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //TX_DATA[4]      => <wire A_IA4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //TX_DATA[5]      => <wire A_IB0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TS_CTRL         => <wire A_IB1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //TS_CTRL[1]      => <wire A_IB2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //TS_CTRL[2]      => <wire A_IB3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //TS_CTRL[3]      => <wire A_IB4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //DPI_STS_CLR     => <wire A_IC0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   IODLY_CTRL[0]   => <wire A_IC1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   IODLY_CTRL[1]   => <wire A_IC2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   IODLY_CTRL[2]   => <wire A_IC3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //DPI_CTRL[0]     => <wire A_IC4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //DPI_CTRL[1]     => <wire A_ID0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   SLIP            => <wire A_ID1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   SYSCLK          => <wire A_ICLK of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                   CE              => <wire A_ICE of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   LRS             => <wire A_IRS of <device CIM @[sx+3, tile_1_sy+2]>>    ,

                   DIN    => ntRef_ntIOB3_DIN                              //IOL3 <- IOB3 (Tile 1) 

                 )
        @[sx+1,tile_1_sy+1];

    // Hook up the outputs of IOL3 -> SRB (TILE 1)
    connect
        (
            <pin A_IY0   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_IODLY_OV       , 
            <pin A_IY1   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA_DD     ,
            <pin A_IY2   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[0]    ,
            <pin A_IY3   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[1]    ,
          //<pin A_IQ0   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[2]    ,
          //<pin A_IQ1   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[3]    ,
          //<pin A_IQ2   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[4]    ,
          //<pin A_IQ3   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[5]    ,
            <pin S_IY6AB of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_DPI_STS[0]     ,
            <pin S_IY6CD of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_DPI_STS[1]
        );

    //
    // Instantiate the IOB3 @[2,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LA_%d_%d", sx+2, tile_1_sy+1);
    device IOB_LA *strVar
        port map (
                   DO         => ntRef_ntIOL3_DO   ,   //Input from IOL3 (Tile 1)
                   TO         => ntRef_ntIOL3_TO   ,
                   
                   DIN        => ntRef_ntIOB3_DIN  ,     //output
                   DIFFI_OUT  => ntRef_ntIOB3_DIFFI_OUT
                 )
        @[sx+2,tile_1_sy+1];

};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO_L-2CIM block tiles in vertical direction. 
             Each IO block takes the size of 2 tiles. (WEST EDGE)
             
             ----------|----------|----------|----------    
                         IOL2[1,2]  IOB2[2,2]  C[3,2]
               V[0,1]           
               G[0,0]    R[1,0]     I[2,0]                 TILE 0   
             ----------|----------|----------|----------      
                                               C[3,2]
               V[0,1]     
               G[0,0]    R[1,0]     I[2,0]                 TILE 1 
             ----------|----------|----------|----------

            ]

  Revision History:

*****************************************************************************************/
function place_io_l_b_2cim_v_tile ( unsigned int tx, ty)
{
    string strVar;
   
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // The wires are spread out in 2 tiles. Pre-calculate the lower-left corner of all 2 tiles
    unsigned int tile_0_sy =  ty              * TILE_NUM_SITE_Y;
    unsigned int tile_1_sy = (ty -1)          * TILE_NUM_SITE_Y;
    
    //
    // Layout IOL2 in the tile #0
    //
    // Allocate the wires driven by IOL2
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_RX_DATA[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_0_sy+2);
    &wire ntRef_ntIOL2_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOB2 in the tile #0
    //
    // Allocate the wires driven by IOB2 
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_0_sy+2);
    &wire ntRef_ntIOB2_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_0_sy+2);
    &wire ntRef_ntIOB2_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
        

    //
    // Instantiate the IOL2 @[1,2] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_L_%d_%d", sx+1, tile_0_sy+2);
    device IOL_L *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL2_IODLY_OV        ,           // output
                 //DPI_STS         => ntRef_ntIOL2_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL2_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL2_RX_DATA         ,
                   DO              => ntRef_ntIOL2_DO              ,
                   TO              => ntRef_ntIOL2_TO              ,
                   
                   TX_DATA[0]        => <wire S_IA0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,   // IOL2 <- SIB
                   TX_DATA[1]        => <wire S_IA1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[2]        => <wire S_IA2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[3]        => <wire S_IA3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[4]        => <wire S_IA4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[5]        => <wire S_IB0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL           => <wire S_IB1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TS_CTRL[1]        => <wire S_IB2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TS_CTRL[2]        => <wire S_IB3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TS_CTRL[3]        => <wire S_IB4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //DPI_STS_CLR       => <wire S_IC0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[0]     => <wire S_IC1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[1]     => <wire S_IC2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[2]     => <wire S_IC3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //DPI_CTRL[0]       => <wire S_IC4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //DPI_CTRL[1]       => <wire S_ID0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SLIP              => <wire S_ID1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SYSCLK            => <wire S_ICLK of <device CIM @[sx+3, tile_0_sy+2]>>   ,
                   CE                => <wire S_ICE of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   LRS               => <wire S_IRS of <device CIM @[sx+3, tile_0_sy+2]>>    ,

                   DIN    => ntRef_ntIOB2_DIN                              // IOL2 <- IOB2
                 )
        @[sx+1, tile_0_sy+2];
        
    // Hook up the outputs of SRB <- IOL2
    connect
        (         
            <pin S_IY0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_IODLY_OV       ,
            <pin S_IY1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA_DD       ,
            <pin S_IY2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[0]    ,
            <pin S_IY3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[1]    ,
          //<pin S_IQ0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[2]    ,
          //<pin S_IQ1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[3]    ,
          //<pin S_IQ2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[4]    ,
          //<pin S_IQ3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[5]    ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntIOL2_DPI_STS[0]     ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntIOL2_DPI_STS[1]
        );  
        
    //
    // Instantiate the IOB2 @[2,2] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LB_%d_%d", sx+2, tile_0_sy+2);
    device IOB_LB *strVar
        port map (
                   DO          => ntRef_ntIOL2_DO    ,  //Input from IOL2 (Tile 0)
                   TO          => ntRef_ntIOL2_TO     ,
                   
                   DIN         => ntRef_ntIOB2_DIN     ,  //output
                   DIFFI_OUT      => ntRef_ntIOB2_DIFFI_OUT    
                 )
        @[sx+2,tile_0_sy+2];
        
};


/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO_L-2CIM block tiles in vertical direction. 
             Each IO block takes the size of 2 tiles. (WEST EDGE)
             
             ----------|----------|----------|----------    
                         IOL1[1,2]  IOB1[2,2]  C[3,2]
               V[0,1]         
               G[0,0]    R[1,0]     I[2,0]                 TILE PRE  
             ----------|----------|----------|----------    
                                               C[3,2]
               V[0,1]          
               G[0,0]    R[1,0]     I[2,0]                 TILE 0   
             ----------|----------|----------|----------      
                         IOL3[1,2]  IOB3[2,2]  C[3,2]
               V[0,1]    IOL2[1,1]  IOB2[2,1]
               G[0,0]    R[1,0]     I[2,0]                 TILE 1 
             ----------|----------|----------|----------

            ]

  Revision History:

*****************************************************************************************/
function place_io_l_bab_2cim_v_tile ( unsigned int tx, ty)
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // The wires are spread out in 2 tiles. Pre-calculate the lower-left corner of all 2 tiles
    unsigned int tile_pre_sy = (ty + 1)         * TILE_NUM_SITE_Y;    
    unsigned int tile_0_sy   =  ty              * TILE_NUM_SITE_Y;
    unsigned int tile_1_sy   = (ty - 1)         * TILE_NUM_SITE_Y;
    
    //
    // Layout IOL1 in the tile #pre
    //
    // Allocate the wires driven by IOL1
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
   
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_RX_DATA[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    //
    // Layout IOB1 in the tile #pre
    //
    // Allocate the wires driven by IOB1 
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_pre_sy+2);
    &wire ntRef_ntIOB1_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_pre_sy+2);
    &wire ntRef_ntIOB1_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOL2 in the tile #1
    //
    // Allocate the wires driven by IOL2
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_RX_DATA[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, tile_1_sy+1);
    &wire ntRef_ntIOL2_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Layout IOB2 in the tile #1
    //
    // Allocate the wires driven by IOB2 
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntIOB2_DIN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_1_sy+1);
    &wire ntRef_ntIOB2_DIFFI_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
        
    //
    // Instantiate the IOL1 @[1,2] in tile #PRE. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_L_%d_%d", sx+1, tile_pre_sy+2);
    device IOL_L *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL1_IODLY_OV        ,           // output
                 //DPI_STS         => ntRef_ntIOL1_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL1_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL1_RX_DATA         ,
                   DO              => ntRef_ntIOL1_DO              ,
                   TO              => ntRef_ntIOL1_TO              ,
                   
                   TX_DATA[0]       => <wire A_IA0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,      // IOL1 <- SIB
                   TX_DATA[1]       => <wire A_IA1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[2]       => <wire A_IA2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[3]       => <wire A_IA3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[4]       => <wire A_IA4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[5]       => <wire A_IB0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL          => <wire A_IB1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TS_CTRL[1]       => <wire A_IB2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TS_CTRL[2]       => <wire A_IB3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TS_CTRL[3]       => <wire A_IB4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //DPI_STS_CLR      => <wire A_IC0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[0]    => <wire A_IC1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[1]    => <wire A_IC2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[2]    => <wire A_IC3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //DPI_CTRL[0]      => <wire A_IC4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //DPI_CTRL[1]      => <wire A_ID0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SLIP             => <wire A_ID1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SYSCLK           => <wire A_ICLK of <device CIM @[sx+3, tile_0_sy+2]>>   ,
                   CE               => <wire A_ICE of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   LRS              => <wire A_IRS of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   
                   DIN               => ntRef_ntIOB1_DIN                              // IOL1 <- IOB1
                 )
        @[sx+1,tile_pre_sy+2];
        
    // Hook up the outputs of IOL1 -> SRB (TILE 0)
    connect
        (
            <pin A_IY0   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_IODLY_OV      , 
            <pin A_IY1   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA_DD      ,
            <pin A_IY2   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[0]   ,
            <pin A_IY3   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[1]   ,
          //<pin A_IQ0   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[2]   ,
          //<pin A_IQ1   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[3]   ,
          //<pin A_IQ2   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[4]   ,
          //<pin A_IQ3   of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_RX_DATA[5]   ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_DPI_STS[0]    ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_0_sy+2]>> => ntRef_ntIOL1_DPI_STS[1]
        );
        
    //
    // Instantiate the IOB1 @[2,2] in tile #pre. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LB_%d_%d", sx+2, tile_pre_sy+2);
    device IOB_LB *strVar
        port map (
                   DO         => ntRef_ntIOL1_DO        , //Input from IOL1 (Tile 1)
                   TO         => ntRef_ntIOL1_TO         ,
                   
                   DIN        => ntRef_ntIOB1_DIN         ,   //output
                   DIFFI_OUT     => ntRef_ntIOB1_DIFFI_OUT  
                 )
        @[sx+2,tile_pre_sy+2];
        

    //
    // Instantiate the IOL2 @[1,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_L_%d_%d", sx+1, tile_1_sy+1);
    device IOL_L *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL2_IODLY_OV        ,           // output
                 //DPI_STS         => ntRef_ntIOL2_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL2_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL2_RX_DATA         ,
                   DO              => ntRef_ntIOL2_DO              ,
                   TO              => ntRef_ntIOL2_TO              ,
                   DO_OUT          => ntRef_ntIOL2_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL2_TO_OUT          ,
                   
                   TX_DATA[0]        => <wire S_IA0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,   // IOL2 <- SIB
                   TX_DATA[1]        => <wire S_IA1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[2]        => <wire S_IA2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[3]        => <wire S_IA3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[4]        => <wire S_IA4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TX_DATA[5]        => <wire S_IB0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   TS_CTRL           => <wire S_IB1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TS_CTRL[1]        => <wire S_IB2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TS_CTRL[2]        => <wire S_IB3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //TS_CTRL[3]        => <wire S_IB4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //DPI_STS_CLR       => <wire S_IC0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[0]     => <wire S_IC1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[1]     => <wire S_IC2 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   IODLY_CTRL[2]     => <wire S_IC3 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //DPI_CTRL[0]       => <wire S_IC4 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                 //DPI_CTRL[1]       => <wire S_ID0 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SLIP              => <wire S_ID1 of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   SYSCLK            => <wire S_ICLK of <device CIM @[sx+3, tile_0_sy+2]>>   ,
                   CE                => <wire S_ICE of <device CIM @[sx+3, tile_0_sy+2]>>    ,
                   LRS               => <wire S_IRS of <device CIM @[sx+3, tile_0_sy+2]>>    ,

                   DIN    => ntRef_ntIOB2_DIN                              // IOL2 <- IOB2
                 )
        @[sx+1, tile_1_sy+1];
        
    // Hook up the outputs of SRB <- IOL2
    connect
        (         
            <pin S_IY0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_IODLY_OV       ,
            <pin S_IY1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA_DD       ,
            <pin S_IY2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[0]    ,
            <pin S_IY3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[1]    ,
          //<pin S_IQ0 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[2]    ,
          //<pin S_IQ1 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[3]    ,
          //<pin S_IQ2 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[4]    ,
          //<pin S_IQ3 of <device CIM @[sx+3,tile_0_sy+2]>>   => ntRef_ntIOL2_RX_DATA[5]    ,
            <pin A_IY6AB of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntIOL2_DPI_STS[0]     ,
            <pin A_IY6CD of <device CIM @[sx+3,tile_1_sy+2]>> => ntRef_ntIOL2_DPI_STS[1]
        );  
        
    //
    // Instantiate the IOB2 @[2,1] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LA_%d_%d", sx+2, tile_1_sy+1);
    device IOB_LA *strVar
        port map (
                   DO          => ntRef_ntIOL2_DO     ,  //Input from IOL2 (Tile 0)
                   TO          => ntRef_ntIOL2_TO     ,
                   
                   DIN         => ntRef_ntIOB2_DIN    , //output 
                   DIFFI_OUT   => ntRef_ntIOB2_DIFFI_OUT
                 )
        @[sx+2,tile_1_sy+1];
        
    //
    // Layout IOL3 in the tile #1
    //
    // Allocate the wires driven by IOL3
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_1_sy+2);
    &wire ntRef_ntIOL3_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_1_sy+2);
    &wire ntRef_ntIOL3_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_1_sy+2);
    &wire ntRef_ntIOL3_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_1_sy+2);
    &wire ntRef_ntIOL3_RX_DATA[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_1_sy+2);
    &wire ntRef_ntIOL3_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_1_sy+2);
    &wire ntRef_ntIOL3_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    //
    // Layout IOB3 in the tile #1
    //
    // Allocate the wires driven by IOB3
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_1_sy+2);
    &wire ntRef_ntIOB3_DIN = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_1_sy+2);
    &wire ntRef_ntIOB3_DIFFI_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
       
    //
    // Instantiate the IOL3 @[1,2] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_L_%d_%d", sx+1, tile_1_sy+2);
    device IOL_L *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL3_IODLY_OV        ,           // output
                 //DPI_STS         => ntRef_ntIOL3_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL3_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL3_RX_DATA         ,
                   DO              => ntRef_ntIOL3_DO              ,
                   TO              => ntRef_ntIOL3_TO              ,

                   TX_DATA[0]      => <wire A_IA0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,      //IOL3 <- SIB (tile 1)
                   TX_DATA[1]      => <wire A_IA1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //TX_DATA[2]      => <wire A_IA2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //TX_DATA[3]      => <wire A_IA3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //TX_DATA[4]      => <wire A_IA4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //TX_DATA[5]      => <wire A_IB0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   TS_CTRL         => <wire A_IB1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //TS_CTRL[1]      => <wire A_IB2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //TS_CTRL[2]      => <wire A_IB3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //TS_CTRL[3]      => <wire A_IB4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //DPI_STS_CLR     => <wire A_IC0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   IODLY_CTRL[0]   => <wire A_IC1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   IODLY_CTRL[1]   => <wire A_IC2 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   IODLY_CTRL[2]   => <wire A_IC3 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //DPI_CTRL[0]     => <wire A_IC4 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                 //DPI_CTRL[1]     => <wire A_ID0 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   SLIP            => <wire A_ID1 of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   SYSCLK          => <wire A_ICLK of <device CIM @[sx+3, tile_1_sy+2]>>   ,
                   CE              => <wire A_ICE of <device CIM @[sx+3, tile_1_sy+2]>>    ,
                   LRS             => <wire A_IRS of <device CIM @[sx+3, tile_1_sy+2]>>    ,

                   DIN    => ntRef_ntIOB3_DIN                              //IOL3 <- IOB3 (Tile 1) 

                 )
        @[sx+1,tile_1_sy+2];

    // Hook up the outputs of IOL3 -> SRB (TILE 1)
    connect
        (
            <pin A_IY0   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_IODLY_OV       , 
            <pin A_IY1   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA_DD       ,
            <pin A_IY2   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[0]    ,
            <pin A_IY3   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[1]    ,
          //<pin A_IQ0   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[2]    ,
          //<pin A_IQ1   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[3]    ,
          //<pin A_IQ2   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[4]    ,
          //<pin A_IQ3   of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_RX_DATA[5]    ,
            <pin S_IY6AB of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_DPI_STS[0]     ,
            <pin S_IY6CD of <device CIM @[sx+3,tile_1_sy+2]>>   => ntRef_ntIOL3_DPI_STS[1]
        );

    //
    // Instantiate the IOB3 @[2,2] in tile #1. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LB_%d_%d", sx+2, tile_1_sy+2);
    device IOB_LB *strVar
        port map (
                   DO         => ntRef_ntIOL3_DO    ,   //Input from IOL3 (Tile 1)
                   TO         => ntRef_ntIOL3_TO     ,
                   
                   DIN        => ntRef_ntIOB3_DIN     ,   //output
                   DIFFI_OUT     => ntRef_ntIOB3_DIFFI_OUT
                 )
        @[sx+2,tile_1_sy+2];

};


/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-1CIM block tiles. Each IO block takes
             the size of 1 tiles. (1CIM - 1IO)   (WEST EDGE)
             
             ---------|---------|---------|---------    
                                            C[3,2]
                V[0,1]  IOL1[1,1] IOB1[2,1]       
                G[0,0]  R[1,0]    I[2,0]                 TILE 0   
             ---------|---------|---------|---------                                                                                 
              
            ]

  Revision History:

*****************************************************************************************/
function place_io_l_1cim_v_u_tile ( unsigned int tx, ty)
{    
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    //
    // Layout IOL1 in the tile #0
    //
    // Allocate the wires driven by IOL1
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, sy+1);
    &wire ntRef_ntIOL1_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, sy+1);
    &wire ntRef_ntIOL1_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, sy+1);
    &wire ntRef_ntIOL1_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, sy+1);
    &wire ntRef_ntIOL1_RX_DATA[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, sy+1);
    &wire ntRef_ntIOL1_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, sy+1);
    &wire ntRef_ntIOL1_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_OUT_%d_%d", sx+1, sy+1);
    &wire ntRef_ntIOL1_DO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_OUT_%d_%d", sx+1, sy+1);
    &wire ntRef_ntIOL1_TO_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    //
    // Layout IOB1 in the tile #0
    //
    // Allocate the wires driven by IOB1
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, sy+1);
    &wire ntRef_ntIOB1_DIN = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntIOB1_DIFFI_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
           
    //
    // Instantiate the IOL1 @[1,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_L_%d_%d", sx+1, sy+1);
    device IOL_L *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL1_IODLY_OV        ,           // output
                 //DPI_STS         => ntRef_ntIOL1_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL1_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL1_RX_DATA         ,
                   DO              => ntRef_ntIOL1_DO              ,
                   TO              => ntRef_ntIOL1_TO              ,
                   DO_OUT          => ntRef_ntIOL1_DO_OUT          ,
                   TO_OUT          => ntRef_ntIOL1_TO_OUT          ,
                   
                   TX_DATA[0]       => <wire A_IA0 of <device CIM @[sx+3, sy+2]>>    ,  //IOL1 <- SIB (tile 0)
                   TX_DATA[1]       => <wire A_IA1 of <device CIM @[sx+3, sy+2]>>    ,
                 //TX_DATA[2]       => <wire A_IA2 of <device CIM @[sx+3, sy+2]>>    ,
                 //TX_DATA[3]       => <wire A_IA3 of <device CIM @[sx+3, sy+2]>>    ,
                 //TX_DATA[4]       => <wire A_IA4 of <device CIM @[sx+3, sy+2]>>    ,
                 //TX_DATA[5]       => <wire A_IB0 of <device CIM @[sx+3, sy+2]>>    ,
                   TS_CTRL          => <wire A_IB1 of <device CIM @[sx+3, sy+2]>>    ,
                 //TS_CTRL[1]       => <wire A_IB2 of <device CIM @[sx+3, sy+2]>>    ,
                 //TS_CTRL[2]       => <wire A_IB3 of <device CIM @[sx+3, sy+2]>>    ,
                 //TS_CTRL[3]       => <wire A_IB4 of <device CIM @[sx+3, sy+2]>>    ,
                 //DPI_STS_CLR      => <wire A_IC0 of <device CIM @[sx+3, sy+2]>>    ,
                   IODLY_CTRL[0]    => <wire A_IC1 of <device CIM @[sx+3, sy+2]>>    ,
                   IODLY_CTRL[1]    => <wire A_IC2 of <device CIM @[sx+3, sy+2]>>    ,
                   IODLY_CTRL[2]    => <wire A_IC3 of <device CIM @[sx+3, sy+2]>>    ,
                 //DPI_CTRL[0]      => <wire A_IC4 of <device CIM @[sx+3, sy+2]>>    ,
                 //DPI_CTRL[1]      => <wire A_ID0 of <device CIM @[sx+3, sy+2]>>    ,
                   SLIP             => <wire A_ID1 of <device CIM @[sx+3, sy+2]>>    ,
                   SYSCLK           => <wire A_ICLK of <device CIM @[sx+3, sy+2]>>   ,
                   CE               => <wire A_ICE of <device CIM @[sx+3, sy+2]>>    ,
                   LRS              => <wire A_IRS of <device CIM @[sx+3, sy+2]>>    ,

                   DIN               => ntRef_ntIOB1_DIN                              //IOL1 <- IOB1 (Tile 0) 

                 )
        @[sx+1,sy+1];

    // Hook up the outputs of IOL1 -> SRB (TILE 0)
    connect
        (
            <pin A_IY0   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_IODLY_OV     ,
            <pin A_IY1   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA_DD     ,
            <pin A_IY2   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[0]  ,
            <pin A_IY3   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[1]  ,
          //<pin A_IQ0   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[2]  ,
          //<pin A_IQ1   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[3]  ,
          //<pin A_IQ2   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[4]  ,
          //<pin A_IQ3   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[5]  ,
            <pin S_IY6AB of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_DPI_STS[0]   ,
            <pin S_IY6CD of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_DPI_STS[1]
        );

    //
    // Instantiate the IOB1 @[2,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LA_%d_%d", sx+2, sy+1);
    device IOB_LA *strVar
        port map (
                   DO         => ntRef_ntIOL1_DO       ,   //Input from IOL1 (Tile 0)
                   TO         => ntRef_ntIOL1_TO       ,
                   
                   DIN        => ntRef_ntIOB1_DIN      ,  //output
                   DIFFI_OUT  => ntRef_ntIOB1_DIFFI_OUT
                 )
        @[sx+2,sy+1];
};


/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-1CIM block tiles. Each IO block takes
             the size of 1 tiles. (1CIM - 1IO)  (WEST EDGE)
             
             ---------|---------|---------|---------    
                       IOL1[1,2] IOB1[2,2]  C[3,2]
                V[0,1]         
                G[0,0]  R[1,0]    I[2,0]                 TILE PRE  
             ---------|---------|---------|---------    
                                            C[3,2]
                V[0,1]        
                G[0,0]  R[1,0]    I[2,0]                 TILE 0   
             ---------|---------|---------|---------                                                                                 
              
            ]

  Revision History:

*****************************************************************************************/
function place_io_l_1cim_v_d_tile ( unsigned int tx, ty)
{    
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    unsigned int tile_pre_sy = (ty + 1)         * TILE_NUM_SITE_Y;
        
    //
    // Layout IOL1 in the tile #pre
    //
    // Allocate the wires driven by IOL1
    //
    sprintf(strVar, "ntIODLY_OV_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_IODLY_OV = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDPI_STS_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_DPI_STS[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntRX_DATA_DD_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_RX_DATA_DD = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    sprintf(strVar, "ntRX_DATA_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_RX_DATA[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDO_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_DO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntTO_%d_%d", sx+1, tile_pre_sy+2);
    &wire ntRef_ntIOL1_TO = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;

    //
    // Layout IOB1 in the tile #pre
    //
    // Allocate the wires driven by IOB1
    //
    sprintf(strVar, "ntDIN_%d_%d", sx+2, tile_pre_sy+2);
    &wire ntRef_ntIOB1_DIN = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    sprintf(strVar, "ntDIFFI_OUT_%d_%d", sx+2, tile_pre_sy+2);
    &wire ntRef_ntIOB1_DIFFI_OUT = wire *strVar /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
       
    //
    // Instantiate the IOL1 @[1,2] in tile #pre. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOL_L_%d_%d", sx+1, tile_pre_sy+2);
    device IOL_L *strVar
        port map (
                   IODLY_OV        => ntRef_ntIOL1_IODLY_OV        ,           // output
                 //DPI_STS         => ntRef_ntIOL1_DPI_STS         ,
                   RX_DATA_DD      => ntRef_ntIOL1_RX_DATA_DD      ,
                   RX_DATA         => ntRef_ntIOL1_RX_DATA         ,
                   DO              => ntRef_ntIOL1_DO              ,
                   TO              => ntRef_ntIOL1_TO              ,

                   TX_DATA[0]       => <wire A_IA0 of <device CIM @[sx+3, sy+2]>>     ,    //IOL1 <- SIB (tile 0)
                   TX_DATA[1]       => <wire A_IA1 of <device CIM @[sx+3, sy+2]>>     ,
                 //TX_DATA[2]       => <wire A_IA2 of <device CIM @[sx+3, sy+2]>>     ,
                 //TX_DATA[3]       => <wire A_IA3 of <device CIM @[sx+3, sy+2]>>     ,
                 //TX_DATA[4]       => <wire A_IA4 of <device CIM @[sx+3, sy+2]>>     ,
                 //TX_DATA[5]       => <wire A_IB0 of <device CIM @[sx+3, sy+2]>>     ,
                   TS_CTRL          => <wire A_IB1 of <device CIM @[sx+3, sy+2]>>     ,
                 //TS_CTRL[1]       => <wire A_IB2 of <device CIM @[sx+3, sy+2]>>     ,
                 //TS_CTRL[2]       => <wire A_IB3 of <device CIM @[sx+3, sy+2]>>     ,
                 //TS_CTRL[3]       => <wire A_IB4 of <device CIM @[sx+3, sy+2]>>     ,
                 //DPI_STS_CLR      => <wire A_IC0 of <device CIM @[sx+3, sy+2]>>     ,
                   IODLY_CTRL[0]    => <wire A_IC1 of <device CIM @[sx+3, sy+2]>>     ,
                   IODLY_CTRL[1]    => <wire A_IC2 of <device CIM @[sx+3, sy+2]>>     ,
                   IODLY_CTRL[2]    => <wire A_IC3 of <device CIM @[sx+3, sy+2]>>     ,
                 //DPI_CTRL[0]      => <wire A_IC4 of <device CIM @[sx+3, sy+2]>>     ,
                 //DPI_CTRL[1]      => <wire A_ID0 of <device CIM @[sx+3, sy+2]>>     ,
                   SLIP             => <wire A_ID1 of <device CIM @[sx+3, sy+2]>>     ,
                   SYSCLK           => <wire A_ICLK of <device CIM @[sx+3, sy+2]>>    ,
                   CE               => <wire A_ICE of <device CIM @[sx+3, sy+2]>>     ,
                   LRS              => <wire A_IRS of <device CIM @[sx+3, sy+2]>>     ,

                   DIN               => ntRef_ntIOB1_DIN                              //IOL1 <- IOB1 (Tile 0) 

                 )
        @[sx+1,tile_pre_sy+2];

    // Hook up the outputs of IOL1 -> SRB (TILE 0)
    connect
        (            
            <pin A_IY0   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_IODLY_OV      ,
            <pin A_IY1   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA_DD      ,
            <pin A_IY2   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[0]   ,
            <pin A_IY3   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[1]   ,
          //<pin A_IQ0   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[2]   ,
          //<pin A_IQ1   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[3]   ,
          //<pin A_IQ2   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[4]   ,
          //<pin A_IQ3   of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_RX_DATA[5]   ,
            <pin A_IY6AB of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_DPI_STS[0]    ,
            <pin A_IY6CD of <device CIM @[sx+3,sy+2]>> => ntRef_ntIOL1_DPI_STS[1]
        );

    //
    // Instantiate the IOB1 @[2,2] in tile #pre. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOB_LB_%d_%d", sx+2, tile_pre_sy+2);
    device IOB_LB *strVar
        port map (
                   DO         => ntRef_ntIOL1_DO      ,   //Input from IOL1 (Tile 0)
                   TO         => ntRef_ntIOL1_TO       ,

                   DIN        => ntRef_ntIOB1_DIN       ,   //output
                   DIFFI_OUT     => ntRef_ntIOB1_DIFFI_OUT
                 )
        @[sx+2,tile_pre_sy+2];
};


/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-3CIM block tiles. Each IO block takes
             the size of 3 tiles. (North-WAST corner)

            ]

  Revision History:

*****************************************************************************************/
function place_io_l_3cim_4io_v_u_tile ( unsigned int tx, ty )
{
    place_io_l_1cim_v_u_tile (tx, ty);
    place_io_l_bab_2cim_v_tile (tx, ty-1);

    const unsigned int r_tile_y[] = { ty, ty-2 };
    
    unsigned int tile_y;
    
    foreach tile_y ( r_tile_y )
    {
        connect
            (
                <pin DIFFI_IN of <device IOB_LA @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1])>>   => <wire DIFFI_OUT of <device IOB_LB @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2]>> ,
                <pin DIFFI_IN of <device IOB_LB @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2]>>     => <wire DIFFI_OUT of <device IOB_LA @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1]>> ,
                
                <pin DO_IN of <device IOL_L @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire DO_OUT of <device IOL_L @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin TO_IN of <device IOL_L @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire TO_OUT of <device IOL_L @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>  
            );
    }
    
    
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-4CIM block tiles. Each IO block takes
             the size of 4 tiles. (WAST)

            ]

  Revision History:

*****************************************************************************************/
function place_io_l_4cim_6io_v_tile ( unsigned int tx, ty )
{
    place_io_l_aba_2cim_v_tile (tx, ty);
    place_io_l_bab_2cim_v_tile (tx, ty-2);
    
    const unsigned int r_tile_y[] = { ty, ty-1, ty-3 };
    
    unsigned int tile_y;
    
    foreach tile_y ( r_tile_y )
    {
        connect
            (
                <pin DIFFI_IN of <device IOB_LA @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire DIFFI_OUT of <device IOB_LB @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2]>> ,
                <pin DIFFI_IN of <device IOB_LB @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2]>>    => <wire DIFFI_OUT of <device IOB_LA @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1]>> ,
                
                <pin DO_IN of <device IOL_L @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire DO_OUT of <device IOL_L @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin TO_IN of <device IOL_L @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire TO_OUT of <device IOL_L @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>  
            );
    }
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO-3CIM block tiles. Each IO block takes
             the size of 3 tiles. (SOUTH-WAST corner)

            ]

  Revision History:

*****************************************************************************************/
function place_io_l_3cim_4io_v_d_tile ( unsigned int tx, ty )
{
    place_io_l_aba_2cim_v_tile (tx, ty);
    place_io_l_1cim_v_d_tile (tx, ty-2);
    
    const unsigned int r_tile_y[] = { ty, ty-1 };
    
    unsigned int tile_y;
    
    foreach tile_y ( r_tile_y )
    {
        connect
            (
                <pin DIFFI_IN of <device IOB_LA @([tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1])>>  => <wire DIFFI_OUT of <device IOB_LB @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2]>>  ,
                <pin DIFFI_IN of <device IOB_LB @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+2]>>    => <wire DIFFI_OUT of <device IOB_LA @[tx*TILE_NUM_SITE_X+2, tile_y*TILE_NUM_SITE_Y+1]>>  ,
                
                <pin DO_IN of <device IOL_L @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire DO_OUT of <device IOL_L @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>   ,
                <pin TO_IN of <device IOL_L @([tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+2])>>      => <wire TO_OUT of <device IOL_L @[tx*TILE_NUM_SITE_X+1, tile_y*TILE_NUM_SITE_Y+1]>>  
            );
    }
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO DELAY block tiles in horizontal. Each IO DELAY block takes
             the size of 1 tiles. 
             
     
              ---------|---------|---------|---------   
                                            DELAYCODEMUX[3,2]
                                            CLKDELAY[3,1]
                                            CLKDELAYMUX[3,0]
              ---------|---------|---------|---------  
              
            ]

  Revision History:

*****************************************************************************************/
function place_clk_delay_tile ( unsigned int tx, ty )
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    //
    // Layout CLKDELAY
    //
    // Allocate the wires driven by CLKDELAY
    // 
    sprintf(strVar, "ntCOUT_%d_%d", sx+3, sy+1);
    &wire ntRef_ntCOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntDLYOUT_%d_%d", sx+3, sy+1);
    &wire ntRef_ntDLYOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Layout DELAYCODEMUX
    //
    // Allocate the wires driven by DELAYCODEMUX
    // 
    sprintf(strVar, "ntDLL_INDELAY_OUT_%d_%d", sx+3, sy+2);
    &wire ntRef_ntDLL_INDELAY_OUT[7:0] = wire *strVar[7:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Instantiate the DELAYCODEMUX @[3,2]. All connecting nets should have been allocated
    //
    sprintf(strVar, "DELAYCODEMUX_%d_%d", sx+3, sy+2);
    device DELAYCODEMUX *strVar
        port map (
                   DLL_INDELAY_OUT => ntRef_ntDLL_INDELAY_OUT   //output
                 )
        @[sx+3,sy+2];  

    //
    // Instantiate the CLKDELAY @[3,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "CLKDELAY_%d_%d", sx+3, sy+1);
    device CLKDELAY *strVar
        port map (
                   COUT       => ntRef_ntCOUT       ,           // output
                   DLYOUT     => ntRef_ntDLYOUT     ,
                   
                   DLL_INDELAY_CNTL => ntRef_ntDLL_INDELAY_OUT    //input
                 )
        @[sx+3,sy+1];  

    //
    // Layout CLKDELAYMUX
    //
    // Allocate the wires driven by CLKDELAYMUX
    // 
    sprintf(strVar, "ntCLKDELAYMUX_OUT_%d_%d", sx+3, sy);
    &wire ntRef_ntCLKDELAYMUX_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Instantiate the CLKDELAYMUX @[3,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "CLKDELAYMUX_%d_%d", sx+3, sy);
    device CLKDELAYMUX *strVar
        port map (
                   OUT   =>   ntRef_ntCLKDELAYMUX_OUT          ,           // output

                   IN0   =>   ntRef_ntDLYOUT        
                 )
        @[sx+3,sy]; 
           
    
}


/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within DLL block tiles in horizontal. Each DLL block takes
             the size of 1 tiles. 
             
     
              ---------|---------|-----------------|---------   
                                  DLL_CLKMUX2[2,2]   C[3,2]
               V[0,1]             DLL_CLKMUX1[2,1]   DLL1[3,1]
               G[0,0]   R[1,0]    I[2,0]             DLL0[3,0]
              ---------|---------|-----------------|---------  
              
            ]

  Revision History:

*****************************************************************************************/
function place_dll_tile ( unsigned int tx, ty )
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // The wires are spread out in 2 tiles. Pre-calculate the lower-left corner of all 2 tiles
    unsigned int tile_0_sx =  tx      * TILE_NUM_SITE_X;
    unsigned int tile_1_sx = (tx + 1) * TILE_NUM_SITE_X;
    
    //
    // Layout DLL0
    //
    // Allocate the wires driven by DLL0
    // 
    sprintf(strVar, "ntDLL0_LOCK_%d_%d", sx+3, sy);
    &wire ntRef_ntDLL0_LOCK = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntDLL0_DIV_CLK_OSC_OUT_%d_%d", sx+3, sy);
    &wire ntRef_ntDLL0_DIV_CLK_OSC_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntDLL0_DLL_CODE_%d_%d", sx+3, sy);
    &wire ntRef_ntDLL0_DLL_CODE[7:0] = wire *strVar[7:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
 
    
    //
    // Layout DLL1
    //
    // Allocate the wires driven by DLL1
    // 
    sprintf(strVar, "ntDLL1_LOCK_%d_%d", sx+3, sy+1);
    &wire ntRef_ntDLL1_LOCK = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntDLL1_DIV_CLK_OSC_OUT_%d_%d", sx+3, sy+1);
    &wire ntRef_ntDLL1_DIV_CLK_OSC_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntDLL1_DLL_CODE_%d_%d", sx+3, sy+1);
    &wire ntRef_ntDLL1_DLL_CODE[7:0] = wire *strVar[7:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;  
    
    //
    // Layout DLL_CLKMUX1 in the tile #0
    //
    // Allocate the wires driven by DLL_CLKMUX1 
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntDLL_CLKMUX1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the DLL_CLKMUX1 @[2,1] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "DLL_CLKMUX_%d_%d", sx+2, sy+1);
    device DLL_CLKMUX *strVar
        port map (
                     OUT         => ntRef_ntDLL_CLKMUX1_OUT                      ,
                     CLK_INPUT   => <wire A_ICLK of <device CIM @[sx+3, sy+2]>>  ,
                     ZERO        => 1'b0
                 )
        @[sx+2,sy+1];
        
    //
    // Layout DLL_CLKMUX2 in the tile #0
    //
    // Allocate the wires driven by DLL_CLKMUX2
    //
    sprintf(strVar, "ntOUT_%d_%d", sx+2, sy+2);
    &wire ntRef_ntDLL_CLKMUX2_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="LOGIC" */ ;
    
    //
    // Instantiate the DLL_CLKMUX2 @[2,2] in tile #0. All connecting nets should have been allocated
    //
    sprintf(strVar, "DLL_CLKMUX_%d_%d", sx+2, sy+2);
    device DLL_CLKMUX *strVar
        port map (
                     OUT         => ntRef_ntDLL_CLKMUX2_OUT                        ,
                     CLK_INPUT   => <wire S_ICLK of <device CIM @[sx+3, sy+2]>>    ,
                     ZERO        => 1'b0
                 )
        @[sx+2,sy+2];
    
    //
    // Instantiate the DLL0 @[3,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "DLL0_%d_%d", sx+3, sy);
    device DLL *strVar
        port map (
                   LOCK                => ntRef_ntDLL0_LOCK                ,           // output
                   DIV_CLK_OSC_OUT     => ntRef_ntDLL0_DIV_CLK_OSC_OUT     ,
                   DLL_CODE   => ntRef_ntDLL0_DLL_CODE   ,
                   
                   FREEZE_DLL_OSC      => <wire A_IA0  of <device CIM @[sx+3, sy+2]>>    ,    //SIB -> DLL
                   UPDATE_N            => <wire A_IA1  of <device CIM @[sx+3, sy+2]>>    ,
                   //CE                  => <wire A_ICE  of <device CIM @[sx+3, sy+2]>>    ,
                   DLL_RST             => <wire A_IRS  of <device CIM @[sx+3, sy+2]>>    ,
                   IOCLK               => ntRef_ntDLL_CLKMUX1_OUT 
                 )
        @[sx+3,sy]; 
        
    // Hook up the outputs of DLL -> SRB
    connect
        (
          <pin A_IY0 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntDLL0_LOCK                   ,
          <pin A_IY1 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntDLL0_DIV_CLK_OSC_OUT        ,
          <pin A_IY2 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntDLL0_DLL_CODE[0]   ,
          <pin A_IY3 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntDLL0_DLL_CODE[1]   ,
          <pin A_IQ0 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntDLL0_DLL_CODE[2]   ,
          <pin A_IQ1 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntDLL0_DLL_CODE[3]   ,
          <pin A_IQ2 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntDLL0_DLL_CODE[4]   ,
          <pin A_IQ3 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntDLL0_DLL_CODE[5]   ,
          <pin A_IY6AB of <device CIM @[sx+3,sy+2]>> => ntRef_ntDLL0_DLL_CODE[6]   ,
          <pin A_IY6CD of <device CIM @[sx+3,sy+2]>> => ntRef_ntDLL0_DLL_CODE[7]   
        );
        
    //
    // Instantiate the DLL1 @[3,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "DLL1_%d_%d", sx+3, sy+1);
    device DLL *strVar
        port map (
                   LOCK                => ntRef_ntDLL1_LOCK                ,           // output
                   DIV_CLK_OSC_OUT     => ntRef_ntDLL1_DIV_CLK_OSC_OUT     ,
                   DLL_CODE   => ntRef_ntDLL1_DLL_CODE   ,
                   
                   FREEZE_DLL_OSC      => <wire S_IA0  of <device CIM @[sx+3, sy+2]>>    ,    //SIB -> DLL
                   UPDATE_N            => <wire S_IA1  of <device CIM @[sx+3, sy+2]>>    ,
                   //CE                  => <wire A_ICE  of <device CIM @[sx+3, sy+2]>>    ,
                   DLL_RST             => <wire S_IRS  of <device CIM @[sx+3, sy+2]>>    ,
                   IOCLK               => ntRef_ntDLL_CLKMUX2_OUT   
                 )
        @[sx+3,sy+1]; 
        
    // Hook up the outputs of DLL -> SRB
    connect
        (
          <pin S_IY0 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntDLL1_LOCK                   ,
          <pin S_IY1 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntDLL1_DIV_CLK_OSC_OUT        ,
          <pin S_IY2 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntDLL1_DLL_CODE[0]   ,
          <pin S_IY3 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntDLL1_DLL_CODE[1]   ,
          <pin S_IQ0 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntDLL1_DLL_CODE[2]   ,
          <pin S_IQ1 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntDLL1_DLL_CODE[3]   ,
          <pin S_IQ2 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntDLL1_DLL_CODE[4]   ,
          <pin S_IQ3 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntDLL1_DLL_CODE[5]   ,
          <pin S_IY6AB of <device CIM @[sx+3,sy+2]>> => ntRef_ntDLL1_DLL_CODE[6]   ,
          <pin S_IY6CD of <device CIM @[sx+3,sy+2]>> => ntRef_ntDLL1_DLL_CODE[7]   
        );

};

/**VFunction******************************************************************************

  Author    [xiawei]

  Abstract  [This function places the devices within DLL_MUX block tiles in horizontal. Each DLL block takes
             the size of 1 tiles. 
             
     
              ---------|---------|-----------------|---------   
                           DLL_MUX1[1,2]        DLL_CLKMUX2[2,2]   C[3,2]
               V[0,1]   DLL_MUX0[1,1]          DLL_CLKMUX1[2,1]   DLL1[3,1]
               G[0,0]   R[1,0]    I[2,0]             DLL0[3,0]
              ---------|---------|-----------------|---------  
              
            ]

  Revision History:

*****************************************************************************************/
function place_dll_withmux_tile ( unsigned int tx, ty )
{
    place_dll_tile(tx, ty);

    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // Layout DLL_MUX0 in the tile #0
    // Allocate the wires driven by DLL_MUX0 
    sprintf(strVar, "ntDLL_MUX0_O_%d_%d", sx+1, sy+1);
    &wire ntRef_ntDLL_MUX0_O[3:0] = wire *strVar[3:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;    
    
    // Instantiate the DLL_MUX0 @[1,1] in tile #0. All connecting nets should have been allocated
    sprintf(strVar, "DLL_MUX_%d_%d", sx+1, sy+1);
    device DLL_MUX *strVar
        port map (
                     O          => ntRef_ntDLL_MUX0_O
                 )
        @[sx+1,sy+1];
        
    // Layout DLL_MUX1 in the tile #0
    // Allocate the wires driven by DLL_MUX1
    sprintf(strVar, "ntDLL_MUX1_O_%d_%d", sx+1, sy+1);
    &wire ntRef_ntDLL_MUX1_O[3:0] = wire *strVar[3:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;    
    
    // Instantiate the DLL_MUX1 @[1,2] in tile #0. All connecting nets should have been allocated
    sprintf(strVar, "DLL_MUX_%d_%d", sx+1, sy+2);
    device DLL_MUX *strVar
        port map (
                     O          => ntRef_ntDLL_MUX1_O
                 )
        @[sx+1,sy+2];

    connect
        (
          <pin IOCLK  of <device DLL_CLKMUX @[tx*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+1]>>  => ntRef_ntDLL_MUX0_O,
          <pin IOCLK  of <device DLL_CLKMUX @[tx*TILE_NUM_SITE_X+2, ty*TILE_NUM_SITE_Y+2]>>  => ntRef_ntDLL_MUX1_O
        );

};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within PLL block tiles in horizontal. Each PLL block takes
             the size of 8 tiles. 
              IF dir == -1, PLL in top
              ---------|---------|---------|---------   
                                             C[3,2]
               V[0,1]                                    Tile 0
               G[0,0]   R[1,0]    I[2,0]    
              ---------|---------|---------|---------  
                                             C[3,2]
               V[0,1]                                    Tile 1
               G[0,0]   R[1,0]    I[2,0]    
              ---------|---------|---------|---------  
                                             C[3,2]
               V[0,1]                                    Tile 2
               G[0,0]   R[1,0]    I[2,0]    
              ---------|---------|---------|---------  
                                             C[3,2]
               V[0,1]                                    Tile 3
               G[0,0]   R[1,0]    I[2,0]        
              ---------|---------|---------|---------   
               FB_M[0,2]   CK_M0[1,2]   CK_M1[2,2]  C[3,2]
               V[0,1]                                    Tile 4
               G[0,0]   R[1,0]    I[2,0]     PLL[3,0]
              ---------|---------|---------|---------  
                                             C[3,2]
               V[0,1]                                    Tile 5
               G[0,0]   R[1,0]    I[2,0]    
              ---------|---------|---------|---------  
                                             C[3,2]
               V[0,1]                                    Tile 6
               G[0,0]   R[1,0]    I[2,0]    
              ---------|---------|---------|---------     
                                             C[3,2]
               V[0,1]                                    Tile 7
               G[0,0]   R[1,0]    I[2,0]    
              ---------|---------|---------|---------   
              
              //
              IF dir == 1, PLL in bottom
              ---------|---------|---------|---------   
                                             C[3,2]
               V[0,1]                                    Tile 7
               G[0,0]   R[1,0]    I[2,0]    
              ---------|---------|---------|---------  
                                             C[3,2]
               V[0,1]                                    Tile 6
               G[0,0]   R[1,0]    I[2,0]    
              ---------|---------|---------|---------  
                                             C[3,2]
               V[0,1]                                    Tile 5
               G[0,0]   R[1,0]    I[2,0]    
              ---------|---------|---------|---------  
               FB_M[0,2]   CK_M0[1,2]   CK_M1[2,2]  C[3,2]
               V[0,1]                                    Tile 4
               G[0,0]   R[1,0]    I[2,0]     PLL[3,0]   
              ---------|---------|---------|---------   
                                             C[3,2]
               V[0,1]                                    Tile 3
               G[0,0]   R[1,0]    I[2,0]     
              ---------|---------|---------|---------  
                                             C[3,2]
               V[0,1]                                    Tile 2
               G[0,0]   R[1,0]    I[2,0]    
              ---------|---------|---------|---------  
                                             C[3,2]
               V[0,1]                                    Tile 1
               G[0,0]   R[1,0]    I[2,0]    
              ---------|---------|---------|---------     
                                             C[3,2]
               V[0,1]                                    Tile 0
               G[0,0]   R[1,0]    I[2,0]    
              ---------|---------|---------|---------    
            ]

  Revision History:

*****************************************************************************************/
function place_pll_tile ( unsigned int tx, ty, dir)
{
    string strVar;
    
    // Layout devices in 3 tiles. 
    place_base_tile (tx, ty);
    place_base_tile (tx, ty+1*dir);
    place_base_tile (tx, ty+2*dir);  
    place_base_tile (tx, ty+3*dir);
    place_base_tile (tx, ty+4*dir);
    place_base_tile (tx, ty+5*dir);  
    place_base_tile (tx, ty+6*dir);
    place_base_tile (tx, ty+7*dir);
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // The wires are spread out in 8 tiles. Pre-calculate the lower-left corner of all 8 tiles
    unsigned int tile_0_sy =  ty          * TILE_NUM_SITE_Y;
    unsigned int tile_1_sy = (ty + 1*dir) * TILE_NUM_SITE_Y;
    unsigned int tile_2_sy = (ty + 2*dir) * TILE_NUM_SITE_Y;
    unsigned int tile_3_sy = (ty + 3*dir) * TILE_NUM_SITE_Y;
    unsigned int tile_4_sy = (ty + 4*dir) * TILE_NUM_SITE_Y;
    unsigned int tile_5_sy = (ty + 5*dir) * TILE_NUM_SITE_Y;
    unsigned int tile_6_sy = (ty + 6*dir) * TILE_NUM_SITE_Y;
    unsigned int tile_7_sy = (ty + 7*dir) * TILE_NUM_SITE_Y;

    //
    // Layout PLL_CLKFB_MUX
    //
    // Allocate the wires driven by PLL_CLKFB_MUX
    // 
    sprintf(strVar, "ntFBOUT_%d_%d", sx, tile_4_sy+2);
    &wire ntRef_ntFBOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    //
    // Instantiate the PLL_CLKFB_MUX @[0,2]. All connecting nets should have been allocated
    //
    sprintf(strVar, "PLL_CLKFB_MUX_%d_%d", sx, tile_4_sy+2);
    device PLL_CLKFB_MUX *strVar
        port map (
                   FBOUT        => ntRef_ntFBOUT        ,           // output

                   CLKFB[1]                => <wire S_ICLK of <device CIM @[sx+3, tile_2_sy+2]>>          ,
                   CLKFB[6]                => <wire A_ICLK of <device CIM @[sx+3, tile_5_sy+2]>>          ,
                   CLKFB[7]                => <wire S_ICLK of <device CIM @[sx+3, tile_5_sy+2]>>          ,
                   //CLKFB[10]             => 1'b0                                                          ,   
                   //CLKFB[11]             => 1'b0                                                          ,  
                   CLKFB[12]             => 1'b0                                                          , 
                   CLKFB[13]             => 1'b0                                                          ,   
                   CLKFB[14]             => 1'b0          
                 )
        @[sx,tile_4_sy+2]; 

    //
    // Allocate the wires driven by PLL_CLKIN_MUX1
    // 
    sprintf(strVar, "ntCLKOUT_%d_%d", sx+1, tile_4_sy+2);
    &wire ntRef_ntCLKOUT1 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    //
    // Instantiate the PLL_CLKIN_MUX @[1,2]. All connecting nets should have been allocated
    //
    sprintf(strVar, "PLL_CLKIN_MUX_%d_%d", sx+1, tile_4_sy+2);
    device PLL_CLKIN_MUX *strVar
        port map (
                   CLKOUT        => ntRef_ntCLKOUT1        ,           // output 

                   CLKIN[1]               => <wire S_ICLK of <device CIM @[sx+3, tile_4_sy+2]>>          ,
                   CLKIN[2]               => <wire A_ICLK of <device CIM @[sx+3, tile_4_sy+2]>>           ,
                   CLKIN[5]               => <wire A_ICLK of <device CIM @[sx+3, tile_2_sy+2]>>
                 )
        @[sx+1,tile_4_sy+2]; 

    //
    // Allocate the wires driven by PLL_CLKIN_MUX2
    // 
    sprintf(strVar, "ntCLKOUT_%d_%d", sx+2, tile_4_sy+2);
    &wire ntRef_ntCLKOUT2 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    //
    // Instantiate the PLL_CLKIN_MUX @[2,2]. All connecting nets should have been allocated
    //
    sprintf(strVar, "PLL_CLKIN_MUX_%d_%d", sx+2, tile_4_sy+2);
    device PLL_CLKIN_MUX *strVar
        port map (
                   CLKOUT        => ntRef_ntCLKOUT2        ,           // output
                   
                   CLKIN[1]               => <wire S_ICLK of <device CIM @[sx+3, tile_3_sy+2]>>          ,
                   CLKIN[2]               => <wire A_ICLK of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CLKIN[5]               => <wire S_ICLK of <device CIM @[sx+3, tile_6_sy+2]>>
                 )
        @[sx+2,tile_4_sy+2]; 

    //
    // Layout PLL
    //
    // Allocate the wires driven by PLL
    // 
    sprintf(strVar, "ntCLKOUT_%d_%d", sx+3, tile_4_sy);
    &wire ntRef_ntCLKOUT[4:0] = wire *strVar[4:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntPLL_LOCK_%d_%d", sx+3, tile_4_sy);
    &wire ntRef_ntPLL_LOCK = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntO_FDDN_%d_%d", sx+3, tile_4_sy);
    &wire ntRef_ntO_FDDN = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntO_FDUP_%d_%d", sx+3, tile_4_sy);
    &wire ntRef_ntO_FDUP = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
      
    sprintf(strVar, "ntTEST_CLK_O_%d_%d", sx+3, tile_4_sy);
    &wire ntRef_ntTEST_CLK_O = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
       
       
    //
    // Instantiate the PLL @[3,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "PLL_%d_%d", sx+3, tile_4_sy);
    device PLL *strVar
        port map (
                   CLKOUT        => ntRef_ntCLKOUT        ,           // output
                   PLL_LOCK      => ntRef_ntPLL_LOCK      ,
                   O_FDDN        => ntRef_ntO_FDDN        ,
                   O_FDUP        => ntRef_ntO_FDUP        ,
                   TEST_CLK_O    => ntRef_ntTEST_CLK_O    ,
                                      
                   CIM_DYNDU1[0]           => <wire A_IA0 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNDU1[1]           => <wire A_IA1 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNDU1[2]           => <wire A_IA2 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNDU1[3]           => <wire A_IA3 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNDU2[0]           => <wire A_IB0 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNDU2[1]           => <wire A_IB1 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNDU2[2]           => <wire A_IB2 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNDU2[3]           => <wire A_IB3 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNDU3[0]           => <wire A_IC0 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNDU3[1]           => <wire A_IC1 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNDU3[2]           => <wire A_IC2 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNDU3[3]           => <wire A_IC3 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNDU4[0]           => <wire A_ID0 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNDU4[1]           => <wire A_ID1 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNDU4[2]           => <wire A_ID2 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNDU4[3]           => <wire A_ID3 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNODIV[0]          => <wire A_IA4 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNODIV[1]          => <wire A_IB4 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNODIV[2]          => <wire A_IC4 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNODIV[3]          => <wire A_ID4 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNODIV[4]          => <wire A_IAD of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNODIV[5]          => <wire A_IBD of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNPS1[0]           => <wire S_IA0 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNPS1[1]           => <wire S_IA1 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNPS1[2]           => <wire S_IA2 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNPS1[3]           => <wire S_IA3 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNPS2[0]           => <wire S_IB0 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNPS2[1]           => <wire S_IB1 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNPS2[2]           => <wire S_IB2 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNPS2[3]           => <wire S_IB3 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNPS3[0]           => <wire S_IC0 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNPS3[1]           => <wire S_IC1 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNPS3[2]           => <wire S_IC2 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNPS3[3]           => <wire S_IC3 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNPS4[0]           => <wire S_ID0 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNPS4[1]           => <wire S_ID1 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNPS4[2]           => <wire S_ID2 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   CIM_DYNPS4[3]           => <wire S_ID3 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   DYN_FDIV[0]             => <wire S_IA4 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   DYN_FDIV[1]             => <wire S_IB4 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   DYN_FDIV[2]             => <wire S_IC4 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   DYN_FDIV[3]             => <wire S_ID4 of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   DYN_FDIV[4]             => <wire S_IAD of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   DYN_FDIV[5]             => <wire S_IBD of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   DYN_IDIV[0]             => <wire A_IA0 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_IDIV[1]             => <wire A_IA1 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_IDIV[2]             => <wire A_IA2 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_IDIV[3]             => <wire A_IA3 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_IDIV[4]             => <wire A_IA4 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_IDIV[5]             => <wire A_IAD of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_ODIV2_SEL_IN[0]     => <wire A_IB0 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_ODIV2_SEL_IN[1]     => <wire A_IB1 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_ODIV2_SEL_IN[2]     => <wire A_IB2 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_ODIV2_SEL_IN[3]     => <wire A_IB3 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_ODIV2_SEL_IN[4]     => <wire A_IB4 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_ODIV2_SEL_IN[5]     => <wire A_IBD of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_ODIV3_SEL_IN[0]     => <wire A_IC0 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_ODIV3_SEL_IN[1]     => <wire A_IC1 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_ODIV3_SEL_IN[2]     => <wire A_IC2 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_ODIV3_SEL_IN[3]     => <wire A_IC3 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_ODIV3_SEL_IN[4]     => <wire A_IC4 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_ODIV3_SEL_IN[5]     => <wire A_ICD of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_ODIV4_SEL_IN[0]     => <wire A_ID0 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_ODIV4_SEL_IN[1]     => <wire A_ID1 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_ODIV4_SEL_IN[2]     => <wire A_ID2 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_ODIV4_SEL_IN[3]     => <wire A_ID3 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_ODIV4_SEL_IN[4]     => <wire A_ID4 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   DYN_ODIV4_SEL_IN[5]     => <wire A_IDD of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   GATEO[0]                => <wire S_IA0 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   GATEO[1]                => <wire S_IA1 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   GATEO[2]                => <wire S_IA2 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   GATEO[3]                => <wire S_IA3 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   GATEO[4]                => <wire S_IA4 of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   RESET_IDIV              => <wire A_IRS of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   RESET_ODIV              => <wire A_ICE of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   PLL_RST                 => <wire S_IRS of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   PLLPWD                  => <wire A_ICD of <device CIM @[sx+3, tile_3_sy+2]>>           ,
                   TEST_CLKIN              => <wire A_ICLK of <device CIM @[sx+3, tile_1_sy+2]>>          ,
                   CIM_MFG_VCP             => <wire S_IAD of <device CIM @[sx+3, tile_2_sy+2]>>     ,
                   CIM_DYN_CLKIN_SEL       => <wire S_IBD of <device CIM @[sx+3, tile_2_sy+2]>>           ,
                   
                   CLKFB             => ntRef_ntFBOUT,
                   CLKIN1        => ntRef_ntCLKOUT1,
                   CLKIN2        => ntRef_ntCLKOUT2
                 )
        @[sx+3,tile_4_sy]; 
     
    // Hook up the outputs of PLL -> SRB
    connect
        (
            <pin A_IY0 of <device CIM @[sx+3,tile_4_sy+2]>> => ntRef_ntO_FDDN       ,
            <pin A_IY1 of <device CIM @[sx+3,tile_4_sy+2]>> => ntRef_ntO_FDUP       ,
            <pin A_IY2 of <device CIM @[sx+3,tile_4_sy+2]>> => ntRef_ntPLL_LOCK     ,
            <pin A_IY3 of <device CIM @[sx+3,tile_4_sy+2]>> => ntRef_ntTEST_CLK_O
        );
};

/**VFunction******************************************************************************

  Author    [xiawei]

  Abstract  [This function places the devices within PRE_GMUX_LR block tiles. Each DLL block takes
             the size of 1 tiles. 
             
     
              ---------|---------|---------|---------   

                    
                                            GMUX_LR[3,0]
              ---------|---------|---------|---------  
              
            ]

  Revision History:

*****************************************************************************************/
function place_pre_gmux_lr_w_tile ( unsigned int tx, ty )
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // Layout PRE_GMUX_L
    // Allocate the wires driven by PRE_GMUX_LR
    sprintf(strVar, "ntCLKOUT_%d_%d", sx+3, sy);
    &wire ntRef_ntCLKOUT[7:0] = wire *strVar[7:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
     
    // Instantiate the PREGMUX_LR @[3,0]. All connecting nets should have been allocated
    sprintf(strVar, "PREGMUX_L");
    device PREGMUX_LR *strVar
        port map (
                   CLKOUT   => ntRef_ntCLKOUT              // output
                 )
        @[sx+3,sy];      
};

/**VFunction******************************************************************************

  Author    [xiawei]

  Abstract  [This function places the devices within PRE_GMUX_LR block tiles. Each DLL block takes
             the size of 1 tiles. 
             
     
              ---------|---------|---------|---------   

                    
                                            GMUX_LR[3,0]
              ---------|---------|---------|---------  
              
            ]

  Revision History:

*****************************************************************************************/
function place_pre_gmux_lr_e_tile ( unsigned int tx, ty )
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // Layout PRE_GMUX_L
    // Allocate the wires driven by PRE_GMUX_LR
    sprintf(strVar, "ntCLKOUT_%d_%d", sx+3, sy);
    &wire ntRef_ntCLKOUT[7:0] = wire *strVar[7:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
     
    // Instantiate the PREGMUX_LR @[3,0]. All connecting nets should have been allocated
    sprintf(strVar, "PREGMUX_R");
    device PREGMUX_LR *strVar
        port map (
                   CLKOUT   => ntRef_ntCLKOUT              // output
                 )
        @[sx+3,sy];  
    
};

/**VFunction******************************************************************************

  Author    [XiaWei]

  Abstract  [This function places the devices within PREGMUX_TB block tiles. Each PREGMUX_TB block takes
             the size of 1 tiles. 
             
     
              ---------|---------|---------|---------   

                   
              PREGMUX_TB[3,0]    PCLKMUX[3,0]
              ---------|---------|---------|---------  
              
            ]

  Revision History:

*****************************************************************************************/
function place_pre_gmux_tb_tile ( unsigned int tx, ty )
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    // Layout PREGMUX_TB
    // Allocate the wires driven by PREGMUX_TB
    sprintf(strVar, "ntCLKOUT_%d_%d", sx+3, sy);
    &wire ntRef_ntCLKOUT[9:0] = wire *strVar[9:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
     
    // Instantiate the PREGMUX_TB @[3,0]. All connecting nets should have been allocated
    sprintf(strVar, "PREGMUX_TB_%d_%d", sx+3, sy);
    device PREGMUX_TB *strVar
        port map (
                   CLKOUT   => ntRef_ntCLKOUT              // output
                 )
        @[sx+3,sy]; 


    // Layout PCLKMUX
    // Allocate the wires driven by PCLKMUX
    sprintf(strVar, "ntOUT_%d_%d", sx+3, sy);
    &wire ntRef_ntOUT[9:0] = wire *strVar[9:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
     
    // Instantiate the PCLKMUX @[3,0]. All connecting nets should have been allocated
    sprintf(strVar, "PCLKMUX_%d_%d", sx+3, sy);
    device PCLKMUX *strVar
        port map (
                   OUT   => ntRef_ntOUT              // output
                 )
        @[sx+3,sy];     
        
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within POST_GMUX block tiles. Each POST_GMUX block takes
             the size of 1 tiles. 
             
     
              ---------|---------|---------|---------   

                       
                                            POST_GMUX[3,0]
              ---------|---------|---------|---------  
              
            ]

  Revision History:

*****************************************************************************************/
function place_post_gmux_tile ( unsigned int tx, ty )
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    //
    // Layout POST_GMUX
    //
    // Allocate the wires driven by POST_GMUX
    // 
    
    // TO NORTH WEST 
    sprintf(strVar, "ntGCLK_0_A_%d_%d", sx+3, sy);
    &wire ntRef_ntGCLK_0_A[13:0] = wire *strVar[13:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntGCLK_0_B_%d_%d", sx+3, sy);
    &wire ntRef_ntGCLK_0_B[13:0] = wire *strVar[13:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    
    // TO NORTH EAST
    sprintf(strVar, "ntGCLK_1_A_%d_%d", sx+3, sy);
    &wire ntRef_ntGCLK_1_A[13:0] = wire *strVar[13:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntGCLK_1_B_%d_%d", sx+3, sy);
    &wire ntRef_ntGCLK_1_B[13:0] = wire *strVar[13:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    
    // TO SOUTH WEST
    sprintf(strVar, "ntGCLK_2_A_%d_%d", sx+3, sy);
    &wire ntRef_ntGCLK_2_A[13:0] = wire *strVar[13:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntGCLK_2_B_%d_%d", sx+3, sy);
    &wire ntRef_ntGCLK_2_B[13:0] = wire *strVar[13:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    

    // TO SOUTH EAST
    sprintf(strVar, "ntGCLK_3_A_%d_%d", sx+3, sy);
    &wire ntRef_ntGCLK_3_A[13:0] = wire *strVar[13:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntGCLK_3_B_%d_%d", sx+3, sy);
    &wire ntRef_ntGCLK_3_B[13:0] = wire *strVar[13:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;

    //
    // Instantiate the POST_GMUX @[3,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "POST_GMUX");
    device POST_GMUX *strVar
        port map (
                     GCLK_0_A => ntRef_ntGCLK_0_A   ,
                     GCLK_0_B => ntRef_ntGCLK_0_B   ,
                                                    
                     GCLK_1_A => ntRef_ntGCLK_1_A   ,
                     GCLK_1_B => ntRef_ntGCLK_1_B   ,
                                                    
                     GCLK_2_A => ntRef_ntGCLK_2_A   ,
                     GCLK_2_B => ntRef_ntGCLK_2_B   ,
                                                    
                     GCLK_3_A => ntRef_ntGCLK_3_A   ,
                     GCLK_3_B => ntRef_ntGCLK_3_B
                 ) 
        @[sx+3,sy]; 
};


/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within REGIONAL_H_CLKMUX block tiles. Each REGIONAL_H_CLKMUX block takes
             the size of 1 tiles. 
             
     
              ---------|---------|---------|---------   

                                            REG_HMUX_B[3,1]
                                            REG_HMUX_A[3,0]
              ---------|---------|---------|---------  
              
            ]

  Revision History:

*****************************************************************************************/
function place_reg_hmux_tile ( unsigned int tx, ty )
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    //
    // Layout REG_HMUX_A
    //
    // Allocate the wires driven by REG_HMUX_A
    // 
    sprintf(strVar, "ntHCLK_%d_%d", sx+3, sy);
    &wire ntRef_ntREG_HMUX_A_HCLK[3:0] = wire *strVar[3:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;

    //
    // Layout REG_HMUX_B
    //
    // Allocate the wires driven by REG_HMUX_B
    // 
    sprintf(strVar, "ntHCLK_%d_%d", sx+3, sy+1);
    &wire ntRef_ntREG_HMUX_B_HCLK[3:0] = wire *strVar[3:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
     
    //
    // Instantiate the REG_HMUX_A @[3,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "REG_HMUX_%d_%d", sx+3, sy);
    device REG_HMUX *strVar
        port map (
                   HCLK   => ntRef_ntREG_HMUX_A_HCLK             // output     
                 )
        @[sx+3,sy]; 

    //
    // Instantiate the REG_HMUX_B @[3,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "REG_HMUX_%d_%d", sx+3, sy+1);
    device REG_HMUX *strVar
        port map (
                   HCLK   => ntRef_ntREG_HMUX_B_HCLK             // output     
                 )
        @[sx+3,sy+1]; 
};


/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within REGIONAL_V_CLKMUX block tiles. Each REGIONAL_V_CLKMUX block takes
             the size of 1 tiles. 
             
     
              ---------|---------|---------|---------   
                                            RCLK_BUF1[3,2]
                                            RCLK_BUF0[3,1]
                                            REG_VMUX[3,0]
              ---------|---------|---------|---------  
              
            ]

  Revision History:

*****************************************************************************************/
function place_reg_vmux_tile ( unsigned int tx, ty )
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    //
    // Layout REG_VMUX
    //
    // Allocate the wires driven by REG_VMUX
    // 
    sprintf(strVar, "ntREGCLK_%d_%d", sx+3, sy);
    &wire ntRef_ntREGCLK[1:0] = wire *strVar[1:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;

    //
    // Instantiate the REG_VMUX @[3,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "REG_VMUX_%d_%d", sx+3, sy);
    device REG_VMUX *strVar
        port map (
                   REGCLK   => ntRef_ntREGCLK             // output     
                 )
        @[sx+3,sy]; 


    //
    // Layout RCLK_BUF0
    //
    // Allocate the wires driven by RCLK_BUF0
    // 
    sprintf(strVar, "ntCLKOUT0_%d_%d", sx+3, sy+1);
    &wire ntRef_ntCLKOUT0 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Instantiate the RCLK_BUF @[3,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "RCLK_BUF_%d_%d", sx+3, sy+1);
    device RCLK_BUF *strVar
        port map (
                   CLKOUT   => ntRef_ntCLKOUT0 ,            // output     
                   CLKIN    => ntRef_ntREGCLK[0]
                 )
        @[sx+3,sy+1]; 


    //
    // Layout RCLK_BUF1
    //
    // Allocate the wires driven by RCLK_BUF1
    // 
    sprintf(strVar, "ntCLKOUT1_%d_%d", sx+3, sy+2);
    &wire ntRef_ntCLKOUT1 = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Instantiate the RCLK_BUF @[3,2]. All connecting nets should have been allocated
    //
    sprintf(strVar, "RCLK_BUF_%d_%d", sx+3, sy+2);
    device RCLK_BUF *strVar
        port map (
                   CLKOUT   => ntRef_ntCLKOUT1 ,            // output     
                   CLKIN    => ntRef_ntREGCLK[1]
                 )
        @[sx+3,sy+2]; 

};


/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IOCLKGEN block tiles. Each IOCLKGEN block takes
             the size of 1 tiles. 
             
     
              ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
           BRGCLKGATE0[0,2] BRGCLKGATE1[1,2]       
           IOCLKGATE0[0,1]  IOCLKGATE1[1,1]  IOCLKGATE2[2,1]  IOCLKGATE3[3,1]   USCMMUX2TO1[0,1] USCMMUX2TO1[1,1] USCMMUX2TO1[2,1] USCMMUX2TO1[3,1]
                            IOCLKMUX[1,0]                                       IOCLKDIV[0,0]   IOCLKDIV[1,0]   IOCLKDIV[2,0]   IOCLKDIV[3,0]
              ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
                                      Tile 0                                                               Tile 1

            ]

  Revision History:

*****************************************************************************************/
function place_ioclkgen_tb_tile ( unsigned int tx, ty, flag )
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    unsigned int tile_1_sx = (tx+1) * TILE_NUM_SITE_X; 
    
    //========= TILE 0 ==========//
    
    //
    // Layout IOCLKMUX
    //
    // Allocate the wires driven by IOCLKMUX
    //
    sprintf(strVar, "ntIOCLK_%d_%d", sx+1, sy);
    &wire ntRef_ntIOCLK[3:0] = wire *strVar[3:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Layout GATE
    //
    // Allocate the wires driven by IOCLKGATE0
    //
    sprintf(strVar, "ntIOCLKGATE0_OUT_%d_%d", sx, sy+1);
    &wire ntRef_ntIOCLKGATE0_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by IOCLKGATE1
    //
    sprintf(strVar, "ntIOCLKGATE1_OUT_%d_%d", sx+1, sy+1);
    &wire ntRef_ntIOCLKGATE1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by IOCLKGATE2
    //
    sprintf(strVar, "ntIOCLKGATE2_OUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntIOCLKGATE2_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by IOCLKGATE3
    //
    sprintf(strVar, "ntIOCLKGATE3_OUT_%d_%d", sx+3, sy+1);
    &wire ntRef_ntIOCLKGATE3_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by BRGCLKGATE0
    //
    sprintf(strVar, "ntBRGCLKGATE0_OUT_%d_%d", sx, sy+2);
    &wire ntRef_ntBRGCLKGATE0_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by BRGCLKGATE1
    //
    sprintf(strVar, "ntBRGCLKGATE1_OUT_%d_%d", sx+1, sy+2);
    &wire ntRef_ntBRGCLKGATE1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;    
    

     
    //========= TILE 1 ==========//
    
    //
    // Layout IOCLKDIV
    //
    // Allocate the wires driven by IOCLKDIV0
    //
    sprintf(strVar, "ntIOCLKDIV0_CLKDIVOUT_%d_%d", tile_1_sx, sy);
    &wire ntRef_ntIOCLKDIV0_CLKDIVOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
  
    //
    // Allocate the wires driven by IOCLKDIV1
    //
    sprintf(strVar, "ntIOCLKDIV1_CLKDIVOUT_%d_%d", tile_1_sx+1, sy);
    &wire ntRef_ntIOCLKDIV1_CLKDIVOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by IOCLKDIV2
    //
    sprintf(strVar, "ntIOCLKDIV2_CLKDIVOUT_%d_%d", tile_1_sx+2, sy);
    &wire ntRef_ntIOCLKDIV2_CLKDIVOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by IOCLKDIV3
    //
    sprintf(strVar, "ntIOCLKDIV3_CLKDIVOUT_%d_%d", tile_1_sx+3, sy);
    &wire ntRef_ntIOCLKDIV3_CLKDIVOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    
    //
    // Layout USCMMUX2TO1
    //
    // Allocate the wires driven by USCMMUX2TO1
    //
    sprintf(strVar, "ntUSCMMUX2TO1_0_OUT_%d_%d", tile_1_sx, sy+1);
    &wire ntRef_ntUSCMMUX2TO1_0_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;

    sprintf(strVar, "ntUSCMMUX2TO1_1_OUT_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntUSCMMUX2TO1_1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntUSCMMUX2TO1_2_OUT_%d_%d", tile_1_sx+2, sy+1);
    &wire ntRef_ntUSCMMUX2TO1_2_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntUSCMMUX2TO1_3_OUT_%d_%d", tile_1_sx+3, sy+1);
    &wire ntRef_ntUSCMMUX2TO1_3_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //======================================//
    //            PLACE TILE 0              //
    //======================================//
    
    //
    // Instantiate the IOCLKMUX @[1,0]. All connecting nets should have been allocated
    //
    if(flag == 0)
    {
        sprintf(strVar, "IOCLKMUX_T_%d_%d", sx+1, sy);
    }
    else if(flag == 1)
    {
        sprintf(strVar, "IOCLKMUX_B_%d_%d", sx+1, sy);
    }
    
    device IOCLKMUX *strVar
        port map (
                   IOCLK   => ntRef_ntIOCLK             // output     
                 )
        @[sx+1,sy]; 
        
    //
    // Instantiate the IOCLKGATE0 @[0,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKGATE_%d_%d", sx, sy+1);
    device IOCLKGATE *strVar
        port map (
                   OUT   => ntRef_ntIOCLKGATE0_OUT    ,         // output     
                   
                   CLK   => ntRef_ntIOCLK[0]                    //Input from IOCLKMUX
                 )
        @[sx,sy+1]; 
    
    //
    // Instantiate the IOCLKGATE1 @[1,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKGATE_%d_%d", sx+1, sy+1);
    device IOCLKGATE *strVar
        port map (
                   OUT   => ntRef_ntIOCLKGATE1_OUT     ,        // output 
                   
                   CLK   => ntRef_ntIOCLK[1]                    //Input from IOCLKMUX
                 )
        @[sx+1,sy+1]; 
        
    //
    // Instantiate the IOCLKGATE2 @[2,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKGATE_%d_%d", sx+2, sy+1);
    device IOCLKGATE *strVar
        port map (
                   OUT   => ntRef_ntIOCLKGATE2_OUT     ,        // output     
                   
                   CLK   => ntRef_ntIOCLK[2]                    //Input from IOCLKMUX
                 )
        @[sx+2,sy+1]; 
        
    //
    // Instantiate the IOCLKGATE3 @[3,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKGATE_%d_%d", sx+3, sy+1);
    device IOCLKGATE *strVar
        port map (
                   OUT   => ntRef_ntIOCLKGATE3_OUT     ,        // output     
                   
                   CLK   => ntRef_ntIOCLK[3]                    //Input from IOCLKMUX
                 )
        @[sx+3,sy+1]; 
        
    //
    // Instantiate the BRGCLKGATE0 @[0,2]. All connecting nets should have been allocated
    //
    sprintf(strVar, "BRGCLKGATE_%d_%d", sx, sy+2);
    device IOCLKGATE *strVar
        port map (
                   OUT   => ntRef_ntBRGCLKGATE0_OUT    ,         // output     
                   
                   CLK   => ntRef_ntIOCLK[0]                    //Input from IOCLKMUX
                 )
        @[sx,sy+2]; 
    
    //
    // Instantiate the BRGCLKGATE1 @[1,2]. All connecting nets should have been allocated
    //
    sprintf(strVar, "BRGCLKGATE_%d_%d", sx+1, sy+2);
    device IOCLKGATE *strVar
        port map (
                   OUT   => ntRef_ntBRGCLKGATE1_OUT     ,        // output 
                   
                   CLK   => ntRef_ntIOCLK[1]                    //Input from IOCLKMUX
                 )
        @[sx+1,sy+2];         
    
        
    //======================================//
    //            PLACE TILE 1              //
    //======================================//
    //
    // Instantiate the USCMMUX2TO1 @[0,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "USCMMUX2TO1_%d_%d", tile_1_sx, sy+1);
    device USCMMUX2TO1 *strVar
        port map (
                   OUT   => ntRef_ntUSCMMUX2TO1_0_OUT        ,     // output     
                   
                   IN1   => ntRef_ntIOCLKGATE0_OUT                 //Input from IOCLKGATE1
                 )
        @[tile_1_sx,sy+1]; 
        
    //
    // Instantiate the USCMMUX2TO1 @[1,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "USCMMUX2TO1_%d_%d", tile_1_sx+1, sy+1);
    device USCMMUX2TO1 *strVar
        port map (
                   OUT   => ntRef_ntUSCMMUX2TO1_1_OUT        ,     // output     
                   
                   IN1   => ntRef_ntIOCLKGATE1_OUT                 //Input from IOCLKGATE1
                 )
        @[tile_1_sx+1,sy+1]; 

    //
    // Instantiate the USCMMUX2TO1 @[2,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "USCMMUX2TO1_%d_%d", tile_1_sx+2, sy+1);
    device USCMMUX2TO1 *strVar
        port map (
                   OUT   => ntRef_ntUSCMMUX2TO1_2_OUT        ,     // output     
                   
                   IN1   => ntRef_ntIOCLKGATE2_OUT                 //Input from IOCLKGATE2
                 )
        @[tile_1_sx+2,sy+1]; 
        
    //
    // Instantiate the USCMMUX2TO1 @[3,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "USCMMUX2TO1_%d_%d", tile_1_sx+3, sy+1);
    device USCMMUX2TO1 *strVar
        port map (
                   OUT   => ntRef_ntUSCMMUX2TO1_3_OUT        ,     // output     
                   
                   IN1   => ntRef_ntIOCLKGATE3_OUT                 //Input from IOCLKGATE3
                 )
        @[tile_1_sx+3,sy+1]; 
        

    //
    // Instantiate the IOCLKDIV @[0,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKDIV_%d_%d", tile_1_sx, sy);
    device IOCLKDIV *strVar
        port map (
                   CLKDIVOUT   => ntRef_ntIOCLKDIV0_CLKDIVOUT        ,     // output    
                   
                   CLK         => ntRef_ntUSCMMUX2TO1_0_OUT          //Input from USCMMUX2TO1 0
                 )
        @[tile_1_sx,sy]; 

    //
    // Instantiate the IOCLKDIV @[1,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKDIV_%d_%d", tile_1_sx+1, sy);
    device IOCLKDIV *strVar
        port map (
                   CLKDIVOUT   => ntRef_ntIOCLKDIV1_CLKDIVOUT        ,     // output    
                   
                   CLK         => ntRef_ntUSCMMUX2TO1_1_OUT          //Input from USCMMUX2TO1 1
                 )
        @[tile_1_sx+1,sy]; 
        
    //
    // Instantiate the IOCLKDIV @[2,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKDIV_%d_%d", tile_1_sx+2, sy);
    device IOCLKDIV *strVar
        port map (
                   CLKDIVOUT   => ntRef_ntIOCLKDIV2_CLKDIVOUT        ,     // output    
                   
                   CLK         => ntRef_ntUSCMMUX2TO1_2_OUT          //Input from USCMMUX2TO1 2
                 )
        @[tile_1_sx+2,sy]; 
        
    //
    // Instantiate the IOCLKDIV @[3,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKDIV_%d_%d", tile_1_sx+3, sy);
    device IOCLKDIV *strVar
        port map (
                   CLKDIVOUT   => ntRef_ntIOCLKDIV3_CLKDIVOUT        ,     // output    
                   
                   CLK         => ntRef_ntUSCMMUX2TO1_3_OUT          //Input from USCMMUX2TO1 3
                 )
        @[tile_1_sx+3,sy]; 
          
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IOCLKGEN block tiles. Each IOCLKGEN block takes
             the size of 1 tiles. 
             
     
              ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
           BRGCLKGATE0[0,2] BRGCLKGATE1[1,2] BRGCLKGATE2[2,2] BRGCLKGATE3[3,2]      
           IOCLKGATE0[0,1]  IOCLKGATE1[1,1]  IOCLKGATE2[2,1]  IOCLKGATE3[3,1]   USCMMUX2TO1[0,1] USCMMUX2TO1[1,1] USCMMUX2TO1[2,1] USCMMUX2TO1[3,1]
                            IOCLKMUX[1,0]                                       IOCLKDIV[0,0]   IOCLKDIV[1,0]   IOCLKDIV[2,0]   IOCLKDIV[3,0]
              ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
                                      Tile 0                                                               Tile 1

            ]

  Revision History:

*****************************************************************************************/
function place_ioclkgen_r_tile ( unsigned int tx, ty )
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    unsigned int tile_1_sx = (tx+1) * TILE_NUM_SITE_X; 
    
    //========= TILE 0 ==========//
    
    //
    // Layout IOCLKMUX
    //
    // Allocate the wires driven by IOCLKMUX
    //
    sprintf(strVar, "ntIOCLK_%d_%d", sx+1, sy);
    &wire ntRef_ntIOCLK[3:0] = wire *strVar[3:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Layout GATE
    //
    // Allocate the wires driven by IOCLKGATE0
    //
    sprintf(strVar, "ntIOCLKGATE0_OUT_%d_%d", sx, sy+1);
    &wire ntRef_ntIOCLKGATE0_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by IOCLKGATE1
    //
    sprintf(strVar, "ntIOCLKGATE1_OUT_%d_%d", sx+1, sy+1);
    &wire ntRef_ntIOCLKGATE1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by IOCLKGATE2
    //
    sprintf(strVar, "ntIOCLKGATE2_OUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntIOCLKGATE2_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by IOCLKGATE3
    //
    sprintf(strVar, "ntIOCLKGATE3_OUT_%d_%d", sx+3, sy+1);
    &wire ntRef_ntIOCLKGATE3_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by BRGCLKGATE0
    //
    sprintf(strVar, "ntBRGCLKGATE0_OUT_%d_%d", sx, sy+2);
    &wire ntRef_ntBRGCLKGATE0_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by BRGCLKGATE1
    //
    sprintf(strVar, "ntBRGCLKGATE1_OUT_%d_%d", sx+1, sy+2);
    &wire ntRef_ntBRGCLKGATE1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by BRGCLKGATE2
    //
    sprintf(strVar, "ntBRGCLKGATE2_OUT_%d_%d", sx+2, sy+2);
    &wire ntRef_ntBRGCLKGATE2_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by BRGCLKGATE3
    //
    sprintf(strVar, "ntBRGCLKGATE3_OUT_%d_%d", sx+3, sy+2);
    &wire ntRef_ntBRGCLKGATE3_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;

     
    //========= TILE 1 ==========//
    
    //
    // Layout IOCLKDIV
    //
    // Allocate the wires driven by IOCLKDIV0
    //
    sprintf(strVar, "ntIOCLKDIV0_CLKDIVOUT_%d_%d", tile_1_sx, sy);
    &wire ntRef_ntIOCLKDIV0_CLKDIVOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
  
    //
    // Allocate the wires driven by IOCLKDIV1
    //
    sprintf(strVar, "ntIOCLKDIV1_CLKDIVOUT_%d_%d", tile_1_sx+1, sy);
    &wire ntRef_ntIOCLKDIV1_CLKDIVOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by IOCLKDIV2
    //
    sprintf(strVar, "ntIOCLKDIV2_CLKDIVOUT_%d_%d", tile_1_sx+2, sy);
    &wire ntRef_ntIOCLKDIV2_CLKDIVOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by IOCLKDIV3
    //
    sprintf(strVar, "ntIOCLKDIV3_CLKDIVOUT_%d_%d", tile_1_sx+3, sy);
    &wire ntRef_ntIOCLKDIV3_CLKDIVOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    
    //
    // Layout USCMMUX2TO1
    //
    // Allocate the wires driven by USCMMUX2TO1
    //
    sprintf(strVar, "ntUSCMMUX2TO1_0_OUT_%d_%d", tile_1_sx, sy+1);
    &wire ntRef_ntUSCMMUX2TO1_0_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;

    sprintf(strVar, "ntUSCMMUX2TO1_1_OUT_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntUSCMMUX2TO1_1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntUSCMMUX2TO1_2_OUT_%d_%d", tile_1_sx+2, sy+1);
    &wire ntRef_ntUSCMMUX2TO1_2_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntUSCMMUX2TO1_3_OUT_%d_%d", tile_1_sx+3, sy+1);
    &wire ntRef_ntUSCMMUX2TO1_3_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //======================================//
    //            PLACE TILE 0              //
    //======================================//
    
    //
    // Instantiate the IOCLKMUX @[1,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKMUX_R_%d_%d", sx+1, sy);
    device IOCLKMUX *strVar
        port map (
                   IOCLK   => ntRef_ntIOCLK             // output     
                 )
        @[sx+1,sy]; 
        
    //
    // Instantiate the IOCLKGATE0 @[0,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKGATE_%d_%d", sx, sy+1);
    device IOCLKGATE *strVar
        port map (
                   OUT   => ntRef_ntIOCLKGATE0_OUT    ,         // output     
                   
                   CLK   => ntRef_ntIOCLK[0]                    //Input from IOCLKMUX
                 )
        @[sx,sy+1]; 
    
    //
    // Instantiate the IOCLKGATE1 @[1,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKGATE_%d_%d", sx+1, sy+1);
    device IOCLKGATE *strVar
        port map (
                   OUT   => ntRef_ntIOCLKGATE1_OUT     ,        // output 
                   
                   CLK   => ntRef_ntIOCLK[1]                    //Input from IOCLKMUX
                 )
        @[sx+1,sy+1]; 
        
    //
    // Instantiate the IOCLKGATE2 @[2,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKGATE_%d_%d", sx+2, sy+1);
    device IOCLKGATE *strVar
        port map (
                   OUT   => ntRef_ntIOCLKGATE2_OUT     ,        // output     
                   
                   CLK   => ntRef_ntIOCLK[2]                    //Input from IOCLKMUX
                 )
        @[sx+2,sy+1]; 
        
    //
    // Instantiate the IOCLKGATE3 @[3,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKGATE_%d_%d", sx+3, sy+1);
    device IOCLKGATE *strVar
        port map (
                   OUT   => ntRef_ntIOCLKGATE3_OUT     ,        // output     
                   
                   CLK   => ntRef_ntIOCLK[3]                    //Input from IOCLKMUX
                 )
        @[sx+3,sy+1]; 
        
    //
    // Instantiate the BRGCLKGATE0 @[0,2]. All connecting nets should have been allocated
    //
    sprintf(strVar, "BRGCLKGATE_%d_%d", sx, sy+2);
    device IOCLKGATE *strVar
        port map (
                   OUT   => ntRef_ntBRGCLKGATE0_OUT    ,         // output     
                   
                   CLK   => ntRef_ntIOCLK[0]                    //Input from IOCLKMUX
                 )
        @[sx,sy+2]; 
    
    //
    // Instantiate the BRGCLKGATE1 @[1,2]. All connecting nets should have been allocated
    //
    sprintf(strVar, "BRGCLKGATE_%d_%d", sx+1, sy+2);
    device IOCLKGATE *strVar
        port map (
                   OUT   => ntRef_ntBRGCLKGATE1_OUT     ,        // output 
                   
                   CLK   => ntRef_ntIOCLK[1]                    //Input from IOCLKMUX
                 )
        @[sx+1,sy+2]; 
        
    //
    // Instantiate the BRGCLKGATE2 @[2,2]. All connecting nets should have been allocated
    //
    sprintf(strVar, "BRGCLKGATE_%d_%d", sx+2, sy+2);
    device IOCLKGATE *strVar
        port map (
                   OUT   => ntRef_ntBRGCLKGATE2_OUT     ,        // output     
                   
                   CLK   => ntRef_ntIOCLK[2]                    //Input from IOCLKMUX
                 )
        @[sx+2,sy+2]; 
        
    //
    // Instantiate the BRGCLKGATE3 @[3,2]. All connecting nets should have been allocated
    //
    sprintf(strVar, "BRGCLKGATE_%d_%d", sx+3, sy+2);
    device IOCLKGATE *strVar
        port map (
                   OUT   => ntRef_ntBRGCLKGATE3_OUT     ,        // output     
                   
                   CLK   => ntRef_ntIOCLK[3]                    //Input from IOCLKMUX
                 )
        @[sx+3,sy+2]; 
        
    //======================================//
    //            PLACE TILE 1              //
    //======================================//
    //
    // Instantiate the USCMMUX2TO1 @[0,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "USCMMUX2TO1_%d_%d", tile_1_sx, sy+1);
    device USCMMUX2TO1 *strVar
        port map (
                   OUT   => ntRef_ntUSCMMUX2TO1_0_OUT        ,     // output     
                   
                   IN1   => ntRef_ntIOCLKGATE0_OUT                 //Input from IOCLKGATE1
                 )
        @[tile_1_sx,sy+1]; 
        
    //
    // Instantiate the USCMMUX2TO1 @[1,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "USCMMUX2TO1_%d_%d", tile_1_sx+1, sy+1);
    device USCMMUX2TO1 *strVar
        port map (
                   OUT   => ntRef_ntUSCMMUX2TO1_1_OUT        ,     // output     
                   
                   IN1   => ntRef_ntIOCLKGATE1_OUT                 //Input from IOCLKGATE1
                 )
        @[tile_1_sx+1,sy+1]; 

    //
    // Instantiate the USCMMUX2TO1 @[2,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "USCMMUX2TO1_%d_%d", tile_1_sx+2, sy+1);
    device USCMMUX2TO1 *strVar
        port map (
                   OUT   => ntRef_ntUSCMMUX2TO1_2_OUT        ,     // output     
                   
                   IN1   => ntRef_ntIOCLKGATE2_OUT                 //Input from IOCLKGATE2
                 )
        @[tile_1_sx+2,sy+1]; 
        
    //
    // Instantiate the USCMMUX2TO1 @[3,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "USCMMUX2TO1_%d_%d", tile_1_sx+3, sy+1);
    device USCMMUX2TO1 *strVar
        port map (
                   OUT   => ntRef_ntUSCMMUX2TO1_3_OUT        ,     // output     
                   
                   IN1   => ntRef_ntIOCLKGATE3_OUT                 //Input from IOCLKGATE3
                 )
        @[tile_1_sx+3,sy+1]; 
        

    //
    // Instantiate the IOCLKDIV @[0,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKDIV_%d_%d", tile_1_sx, sy);
    device IOCLKDIV *strVar
        port map (
                   CLKDIVOUT   => ntRef_ntIOCLKDIV0_CLKDIVOUT        ,     // output    
                   
                   CLK         => ntRef_ntUSCMMUX2TO1_0_OUT          //Input from USCMMUX2TO1 0
                 )
        @[tile_1_sx,sy]; 

    //
    // Instantiate the IOCLKDIV @[1,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKDIV_%d_%d", tile_1_sx+1, sy);
    device IOCLKDIV *strVar
        port map (
                   CLKDIVOUT   => ntRef_ntIOCLKDIV1_CLKDIVOUT        ,     // output    
                   
                   CLK         => ntRef_ntUSCMMUX2TO1_1_OUT          //Input from USCMMUX2TO1 1
                 )
        @[tile_1_sx+1,sy]; 
        
    //
    // Instantiate the IOCLKDIV @[2,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKDIV_%d_%d", tile_1_sx+2, sy);
    device IOCLKDIV *strVar
        port map (
                   CLKDIVOUT   => ntRef_ntIOCLKDIV2_CLKDIVOUT        ,     // output    
                   
                   CLK         => ntRef_ntUSCMMUX2TO1_2_OUT          //Input from USCMMUX2TO1 2
                 )
        @[tile_1_sx+2,sy]; 
        
    //
    // Instantiate the IOCLKDIV @[3,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKDIV_%d_%d", tile_1_sx+3, sy);
    device IOCLKDIV *strVar
        port map (
                   CLKDIVOUT   => ntRef_ntIOCLKDIV3_CLKDIVOUT        ,     // output    
                   
                   CLK         => ntRef_ntUSCMMUX2TO1_3_OUT          //Input from USCMMUX2TO1 3
                 )
        @[tile_1_sx+3,sy]; 
          
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IOCLKGEN block tiles. Each IOCLKGEN block takes
             the size of 1 tiles. 
             
     
              ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
                 
           IOCLKGATE0[0,1]  IOCLKGATE1[1,1]  IOCLKGATE2[2,1]  IOCLKGATE3[3,1]   USCMMUX2TO1[0,1] USCMMUX2TO1[1,1] USCMMUX2TO1[2,1] USCMMUX2TO1[3,1]
                            IOCLKMUX[1,0]                                       IOCLKDIV[0,0]   IOCLKDIV[1,0]   IOCLKDIV[2,0]   IOCLKDIV[3,0]
              ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
                                      Tile 0                                                               Tile 1

            ]

  Revision History:

*****************************************************************************************/
function place_ioclkgen_l_tile ( unsigned int tx, ty )
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    unsigned int tile_1_sx = (tx+1) * TILE_NUM_SITE_X; 
    
    //========= TILE 0 ==========//
    
    //
    // Layout IOCLKMUX
    //
    // Allocate the wires driven by IOCLKMUX
    //
    sprintf(strVar, "ntIOCLK_%d_%d", sx+1, sy);
    &wire ntRef_ntIOCLK[3:0] = wire *strVar[3:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Layout GATE
    //
    // Allocate the wires driven by IOCLKGATE0
    //
    sprintf(strVar, "ntIOCLKGATE0_OUT_%d_%d", sx, sy+1);
    &wire ntRef_ntIOCLKGATE0_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by IOCLKGATE1
    //
    sprintf(strVar, "ntIOCLKGATE1_OUT_%d_%d", sx+1, sy+1);
    &wire ntRef_ntIOCLKGATE1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by IOCLKGATE2
    //
    sprintf(strVar, "ntIOCLKGATE2_OUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntIOCLKGATE2_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by IOCLKGATE3
    //
    sprintf(strVar, "ntIOCLKGATE3_OUT_%d_%d", sx+3, sy+1);
    &wire ntRef_ntIOCLKGATE3_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
      
     
    //========= TILE 1 ==========//
    
    //
    // Layout IOCLKDIV
    //
    // Allocate the wires driven by IOCLKDIV0
    //
    sprintf(strVar, "ntIOCLKDIV0_CLKDIVOUT_%d_%d", tile_1_sx, sy);
    &wire ntRef_ntIOCLKDIV0_CLKDIVOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
  
    //
    // Allocate the wires driven by IOCLKDIV1
    //
    sprintf(strVar, "ntIOCLKDIV1_CLKDIVOUT_%d_%d", tile_1_sx+1, sy);
    &wire ntRef_ntIOCLKDIV1_CLKDIVOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by IOCLKDIV2
    //
    sprintf(strVar, "ntIOCLKDIV2_CLKDIVOUT_%d_%d", tile_1_sx+2, sy);
    &wire ntRef_ntIOCLKDIV2_CLKDIVOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Allocate the wires driven by IOCLKDIV3
    //
    sprintf(strVar, "ntIOCLKDIV3_CLKDIVOUT_%d_%d", tile_1_sx+3, sy);
    &wire ntRef_ntIOCLKDIV3_CLKDIVOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    
    //
    // Layout USCMMUX2TO1
    //
    // Allocate the wires driven by USCMMUX2TO1
    //
    sprintf(strVar, "ntUSCMMUX2TO1_0_OUT_%d_%d", tile_1_sx, sy+1);
    &wire ntRef_ntUSCMMUX2TO1_0_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;

    sprintf(strVar, "ntUSCMMUX2TO1_1_OUT_%d_%d", tile_1_sx+1, sy+1);
    &wire ntRef_ntUSCMMUX2TO1_1_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntUSCMMUX2TO1_2_OUT_%d_%d", tile_1_sx+2, sy+1);
    &wire ntRef_ntUSCMMUX2TO1_2_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    sprintf(strVar, "ntUSCMMUX2TO1_3_OUT_%d_%d", tile_1_sx+3, sy+1);
    &wire ntRef_ntUSCMMUX2TO1_3_OUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //======================================//
    //            PLACE TILE 0              //
    //======================================//
    
    //
    // Instantiate the IOCLKMUX @[1,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKMUX_L_%d_%d", sx+1, sy);
    device IOCLKMUX *strVar
        port map (
                   IOCLK   => ntRef_ntIOCLK             // output     
                 )
        @[sx+1,sy]; 
        
    //
    // Instantiate the IOCLKGATE0 @[0,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKGATE_%d_%d", sx, sy+1);
    device IOCLKGATE *strVar
        port map (
                   OUT   => ntRef_ntIOCLKGATE0_OUT    ,         // output     
                   
                   CLK   => ntRef_ntIOCLK[0]                    //Input from IOCLKMUX
                 )
        @[sx,sy+1]; 
    
    //
    // Instantiate the IOCLKGATE1 @[1,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKGATE_%d_%d", sx+1, sy+1);
    device IOCLKGATE *strVar
        port map (
                   OUT   => ntRef_ntIOCLKGATE1_OUT     ,        // output 
                   
                   CLK   => ntRef_ntIOCLK[1]                    //Input from IOCLKMUX
                 )
        @[sx+1,sy+1]; 
        
    //
    // Instantiate the IOCLKGATE2 @[2,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKGATE_%d_%d", sx+2, sy+1);
    device IOCLKGATE *strVar
        port map (
                   OUT   => ntRef_ntIOCLKGATE2_OUT     ,        // output     
                   
                   CLK   => ntRef_ntIOCLK[2]                    //Input from IOCLKMUX
                 )
        @[sx+2,sy+1]; 
        
    //
    // Instantiate the IOCLKGATE3 @[3,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKGATE_%d_%d", sx+3, sy+1);
    device IOCLKGATE *strVar
        port map (
                   OUT   => ntRef_ntIOCLKGATE3_OUT     ,        // output     
                   
                   CLK   => ntRef_ntIOCLK[3]                    //Input from IOCLKMUX
                 )
        @[sx+3,sy+1]; 
            
          
    //======================================//
    //            PLACE TILE 1              //
    //======================================//
    //
    // Instantiate the USCMMUX2TO1 @[0,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "USCMMUX2TO1_%d_%d", tile_1_sx, sy+1);
    device USCMMUX2TO1 *strVar
        port map (
                   OUT   => ntRef_ntUSCMMUX2TO1_0_OUT        ,     // output     
                   
                   IN1   => ntRef_ntIOCLKGATE0_OUT                 //Input from IOCLKGATE1
                 )
        @[tile_1_sx,sy+1]; 
        
    //
    // Instantiate the USCMMUX2TO1 @[1,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "USCMMUX2TO1_%d_%d", tile_1_sx+1, sy+1);
    device USCMMUX2TO1 *strVar
        port map (
                   OUT   => ntRef_ntUSCMMUX2TO1_1_OUT        ,     // output     
                   
                   IN1   => ntRef_ntIOCLKGATE1_OUT                 //Input from IOCLKGATE1
                 )
        @[tile_1_sx+1,sy+1]; 

    //
    // Instantiate the USCMMUX2TO1 @[2,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "USCMMUX2TO1_%d_%d", tile_1_sx+2, sy+1);
    device USCMMUX2TO1 *strVar
        port map (
                   OUT   => ntRef_ntUSCMMUX2TO1_2_OUT        ,     // output     
                   
                   IN1   => ntRef_ntIOCLKGATE2_OUT                 //Input from IOCLKGATE2
                 )
        @[tile_1_sx+2,sy+1]; 
        
    //
    // Instantiate the USCMMUX2TO1 @[3,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "USCMMUX2TO1_%d_%d", tile_1_sx+3, sy+1);
    device USCMMUX2TO1 *strVar
        port map (
                   OUT   => ntRef_ntUSCMMUX2TO1_3_OUT        ,     // output     
                   
                   IN1   => ntRef_ntIOCLKGATE3_OUT                 //Input from IOCLKGATE3
                 )
        @[tile_1_sx+3,sy+1]; 
        

    //
    // Instantiate the IOCLKDIV @[0,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKDIV_%d_%d", tile_1_sx, sy);
    device IOCLKDIV *strVar
        port map (
                   CLKDIVOUT   => ntRef_ntIOCLKDIV0_CLKDIVOUT        ,     // output    
                   
                   CLK         => ntRef_ntUSCMMUX2TO1_0_OUT          //Input from USCMMUX2TO1 0
                 )
        @[tile_1_sx,sy]; 

    //
    // Instantiate the IOCLKDIV @[1,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKDIV_%d_%d", tile_1_sx+1, sy);
    device IOCLKDIV *strVar
        port map (
                   CLKDIVOUT   => ntRef_ntIOCLKDIV1_CLKDIVOUT        ,     // output    
                   
                   CLK         => ntRef_ntUSCMMUX2TO1_1_OUT          //Input from USCMMUX2TO1 1
                 )
        @[tile_1_sx+1,sy]; 
        
    //
    // Instantiate the IOCLKDIV @[2,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKDIV_%d_%d", tile_1_sx+2, sy);
    device IOCLKDIV *strVar
        port map (
                   CLKDIVOUT   => ntRef_ntIOCLKDIV2_CLKDIVOUT        ,     // output    
                   
                   CLK         => ntRef_ntUSCMMUX2TO1_2_OUT          //Input from USCMMUX2TO1 2
                 )
        @[tile_1_sx+2,sy]; 
        
    //
    // Instantiate the IOCLKDIV @[3,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLKDIV_%d_%d", tile_1_sx+3, sy);
    device IOCLKDIV *strVar
        port map (
                   CLKDIVOUT   => ntRef_ntIOCLKDIV3_CLKDIVOUT        ,     // output    
                   
                   CLK         => ntRef_ntUSCMMUX2TO1_3_OUT          //Input from USCMMUX2TO1 3
                 )
        @[tile_1_sx+3,sy]; 
          
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO CLK BRIDGE block tiles. Each IO CLK BRIDGE block takes
             the size of 1 tiles. 
             
     
              ------------|---------------|---------------|-------------   


              IOCLK_BRI[0,0]
              ------------|---------------|---------------|-------------  
              
            ]

  Revision History:

*****************************************************************************************/
function place_ioclk_bridge_tile ( unsigned int tx, ty )
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;

    //
    // Layout IOCLK BRIDGE
    //
    // Allocate the wires driven by IOCLK BRIDGE
    //
    sprintf(strVar, "ntBRGCLK_R_O_%d_%d", sx, sy);
    &wire ntRef_ntBRGCLK_R_O[3:0] = wire *strVar[3:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
 
    sprintf(strVar, "ntBRGCLK_B_O_%d_%d", sx, sy);
    &wire ntRef_ntBRGCLK_B_O[3:0] = wire *strVar[3:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
       
    sprintf(strVar, "ntBRGCLK_T_O_%d_%d", sx, sy);
    &wire ntRef_ntBRGCLK_T_O[3:0] = wire *strVar[3:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Instantiate the IOCLK BRIDGE @[0,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IOCLK_BRIDGE");
    device IOCLK_BRIDGE *strVar
        port map (
                   BRGCLK_R_O   => ntRef_ntBRGCLK_R_O   ,          // output     
                   BRGCLK_B_O   => ntRef_ntBRGCLK_B_O   ,
                   BRGCLK_T_O   => ntRef_ntBRGCLK_T_O
                 )
        @[sx,sy]; 
        
};


/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IO CLK BRIDGE block tiles. Each IO CLK BRIDGE block takes
             the size of 1 tiles. 
             
     
              ------------|---------------|---------------|-------------   

                USCM[0,1]      USCM[1,1]       USCM[2,1]       
                USCM[0,0]      USCM[1,0]       USCM[2,0]        USCM[3,0]
              ------------|---------------|---------------|-------------  
              
            ]

  Revision History:

*****************************************************************************************/
function place_uscm_tile ( unsigned int tx, ty, uscm_num, tile_num)
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;

    //
    // Layout USCM[0,0]
    //
    // Allocate the wires driven by USCM[0,0]
    //
    sprintf(strVar, "ntUSCM0_CLKOUT_%d_%d", sx, sy);
    &wire ntRef_ntUSCM0_CLKOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Layout USCM[1,0]
    //
    // Allocate the wires driven by USCM[1,0]
    //
    sprintf(strVar, "ntUSCM1_CLKOUT_%d_%d", sx+1, sy);
    &wire ntRef_ntUSCM1_CLKOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Layout USCM[2,0]
    //
    // Allocate the wires driven by USCM[2,0]
    //
    sprintf(strVar, "ntUSCM2_CLKOUT_%d_%d", sx+2, sy);
    &wire ntRef_ntUSCM2_CLKOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Layout USCM[3,0]
    //
    // Allocate the wires driven by USCM[3,0]
    //
    sprintf(strVar, "ntUSCM3_CLKOUT_%d_%d", sx+3, sy);
    &wire ntRef_ntUSCM3_CLKOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Layout USCM[0,1]
    //
    // Allocate the wires driven by USCM[0,1]
    //
    sprintf(strVar, "ntUSCM4_CLKOUT_%d_%d", sx, sy+1);
    &wire ntRef_ntUSCM4_CLKOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Layout USCM[1,1]
    //
    // Allocate the wires driven by USCM[1,1]
    //
    sprintf(strVar, "ntUSCM5_CLKOUT_%d_%d", sx+1, sy+1);
    &wire ntRef_ntUSCM5_CLKOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Layout USCM[2,1]
    //
    // Allocate the wires driven by USCM[2,1]
    //
    sprintf(strVar, "ntUSCM6_CLKOUT_%d_%d", sx+2, sy+1);
    &wire ntRef_ntUSCM6_CLKOUT = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    
    //
    // Instantiate the USCM @[0,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "USCM%d_%d", uscm_num, 0+7*tile_num);
    device USCM *strVar
        port map (
                   CLKOUT   => ntRef_ntUSCM0_CLKOUT            // output
                 )
        @[sx,sy]; 

        
    //
    // Instantiate the USCM @[1,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "USCM%d_%d", uscm_num, 1+7*tile_num);
    device USCM *strVar
        port map (
                   CLKOUT   => ntRef_ntUSCM1_CLKOUT            // output
                 )
        @[sx+1,sy]; 

       
    //
    // Instantiate the USCM @[2,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "USCM%d_%d", uscm_num, 2+7*tile_num);
    device USCM *strVar
        port map (
                   CLKOUT   => ntRef_ntUSCM2_CLKOUT            // output
                 )
        @[sx+2,sy]; 
        
        
    //
    // Instantiate the USCM @[3,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "USCM%d_%d", uscm_num, 3+7*tile_num);
    device USCM *strVar
        port map (
                   CLKOUT   => ntRef_ntUSCM3_CLKOUT            // output
                 )
        @[sx+3,sy]; 

        
    //
    // Instantiate the USCM @[0,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "USCM%d_%d", uscm_num, 4+7*tile_num);
    device USCM *strVar
        port map (
                   CLKOUT   => ntRef_ntUSCM4_CLKOUT            // output
                 )
        @[sx,sy+1]; 
        
        
    //
    // Instantiate the USCM @[1,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "USCM%d_%d", uscm_num, 5+7*tile_num);
    device USCM *strVar
        port map (
                   CLKOUT   => ntRef_ntUSCM5_CLKOUT            // output
                 )
        @[sx+1,sy+1]; 
        
             
    //
    // Instantiate the USCM @[2,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "USCM%d_%d", uscm_num, 6+7*tile_num);
    device USCM *strVar
        port map (
                   CLKOUT   => ntRef_ntUSCM6_CLKOUT            // output
                 )
        @[sx+2,sy+1]; 
        
        
 
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within CLK_BUF block tiles. Each CLK_BUF block takes
             the size of 1 tiles. 
             
     
              ------------|---------------|---------------|-------------   

                            CLK_BUF[1,1]    

              ------------|---------------|---------------|-------------  
              
            ]

  Revision History:

*****************************************************************************************/
function place_clk_buf_tile ( unsigned int tx, ty)
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;
    
    //
    // Layout CLK_BUF[1,1]
    //
    // Allocate the wires driven by CLK_BUF[1,1]
    //
    sprintf(strVar, "ntCLK_BUF_CLKOUT_T_%d_%d", sx+1, sy+1);
    &wire ntRef_ntCLK_BUF_CLKOUT_T[15:0] = wire *strVar[15:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;    
    
    sprintf(strVar, "ntCLK_BUF_CLKOUT_B_%d_%d", sx+1, sy+1);                                     
    &wire ntRef_ntCLK_BUF_CLKOUT_B[15:0] = wire *strVar[15:0]  /*pragma PAP_ARC_ITC_TYPE="CLOCK" */ ;
    
    //
    // Instantiate the CLK_BUF @[1,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "CLK_BUF_%d_%d", sx+1, sy+1);
    device CLK_BUF *strVar
        port map (
                   CLKOUT_T   =>  ntRef_ntCLK_BUF_CLKOUT_T,            // output
                   CLKOUT_B   =>  ntRef_ntCLK_BUF_CLKOUT_B
                 )
        @[sx+1,sy+1]; 

}


/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within START block tiles. Each START block takes
             the size of 1 tiles. 
             
     
              ------------|---------------|---------------|-------------   

  
                                                             START[3,0]
              ------------|---------------|---------------|-------------  
              
            ]

  Revision History:

*****************************************************************************************/
function place_start_tile ( unsigned int tx, ty)
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;


    //
    // Instantiate the START @[3,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "START_%d_%d", sx+3, sy);
    device START *strVar
        port map (
                   UCLK     => <wire A_ICLK  of <device CIM @[sx+3, sy+2]>>   ,            //INPUT  
                   GOUTEN   => <wire A_IM3   of <device CIM @[sx+3, sy+2]>>    ,
                   GRSN     => <wire A_IM2   of <device CIM @[sx+3, sy+2]>>    ,
                   GWEN     => <wire A_IM1   of <device CIM @[sx+3, sy+2]>>
                 )
        @[sx+3,sy]; 
}


/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within GRS block tiles. Each GRS block takes
             the size of 1 tiles. 
             
                                                             GRS[3,1]
              ------------|---------------|---------------|-------------   

  
                                                             
              ------------|---------------|---------------|-------------  
              
            ]

  Revision History:

*****************************************************************************************/
function place_grs_tile ( unsigned int tx, ty)
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;


    //
    // Instantiate the GRS @[3,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "GRS_%d_%d", sx+3, sy + 1);
    device GRS *strVar
        port map (
                   GRS => <wire A_IM2   of <device CIM @[sx+3, sy+2]>>
                 )
        @[sx+3,sy+1]; 
}


/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within EFUSECODE block tiles. Each EFUSECODE block takes
             the size of 2 tiles. 
             
     
              ------------|---------------|---------------|-------------   

  
                                                           EFUSECODE[3,0]
              ------------|---------------|---------------|-------------  
              
            ]

  Revision History:

*****************************************************************************************/
function place_efusecode_tile ( unsigned int tx, ty)
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;

    unsigned int tile_up_sy = (ty+1) * TILE_NUM_SITE_Y; 


    // Allocate the wires driven by EFUSECODE[3,0]
    //
    sprintf(strVar, "ntEFUSE_%d_%d", sx+3, sy);
    &wire ntRef_ntEFUSE[31:0] = wire *strVar[31:0]  /*pragma PAP_ARC_ITC_TYPE="GLOBAL" */ ;
    
    //
    // Instantiate the EFUSECODE @[0,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "EFUSECODE_%d_%d", sx+3, sy);
    device EFUSECODE *strVar
        port map (
                   EFUSE  => ntRef_ntEFUSE 
                 )
        @[sx+3,sy]; 
        
        
        connect
        (
            <pin A_IY0  of <device CIM @[sx+3, tile_up_sy+2]>>  => ntRef_ntEFUSE[0]  ,
            <pin A_IY1  of <device CIM @[sx+3, tile_up_sy+2]>>  => ntRef_ntEFUSE[1]  ,
            <pin A_IY2  of <device CIM @[sx+3, tile_up_sy+2]>>  => ntRef_ntEFUSE[2]  ,
            <pin A_IY3  of <device CIM @[sx+3, tile_up_sy+2]>>  => ntRef_ntEFUSE[3]  ,
            <pin A_IQ0  of <device CIM @[sx+3, tile_up_sy+2]>>  => ntRef_ntEFUSE[4]  ,
            <pin A_IQ1  of <device CIM @[sx+3, tile_up_sy+2]>>  => ntRef_ntEFUSE[5]  ,
            <pin A_IQ2  of <device CIM @[sx+3, tile_up_sy+2]>>  => ntRef_ntEFUSE[6]  ,
            <pin A_IQ3  of <device CIM @[sx+3, tile_up_sy+2]>>  => ntRef_ntEFUSE[7]  ,
            <pin S_IY0  of <device CIM @[sx+3, tile_up_sy+2]>>  => ntRef_ntEFUSE[8]  ,
            <pin S_IY1  of <device CIM @[sx+3, tile_up_sy+2]>>  => ntRef_ntEFUSE[9]  ,
            <pin S_IY2  of <device CIM @[sx+3, tile_up_sy+2]>>  => ntRef_ntEFUSE[10] ,
            <pin S_IY3  of <device CIM @[sx+3, tile_up_sy+2]>>  => ntRef_ntEFUSE[11] ,
            <pin S_IQ0  of <device CIM @[sx+3, tile_up_sy+2]>>  => ntRef_ntEFUSE[12] ,
            <pin S_IQ1  of <device CIM @[sx+3, tile_up_sy+2]>>  => ntRef_ntEFUSE[13] ,
            <pin S_IQ2  of <device CIM @[sx+3, tile_up_sy+2]>>  => ntRef_ntEFUSE[14] ,
            <pin S_IQ3  of <device CIM @[sx+3, tile_up_sy+2]>>  => ntRef_ntEFUSE[15] ,
                                                                   
            <pin A_IY0  of <device CIM @[sx+3, sy+2]>>  => ntRef_ntEFUSE[16] ,        
            <pin A_IY1  of <device CIM @[sx+3, sy+2]>>  => ntRef_ntEFUSE[17] ,        
            <pin A_IY2  of <device CIM @[sx+3, sy+2]>>  => ntRef_ntEFUSE[18] ,        
            <pin A_IY3  of <device CIM @[sx+3, sy+2]>>  => ntRef_ntEFUSE[19] ,        
            <pin A_IQ0  of <device CIM @[sx+3, sy+2]>>  => ntRef_ntEFUSE[20] ,        
            <pin A_IQ1  of <device CIM @[sx+3, sy+2]>>  => ntRef_ntEFUSE[21] ,        
            <pin A_IQ2  of <device CIM @[sx+3, sy+2]>>  => ntRef_ntEFUSE[22] ,        
            <pin A_IQ3  of <device CIM @[sx+3, sy+2]>>  => ntRef_ntEFUSE[23] ,        
            <pin S_IY0  of <device CIM @[sx+3, sy+2]>>  => ntRef_ntEFUSE[24] ,        
            <pin S_IY1  of <device CIM @[sx+3, sy+2]>>  => ntRef_ntEFUSE[25] ,        
            <pin S_IY2  of <device CIM @[sx+3, sy+2]>>  => ntRef_ntEFUSE[26] ,        
            <pin S_IY3  of <device CIM @[sx+3, sy+2]>>  => ntRef_ntEFUSE[27] ,        
            <pin S_IQ0  of <device CIM @[sx+3, sy+2]>>  => ntRef_ntEFUSE[28] ,        
            <pin S_IQ1  of <device CIM @[sx+3, sy+2]>>  => ntRef_ntEFUSE[29] ,        
            <pin S_IQ2  of <device CIM @[sx+3, sy+2]>>  => ntRef_ntEFUSE[30] ,        
            <pin S_IQ3  of <device CIM @[sx+3, sy+2]>>  => ntRef_ntEFUSE[31]  
        );
        
        
}

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within SCANCHAIN block tiles. Each SCANCHAIN block takes
             the size of 2 tiles. 
             
     
              ------------|---------------|---------------|-------------   

                                                           SCANCHAIN1[3,1]
                                                           SCANCHAIN0[3,0]
              ------------|---------------|---------------|------------- 
            ]

  Revision History:

*****************************************************************************************/
function place_scanchain_tile ( unsigned int tx, ty)
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;

    // Allocate the wires driven by SCANCHAIN0[3,0]  
    //
    sprintf(strVar, "ntJCLK_%d_%d", sx+3, sy);
    &wire ntRef_ntSCANCHAIN0_JCLK = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="GLOBAL" */ ;
    
    sprintf(strVar, "ntUPDR_%d_%d", sx+3, sy);
    &wire ntRef_ntSCANCHAIN0_UPDR = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="GLOBAL" */ ;
    
    sprintf(strVar, "ntSHFTDR_%d_%d", sx+3, sy);
    &wire ntRef_ntSCANCHAIN0_SHFTDR = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="GLOBAL" */ ;
    
    sprintf(strVar, "ntFLG_USER_%d_%d", sx+3, sy);
    &wire ntRef_ntSCANCHAIN0_FLG_USER = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="GLOBAL" */ ;
    
    sprintf(strVar, "ntCAPDR_%d_%d", sx+3, sy);
    &wire ntRef_ntSCANCHAIN0_CAPDR = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="GLOBAL" */ ;
    
    sprintf(strVar, "ntRST_%d_%d", sx+3, sy);
    &wire ntRef_ntSCANCHAIN0_RST = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="GLOBAL" */ ;
    
    sprintf(strVar, "ntTDI_%d_%d", sx+3, sy);
    &wire ntRef_ntSCANCHAIN0_TDI = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="GLOBAL" */ ;
    

    //
    // Instantiate the SCANCHAIN @[3,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "SCANCHAIN_%d_%d", sx+3, sy);
    device SCANCHAIN *strVar
        port map (
                   JCLK             => ntRef_ntSCANCHAIN0_JCLK        ,            //OUTPUT 
                   UPDR             => ntRef_ntSCANCHAIN0_UPDR        ,
                   SHFTDR           => ntRef_ntSCANCHAIN0_SHFTDR      ,
                   FLG_USER         => ntRef_ntSCANCHAIN0_FLG_USER    ,
                   CAPDR            => ntRef_ntSCANCHAIN0_CAPDR       ,
                   RST              => ntRef_ntSCANCHAIN0_RST         ,
                   TDI              => ntRef_ntSCANCHAIN0_TDI         , 
                    
                   TDO_USER         => <wire A_IA0 of <device CIM @[sx+3,sy+2]>>  
                 )
        @[sx+3,sy]; 
    
      
    connect
    (
        <pin A_IY0 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntSCANCHAIN0_JCLK            ,
        <pin A_IY1 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntSCANCHAIN0_UPDR            ,
        <pin A_IY2 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntSCANCHAIN0_SHFTDR          ,
        <pin A_IY3 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntSCANCHAIN0_FLG_USER        ,
        <pin A_IQ0 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntSCANCHAIN0_CAPDR           ,
        <pin A_IQ1 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntSCANCHAIN0_RST             ,
        <pin A_IQ2 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntSCANCHAIN0_TDI 
    );
    
    
    
    // Allocate the wires driven by SCANCHAIN1[3,1] 
    //
    sprintf(strVar, "ntJCLK_%d_%d", sx+3, sy+1);
    &wire ntRef_ntSCANCHAIN1_JCLK = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="GLOBAL" */ ;
    
    sprintf(strVar, "ntUPDR_%d_%d", sx+3, sy+1);
    &wire ntRef_ntSCANCHAIN1_UPDR = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="GLOBAL" */ ;
    
    sprintf(strVar, "ntSHFTDR_%d_%d", sx+3, sy+1);
    &wire ntRef_ntSCANCHAIN1_SHFTDR = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="GLOBAL" */ ;
    
    sprintf(strVar, "ntFLG_USER_%d_%d", sx+3, sy+1);
    &wire ntRef_ntSCANCHAIN1_FLG_USER = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="GLOBAL" */ ;
    
    sprintf(strVar, "ntCAPDR_%d_%d", sx+3, sy+1);
    &wire ntRef_ntSCANCHAIN1_CAPDR = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="GLOBAL" */ ;
    
    sprintf(strVar, "ntRST_%d_%d", sx+3, sy+1);
    &wire ntRef_ntSCANCHAIN1_RST = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="GLOBAL" */ ;
    
    sprintf(strVar, "ntTDI_%d_%d", sx+3, sy+1);
    &wire ntRef_ntSCANCHAIN1_TDI = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="GLOBAL" */ ;
    

    //
    // Instantiate the SCANCHAIN @[3,1]. All connecting nets should have been allocated
    //
    sprintf(strVar, "SCANCHAIN_%d_%d", sx+3, sy+1);
    device SCANCHAIN *strVar
        port map (
                   JCLK             => ntRef_ntSCANCHAIN1_JCLK        ,            //OUTPUT 
                   UPDR             => ntRef_ntSCANCHAIN1_UPDR        ,
                   SHFTDR           => ntRef_ntSCANCHAIN1_SHFTDR      ,
                   FLG_USER         => ntRef_ntSCANCHAIN1_FLG_USER    ,
                   CAPDR            => ntRef_ntSCANCHAIN1_CAPDR       ,
                   RST              => ntRef_ntSCANCHAIN1_RST         ,
                   TDI              => ntRef_ntSCANCHAIN1_TDI         , 
                    
                   TDO_USER         => <wire S_IA0 of <device CIM @[sx+3,sy+2]>>  
                 )
        @[sx+3,sy+1]; 


    connect
    (
        <pin S_IY0 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntSCANCHAIN1_JCLK            ,
        <pin S_IY1 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntSCANCHAIN1_UPDR            ,
        <pin S_IY2 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntSCANCHAIN1_SHFTDR          ,
        <pin S_IY3 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntSCANCHAIN1_FLG_USER        ,
        <pin S_IQ0 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntSCANCHAIN1_CAPDR           ,
        <pin S_IQ1 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntSCANCHAIN1_RST             ,
        <pin S_IQ2 of <device CIM @[sx+3,sy+2]>>   => ntRef_ntSCANCHAIN1_TDI 
    );


}

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within IPAL block tiles. Each IPAL block takes
             the size of 2 tiles. 
             
              ------------|---------------|---------------|-------------  


                                                           IPAL[3,0]
              ------------|---------------|---------------|-------------  
            ]

  Revision History:

*****************************************************************************************/
function place_ipal_tile ( unsigned int tx, ty)
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;

    unsigned int tile_up_sy = (ty+1) * TILE_NUM_SITE_Y; 

    // Allocate the wires driven by IPAL[3,0]   #TILE UP
    //
    sprintf(strVar, "ntBUSY_%d_%d", sx+3, sy);
    &wire ntRef_ntBUSY = wire *strVar  /*pragma PAP_ARC_ITC_TYPE="GLOBAL" */ ;
    
    sprintf(strVar, "ntDOUT_%d_%d", sx+3, sy);
    &wire ntRef_ntDOUT[7:0] = wire *strVar[7:0]  /*pragma PAP_ARC_ITC_TYPE="GLOBAL" */ ;
    
    //
    // Instantiate the IPAL @[3,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "IPAL_%d_%d", sx+3, sy);
    device IPAL *strVar
        port map (
                   BUSY             => ntRef_ntBUSY        ,            //OUTPUT 
                   DOUT             => ntRef_ntDOUT        ,
 
 
                   CLK            => <wire A_ICLK of <device CIM @[sx+3,tile_up_sy+2]>>   ,
                   CS_B           => <wire A_ICE  of <device CIM @[sx+3,tile_up_sy+2]>>   ,
                   DIN[0]         => <wire A_IA0  of <device CIM @[sx+3,tile_up_sy+2]>>   ,
                   DIN[1]         => <wire A_IA1  of <device CIM @[sx+3,tile_up_sy+2]>>   ,
                   DIN[2]         => <wire A_IA2  of <device CIM @[sx+3,tile_up_sy+2]>>   ,
                   DIN[3]         => <wire A_IA3  of <device CIM @[sx+3,tile_up_sy+2]>>   ,
                   DIN[4]         => <wire A_IB0  of <device CIM @[sx+3,tile_up_sy+2]>>   ,
                   DIN[5]         => <wire A_IB1  of <device CIM @[sx+3,tile_up_sy+2]>>   ,
                   DIN[6]         => <wire A_IB2  of <device CIM @[sx+3,tile_up_sy+2]>>   ,
                   DIN[7]         => <wire A_IB3  of <device CIM @[sx+3,tile_up_sy+2]>>   ,
                  
                   RDWR_B         => <wire A_IRS  of <device CIM @[sx+3,tile_up_sy+2]>> 

                 )
        @[sx+3,sy]; 


    connect
    (
        <pin A_IY6AB of <device CIM @[sx+3,tile_up_sy+2]>>   => ntRef_ntBUSY        ,
        
        <pin A_IY0 of <device CIM @[sx+3,tile_up_sy+2]>>   =>  ntRef_ntDOUT[0]      ,
        <pin A_IY1 of <device CIM @[sx+3,tile_up_sy+2]>>   =>  ntRef_ntDOUT[1]      ,
        <pin A_IY2 of <device CIM @[sx+3,tile_up_sy+2]>>   =>  ntRef_ntDOUT[2]      ,
        <pin A_IY3 of <device CIM @[sx+3,tile_up_sy+2]>>   =>  ntRef_ntDOUT[3]      ,
        <pin A_IQ0 of <device CIM @[sx+3,tile_up_sy+2]>>   =>  ntRef_ntDOUT[4]      ,
        <pin A_IQ1 of <device CIM @[sx+3,tile_up_sy+2]>>   =>  ntRef_ntDOUT[5]      ,
        <pin A_IQ2 of <device CIM @[sx+3,tile_up_sy+2]>>   =>  ntRef_ntDOUT[6]      ,
        <pin A_IQ3 of <device CIM @[sx+3,tile_up_sy+2]>>   =>  ntRef_ntDOUT[7]    
    );

}

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [This function places the devices within LLC block tiles. 
             
              ------------|---------------|---------------|-------------  


                                                           OSC[3,0]
              ------------|---------------|---------------|-------------  
            ]

  Revision History:

*****************************************************************************************/
function place_osc_tile ( unsigned int tx, ty)
{
    string strVar;
    
    // Site index variable
    unsigned int sx, sy;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    sx = tx * TILE_NUM_SITE_X;
    sy = ty * TILE_NUM_SITE_Y;

    //
    // Instantiate the OSC @[3,0]. All connecting nets should have been allocated
    //
    sprintf(strVar, "OSC_%d_%d", sx+3, sy);
    device OSC *strVar
        port map (                  
                   OSC_ENN_CIM   => <wire A_IA0  of <device CIM @[sx+3,sy+2]>> 
                 )
        @[sx+3,sy]; 

}

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [Connect the iob sgmii in the entire architecture]

  Revision History:

*****************************************************************************************/
function connect_iob_sgmii
(
    unsigned int from_x ,
    unsigned int from_y , 
                 
    unsigned int to_x ,
    unsigned int to_y
)
{
    unsigned int fx,fy,tx,ty;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    fx = from_x * TILE_NUM_SITE_X;
    fy = from_y * TILE_NUM_SITE_Y;
    
    tx = to_x * TILE_NUM_SITE_X;
    ty = to_y * TILE_NUM_SITE_Y;

    connect
    (
        <pin DIN_CDR  of <device IOL @[tx+1,ty+1]>>   => <wire DIN of <device IOB_A @[fx+2,fy+1]>> ,
        <pin DIN_CDR  of <device IOL @[tx+1,ty+2]>>   => <wire DIN of <device IOB_A @[fx+2,fy+1]>> ,
        <pin DIN_CDR  of <device IOL @[fx+1,fy+1]>>   => <wire DIN of <device IOB_A @[fx+2,fy+1]>> ,
        <pin DIN_CDR  of <device IOL @[fx+1,fy+2]>>   => <wire DIN of <device IOB_A @[fx+2,fy+1]>> 
    );
};

/**VFunction******************************************************************************

  Author    [Zhang min]

  Abstract  [Connect the iobl sgmii in the entire architecture]

  Revision History:

*****************************************************************************************/
function connect_iobl_sgmii
(
    unsigned int from_x ,
    unsigned int from_y , 
                 
    unsigned int to_x ,
    unsigned int to_y
)
{
    unsigned int fx,fy,tx,ty;
    
    // Calculate the site coordinate of the lower-left corner of the base tile
    fx = from_x * TILE_NUM_SITE_X;
    fy = from_y * TILE_NUM_SITE_Y;
    
    tx = to_x * TILE_NUM_SITE_X;
    ty = to_y * TILE_NUM_SITE_Y;

    connect
    (
        <pin DIN_CDR  of <device IOL @[tx+1,ty+1]>>   => <wire DIN of <device IOB_LA @[fx+2,fy+1]>> ,
        <pin DIN_CDR  of <device IOL @[tx+1,ty+2]>>   => <wire DIN of <device IOB_LA @[fx+2,fy+1]>> ,
        <pin DIN_CDR  of <device IOL @[fx+1,fy+1]>>   => <wire DIN of <device IOB_LA @[fx+2,fy+1]>> ,
        <pin DIN_CDR  of <device IOL @[fx+1,fy+2]>>   => <wire DIN of <device IOB_LA @[fx+2,fy+1]>> 
    );
};


}; // end of package pango_funcs

