*******************************************************************

  Package   [pango_floorplan_funcs]

  Author    [XIAWEI]

  Abstract  [Floorplan description common to pango architecture]

  Revision History:

********************************************************************************/
library work;
USE pango_defs;

package pango_floorplan_funcs
{


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place logic sa tile fp]
  
  ---------|---------|---------|---------
  
    V[0,1]    A[1,1]   S[2,1]

    G[0,0]    R[1,0]   I[2,0] 
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function place_logic_sa_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int blank_x0
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx_a, lsy, fsy_a, fsx_s, fsy_s;

    // device reference variables
    &device s0Ref, s1Ref;
    &device s0fl, s1fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    
    fsx_a = ( lsx + 1 ) / 2 + 2;
    fsy_a = ( lsy + 1 ) / 3 + 1;
    
    fsx_s = ( lsx + 2 ) / 2 + 2;
    fsy_s = ( lsy + 1 ) / 3 + 1;
    
    if( fsx_a > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx_a = fsx_a - 2;          
    }       
    
    if( fsy_a <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy_a = fsy_a;   
    }    
    else if( fsy_a <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy_a = fsy_a - 1;        
    }
    else if( fsy_a <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy_a = fsy_a - 2;        
    }
    else if( fsy_a <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy_a = fsy_a - 3;        
    }
    else 
    {
         fsy_a = fsy_a - 4;         
    }            

    if( fsx_s > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx_s = fsx_s - 2;          
    }       
    
    if( fsy_s <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy_s = fsy_s;   
    }    
    else if( fsy_s <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy_s = fsy_s - 1;        
    }
    else if( fsy_s <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy_s = fsy_s - 2;        
    }
    else if( fsy_s <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy_s = fsy_s - 3;        
    }
    else 
    {
         fsy_s = fsy_s - 4;         
    }            

    // Pull out the device instances from logic structure
    s0Ref = <device CLMA @[lsx+1,lsy+1]   of ARCHITECTURE>;
    s1Ref = <device CLMS @[lsx+2,lsy+1]   of ARCHITECTURE>;

    // Instantiate the device. 
    sprintf(strVar, "CLMA_%d_%d", lsx+1, lsy+1);
    s0fl = device CLMA ( structure fp_struct ) *strVar @[fsx_a,fsy_a];

    sprintf(strVar, "CLMS_%d_%d", lsx+2, lsy+1);
    s1fl = device CLMS ( structure fp_struct ) *strVar @[fsx_s,fsy_s];

    map ( s0fl => s0Ref, s1fl => s1Ref );


}; // end of function place_logic_sa_tile_fp  



/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw logic sa tile fp]
  
  ---------|---------|---------|---------
  
    V[0,1]    A[1,1]   S[2,1]

    G[0,0]    R[1,0]   I[2,0] 
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function draw_logic_sa_tile_fp 
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref, s1Ref;
    &schematic s0schm, s1schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "CLMA_%d_%d", lsx+1, lsy+1);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device CLMA ( schematic floorplan_view ) *strVar @[gsx,gsy];

    sprintf(strVar, "CLMS_%d_%d", lsx+2, lsy+1);
    s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s1schm = device CLMS ( schematic floorplan_view ) *strVar @[gsx+20*8,gsy];

    map ( s0schm => s0Ref, s1schm => s1Ref );

}; // end of function draw_logic_sa_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place logic aa tile fp]
  
  ---------|---------|---------|---------
  
    V[0,1]    A0[1,1]  A1[2,1]

    G[0,0]    R[1,0]   I[2,0] 
  ---------|---------|---------|---------  

  Revision History:

*****************************************************************************************/
function place_logic_aa_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int blank_x0
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx_a0, lsy, fsy_a0, fsx_a1, fsy_a1;

    // device reference variables
    &device s0Ref, s1Ref;
    &device s0fl, s1fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    
    fsx_a0 = ( lsx + 1 ) / 2 + 2; 
    fsy_a0 = ( lsy + 1 ) / 3 + 1; 
                                 
    fsx_a1 = ( lsx + 2 ) / 2 + 2; 
    fsy_a1 = ( lsy + 1 ) / 3 + 1; 
    
    if( fsx_a0 > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx_a0 = fsx_a0 - 2;          
    }       
    
    if( fsy_a0 <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy_a0 = fsy_a0;   
    }    
    else if( fsy_a0 <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy_a0 = fsy_a0 - 1;        
    }
    else if( fsy_a0 <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy_a0 = fsy_a0 - 2;        
    }
    else if( fsy_a0 <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy_a0 = fsy_a0 - 3;        
    }
    else 
    {
         fsy_a0 = fsy_a0 - 4;         
    }            

    if( fsx_a1 > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx_a1 = fsx_a1 - 2;          
    }       
    
    if( fsy_a1 <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy_a1 = fsy_a1;   
    }    
    else if( fsy_a1 <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy_a1 = fsy_a1 - 1;        
    }
    else if( fsy_a1 <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy_a1 = fsy_a1 - 2;        
    }
    else if( fsy_a1 <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy_a1 = fsy_a1 - 3;        
    }
    else 
    {
         fsy_a1 = fsy_a1 - 4;         
    }            
        
    // Pull out the device instances from logic structure
    s0Ref = <device CLMA @[lsx+1,lsy+1]   of ARCHITECTURE>;
    s1Ref = <device CLMA @[lsx+2,lsy+1]   of ARCHITECTURE>;

    // Instantiate the device. 
    sprintf(strVar, "CLMA_%d_%d", lsx+1, lsy+1);
    s0fl = device CLMA ( structure fp_struct ) *strVar @[fsx_a0,fsy_a0];

    sprintf(strVar, "CLMA_%d_%d", lsx+2, lsy+1);
    s1fl = device CLMA ( structure fp_struct ) *strVar @[fsx_a1,fsy_a1];

    map ( s0fl => s0Ref, s1fl => s1Ref );


}; // end of function place_logic_aa_tile_fp  


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw logic aa tile fp]
  
  ---------|---------|---------|---------
  
    V[0,1]    A0[1,1]  A1[2,1]

    G[0,0]    R[1,0]   I[2,0] 
  ---------|---------|---------|---------  

  Revision History:

*****************************************************************************************/
function draw_logic_aa_tile_fp 
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref, s1Ref;
    &schematic s0schm, s1schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "CLMA_%d_%d", lsx+1, lsy+1);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device CLMA ( schematic floorplan_view ) *strVar @[gsx,gsy];

    sprintf(strVar, "CLMA_%d_%d", lsx+2, lsy+1);
    s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s1schm = device CLMA ( schematic floorplan_view ) *strVar @[gsx+20*8,gsy];

    map ( s0schm => s0Ref, s1schm => s1Ref );


}; // end of function draw_logic_aa_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place apm tile fp]
  
  ---------|---------|---------|---------
  
                
              R[1,0]   I[2,0]                TILE 3
  ---------|---------|---------|---------
  
                
              R[1,0]   I[2,0]                TILE 2
  ---------|---------|---------|---------
  
                
              R[1,0]   I[2,0]                TILE 1
  ---------|---------|---------|---------
  
                       A[2,1]
              R[1,0]   I[2,0]                TILE 0
  ---------|---------|---------|---------
  

  Revision History:

*****************************************************************************************/
function place_apm_tile_fp
( 
    unsigned int apm_tile_x[],
    unsigned int apm_tile_y[],
    unsigned int blank_x0
)
{

    // Tile index variable
    unsigned int tx, ty;

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx, lsy, fsy;

    // device reference variables
    &device s0Ref ;
    &device s0fl ;

    string strVar;

    foreach tx ( apm_tile_x )
    {
        foreach ty ( apm_tile_y )
        {

            lsx = tx * TILE_NUM_SITE_X;
            lsy = ty * TILE_NUM_SITE_Y;
            fsx = ( lsx + 2 ) / 2 + 2;
            fsy = ( lsy + 1 ) / 3 + 1;

            if( fsx > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
            {        
                fsx = fsx - 2;          
            }       
            
            if( fsy <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
            {
                 fsy = fsy;   
            }    
            else if( fsy <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
            {
                 fsy = fsy - 1;        
            }
            else if( fsy <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
            {
                 fsy = fsy - 2;        
            }
            else if( fsy <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
            {
                 fsy = fsy - 3;        
            }
            else 
            {
                 fsy = fsy - 4;         
            }            
                        
            // Pull out the device instances from logic structure
            s0Ref = <device APM @[lsx+2,lsy+1]   of ARCHITECTURE>;
         
            // Instantiate the device. 
            sprintf(strVar, "APM_%d_%d", lsx+2, lsy+1);
            s0fl = device APM ( structure fp_struct ) *strVar @[fsx,fsy];
            //s0fl = device APM  *strVar @[fsx,fsy];
                  
            map ( s0fl => s0Ref);  
        }
    }


}; // end of function place_apm_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw apm tile fp]
  
  ---------|---------|---------|---------
  
                
              R[1,0]   I[2,0]                TILE 3
  ---------|---------|---------|---------
  
                
              R[1,0]   I[2,0]                TILE 2
  ---------|---------|---------|---------
  
                
              R[1,0]   I[2,0]                TILE 1
  ---------|---------|---------|---------
  
                       A[2,1]
              R[1,0]   I[2,0]                TILE 0
  ---------|---------|---------|---------
  

  Revision History:

*****************************************************************************************/
function draw_apm_tile_fp
( 
    unsigned int apm_tile_x[],
    unsigned int apm_tile_y[]
)
{
    // Tile index variable
    unsigned int tx, ty;

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx, lsy, fsy;

    // device reference variables
    &device s0Ref ;
    &symbol s0fl ;

    string strVar;

    foreach tx ( apm_tile_x )
    {
        foreach ty ( apm_tile_y )
        {

            lsx = tx * TILE_NUM_SITE_X;
            lsy = ty * TILE_NUM_SITE_Y;
            fsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
            fsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;
         
            // Instantiate the device. 
            sprintf(strVar, "APM_%d_%d", lsx+2, lsy+1);
            s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s0fl = device APM ( schematic floorplan_view ) *strVar @[fsx+60, fsy+30];
            //s0fl  = device APM ( symbol fpsym ) *strVar @[fsx+60, fsy+30];
                  
            map ( s0fl => s0Ref);  
        }
    }

}; // end of function draw_apm_tile_fp



/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place drm tile fp]
  
  ---------|---------|---------
                       
              R[1,0]   I[2,0]           TILE 4
  ---------|---------|---------
                       D[2,1]
              R[1,0]   I[2,0]           TILE 3
  ---------|---------|---------
                
              R[1,0]   I[2,0]           TILE 2
  ---------|---------|---------
                       D[2,1]
              R[1,0]   I[2,0]           TILE 1
  ---------|---------|---------
                       
              R[1,0]   I[2,0]           TILE 0
  ---------|---------|---------    

  Revision History:

*****************************************************************************************/
function place_drm_tile_fp
( 
    unsigned int drm_tile_x[],
    unsigned int drm_tile_y[],
    unsigned int blank_x0
)
{

    // Tile index variable
    unsigned int tx, ty;

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx0, lsy0, lsy1, fsy0, fsx1, fsy1;

    // device reference variables
    &device s0Ref,s1Ref;
    &device s0fl,s1fl;

    string strVar;
   
    foreach tx ( drm_tile_x )
    {
        foreach ty ( drm_tile_y )
        {
            lsx = tx * TILE_NUM_SITE_X;
            lsy0 = (ty+1) * TILE_NUM_SITE_Y;
            lsy1 = (ty+3) * TILE_NUM_SITE_Y;
            
            fsx0 = ( lsx + 2 ) / 2 + 2;
            fsy0 = ( lsy0 + 1) / 3 + 1;
            
            fsx1 = ( lsx + 2 ) / 2 + 2;
            fsy1 = ( lsy1 + 1 ) / 3 + 1;            

            if( fsx0 > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
            {        
                fsx0 = fsx0 - 2;          
            }       
            
            if( fsy0 <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
            {
                 fsy0 = fsy0;   
            }    
            else if( fsy0 <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
            {
                 fsy0 = fsy0 - 1;        
            }
            else if( fsy0 <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
            {
                 fsy0 = fsy0 - 2;        
            }
            else if( fsy0 <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
            {
                 fsy0 = fsy0 - 3;        
            }
            else 
            {
                 fsy0 = fsy0 - 4;         
            }            
            
            if( fsx1 > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
            {        
                fsx1 = fsx1 - 2;          
            }       
            
            if( fsy1 <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
            {
                 fsy1 = fsy1;   
            }    
            else if( fsy1 <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
            {
                 fsy1 = fsy1 - 1;        
            }
            else if( fsy1 <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
            {
                 fsy1 = fsy1 - 2;        
            }
            else if( fsy1 <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
            {
                 fsy1 = fsy1 - 3;        
            }
            else 
            {
                 fsy1 = fsy1 - 4;         
            }            

            // Pull out the device instances from logic structure
            s0Ref = <device DRM @[lsx+2,lsy0+1]   of ARCHITECTURE>;
            s1Ref = <device DRM @[lsx+2,lsy1+1]   of ARCHITECTURE>;  
                     
            // Instantiate the device. 
            sprintf(strVar, "DRM_%d_%d", lsx+2, lsy0+1);
            s0fl = device DRM  *strVar @[fsx0,fsy0];

            sprintf(strVar, "DRM_%d_%d", lsx+2, lsy1+1);
            s1fl = device DRM  *strVar @[fsx1,fsy1];
                           
            map ( s0fl => s0Ref,s1fl => s1Ref);  
        }
    }


}; // end of function place_drm_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw drm tile fp]
  
  ---------|---------|---------
                       
              R[1,0]   I[2,0]           TILE 4
  ---------|---------|---------
                       D[2,1]
              R[1,0]   I[2,0]           TILE 3
  ---------|---------|---------
                
              R[1,0]   I[2,0]           TILE 2
  ---------|---------|---------
                       D[2,1]
              R[1,0]   I[2,0]           TILE 1
  ---------|---------|---------
                       
              R[1,0]   I[2,0]           TILE 0
  ---------|---------|---------    

  Revision History:

*****************************************************************************************/
function draw_drm_tile_fp
( 
    unsigned int drm_tile_x[],
    unsigned int drm_tile_y[]
)
{
    // Tile index variable
    unsigned int tx, ty;

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx, lsy0, lsy1, fsy;

    // device reference variables
    &device s0Ref, s1Ref;
    &symbol s0fl, s1fl ;

    string strVar;

    foreach tx ( drm_tile_x )
    {
        foreach ty ( drm_tile_y )
        {

            lsx = tx * TILE_NUM_SITE_X;
            lsy0 = (ty+1) * TILE_NUM_SITE_Y;
            lsy1 = (ty+3) * TILE_NUM_SITE_Y;
            fsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
            fsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;
         
            // Instantiate the device. 
            sprintf(strVar, "DRM_%d_%d", lsx+2, lsy0+1);
            s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s0fl  = device DRM ( symbol fpsym ) *strVar @[fsx+60, fsy+80];
 
            sprintf(strVar, "DRM_%d_%d", lsx+2, lsy1+1);
            s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s1fl  = device DRM ( symbol fpsym ) *strVar @[fsx+60, fsy+860]; 
                  
            map ( s0fl => s0Ref,s1fl => s1Ref); 
        }
    }

}; // end of function draw_drm_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place drm0 tile fp]
  
  ---------|---------|---------|---------
                                 C[3,2]
  
              R[1,0]   I[2,0]                 TILE 2
  ---------|---------|---------|---------
                                 C[3,2]
                       D[2,1]
              R[1,0]   I[2,0]                 TILE 1
  ---------|---------|---------|---------
                                 C[3,2]
                                 
              R[1,0]   I[2,0]                 TILE 0
  ---------|---------|---------|---------
      
  Revision History:

*****************************************************************************************/

function place_drm0_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int blank_x0
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx, lsy0, fsy;

    // device reference variables
    &device s0Ref;
    &device s0fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy0 = (ty+1) * TILE_NUM_SITE_Y;
    fsx = ( lsx + 2 ) / 2 + 2;
    fsy = ( lsy0 + 1 ) / 3 + 1;
    
    if( fsx > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx = fsx - 2;          
    }       
    
    if( fsy <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy = fsy;   
    }    
    else if( fsy <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 1;        
    }
    else if( fsy <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 2;        
    }
    else if( fsy <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 3;        
    }
    else 
    {
         fsy = fsy - 4;         
    }            
    
    // Pull out the device instances from logic structure
    s0Ref = <device DRM @[lsx+2,lsy0+1]   of ARCHITECTURE>;
             
    // Instantiate the device. 
    sprintf(strVar, "DRM_%d_%d", lsx+2, lsy0+1);
    s0fl = device DRM  *strVar @[fsx,fsy];
                          
    map ( s0fl => s0Ref);  

}; // end of function place_drm0_tile_fp

/**VFunction******************************************************************************

  Author    [xiawei]

  Abstract  [Place hsst tile fp]
  
  ---------|---------|---------|---------
              HSST[1,0]              
  ---------|---------|---------|---------
      
  Revision History:

*****************************************************************************************/

function place_hsst_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int blank_x0
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx, lsy, fsy;

    // device reference variables
    &device sRef;
    &device sfl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    fsx = ( lsx + 2 ) / 2 + 2;
    fsy = ( lsy + 1 ) / 3 + 1;
    
    if( fsx > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx = fsx - 2;          
    }       
    
    if( fsy <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy = fsy;   
    }    
    else if( fsy <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 1;        
    }
    else if( fsy <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 2;        
    }
    else if( fsy <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 3;        
    }
    else 
    {
         fsy = fsy - 4;         
    }            
    
    // Pull out the device instances from logic structure
    sRef = <device HSST @[lsx+1,lsy]   of ARCHITECTURE>;
             
    // Instantiate the device. 
    sprintf(strVar, "HSST_%d_%d", lsx+1, lsy);
    sfl = device HSST  *strVar @[fsx,fsy];
                          
    map ( sfl => sRef);  

}; // end of function place_hsst_tile_fp

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw drm0 tile fp]
  
  ---------|---------|---------|---------
                                 C[3,2]
  
              R[1,0]   I[2,0]                 TILE 2
  ---------|---------|---------|---------
                                 C[3,2]
                       D[2,1]
              R[1,0]   I[2,0]                 TILE 1
  ---------|---------|---------|---------
                                 C[3,2]
                                 
              R[1,0]   I[2,0]                 TILE 0
  ---------|---------|---------|---------
      
  Revision History:

*****************************************************************************************/

function draw_drm0_tile_fp
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx, lsy0, fsy;

    // device reference variables
    &device s0Ref ;
    &symbol s0fl ;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy0 = (ty+1) * TILE_NUM_SITE_Y;
    fsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    fsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;
    
    // Instantiate the device. 
    sprintf(strVar, "DRM_%d_%d", lsx+2, lsy0+1);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0fl  = device DRM ( symbol fpsym ) *strVar @[fsx+60, fsy+80];
          
    map ( s0fl => s0Ref); 


}; // end of function draw_drm0_tile_fp

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place drm1 tile fp]
  
  ---------|---------|---------|---------
                                 C[3,2]
  
              R[1,0]   I[2,0]                 TILE 2
  ---------|---------|---------|---------
                                 C[3,2]
                       D[2,1]
              R[1,0]   I[2,0]                 TILE 1
  ---------|---------|---------|---------
                                 C[3,2]
                                 
              R[1,0]   I[2,0]                 TILE 0
  ---------|---------|---------|---------
      
  Revision History:

*****************************************************************************************/

function place_drm1_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int blank_x0
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx, lsy1, fsy;

    // device reference variables
    &device s1Ref;
    &device s1fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy1 = (ty+3) * TILE_NUM_SITE_Y;
    fsx = ( lsx + 2 ) / 2 + 2;
    fsy = ( lsy1 + 1 ) / 3 + 1;
   
   if( fsx > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
   {        
       fsx = fsx - 2;          
   }       
   
   if( fsy <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
   {
        fsy = fsy;   
   }    
   else if( fsy <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
   {
        fsy = fsy - 1;        
   }
   else if( fsy <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
   {
        fsy = fsy - 2;        
   }
   else if( fsy <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
   {
        fsy = fsy - 3;        
   }
   else 
   {
        fsy = fsy - 4;         
   }            
    
    // Pull out the device instances from logic structure
    s1Ref = <device DRM @[lsx+2,lsy1+1]   of ARCHITECTURE>;
             
    // Instantiate the device. 
    sprintf(strVar, "DRM_%d_%d", lsx+2, lsy1+1);
    s1fl = device DRM  *strVar @[fsx,fsy];
                          
    map ( s1fl => s1Ref);  

}; // end of function place_drm1_tile_fp

/**VFunction******************************************************************************

  Author    [xiawei]

  Abstract  [Draw hsst tile fp]
  
  ---------|---------|---------|---------
              HSST[1,0]              
  ---------|---------|---------|---------
      
  Revision History:

*****************************************************************************************/

function draw_hsst_tile_fp
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx, lsy, fsy;

    // device reference variables
    &device sRef ;
    &symbol sfl ;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    fsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    fsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;
    
    // Instantiate the device. 
    sprintf(strVar, "HSST_%d_%d", lsx+1, lsy);
    sRef = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    sfl  = device HSST ( symbol fpsym ) *strVar @[fsx+10, fsy+10];
          
    map ( sfl => sRef); 

}; // end of function draw_hsst_tile_fp

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw drm1 tile fp]
  
  ---------|---------|---------|---------
                                 C[3,2]
  
              R[1,0]   I[2,0]                 TILE 2
  ---------|---------|---------|---------
                                 C[3,2]
                       D[2,1]
              R[1,0]   I[2,0]                 TILE 1
  ---------|---------|---------|---------
                                 C[3,2]
                                 
              R[1,0]   I[2,0]                 TILE 0
  ---------|---------|---------|---------
      
  Revision History:

*****************************************************************************************/

function draw_drm1_tile_fp
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx, lsy1, fsy;

    // device reference variables
    &device s1Ref ;
    &symbol s1fl ;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy1 = (ty+3) * TILE_NUM_SITE_Y;
    fsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    fsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;
    
    // Instantiate the device. 
    sprintf(strVar, "DRM_%d_%d", lsx+2, lsy1+1);
    s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s1fl  = device DRM ( symbol fpsym ) *strVar @[fsx+60, fsy+860];
          
    map ( s1fl => s1Ref); 


}; // end of function draw_drm1_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place dll tile fp]
  
  ---------|---------|---------|---------   

   V[0,1]                       DLL1[3,1]
   G[0,0]   R[1,0]    I[2,0]    DLL0[3,0]
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function place_dll_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int blank_x0
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx0, lsy, fsy0, fsx1, fsy1;

    // device reference variables
    &device s0Ref, s1Ref;
    &device s0fl, s1fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
       
    if (tx < blank_x0)                
    {                    
        fsx0 = ( lsx + 3 ) / 2 + 1 + ( lsy + 0 ) % 3;
        fsy0 = ( lsy + 0 ) / 3 + 1;
        
        fsx1 = ( lsx + 3 ) / 2 + 1 + ( lsy + 1 ) % 3;
        fsy1 = ( lsy + 1 ) / 3 + 1;
    }                
    else                
    {                    
        fsx0 = ( lsx + 3 ) / 2 + 2 + ( lsy + 0 ) % 3;
        fsy0 = ( lsy + 0 ) / 3 + 1;
        
        fsx1 = ( lsx + 3 ) / 2 + 2 + ( lsy + 1 ) % 3;
        fsy1 = ( lsy + 1 ) / 3 + 1;
    }
    
    if( fsx0 > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx0 = fsx0 - 2;          
    }       
    
    if( fsy0 <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy0 = fsy0;   
    }    
    else if( fsy0 <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy0 = fsy0 - 1;        
    }
    else if( fsy0 <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy0 = fsy0 - 2;        
    }
    else if( fsy0 <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy0 = fsy0 - 3;        
    }
    else 
    {
         fsy0 = fsy0 - 4;         
    }            
    
    if( fsx1 > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx1 = fsx1 - 2;          
    }       
    
    if( fsy1 <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy1 = fsy1;   
    }    
    else if( fsy1 <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy1 = fsy1 - 1;        
    }
    else if( fsy1 <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy1 = fsy1 - 2;        
    }
    else if( fsy1 <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy1 = fsy1 - 3;        
    }
    else 
    {
         fsy1 = fsy1 - 4;         
    }            

    // Pull out the device instances from logic structure
    s0Ref = <device DLL @[lsx+3,lsy+0]   of ARCHITECTURE>;
    s1Ref = <device DLL @[lsx+3,lsy+1]   of ARCHITECTURE>;

    // Instantiate the device. 
    sprintf(strVar, "DLL0_%d_%d", lsx+3, lsy+0);
    s0fl = device DLL  *strVar @[fsx0,fsy0];

    sprintf(strVar, "DLL1_%d_%d", lsx+3, lsy+1);
    s1fl = device DLL  *strVar @[fsx1,fsy1];

    map ( s0fl => s0Ref, s1fl => s1Ref );


}; // end of function place_dll_tile_fp  



/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [draw dll tile fp]
  
  ---------|---------|---------|---------   

   V[0,1]                       DLL1[3,1]
   G[0,0]   R[1,0]    I[2,0]    DLL0[3,0]
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function  draw_dll_tile_fp
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref, s1Ref;
    &symbol s0schm, s1schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "DLL0_%d_%d", lsx+3, lsy+0);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device DLL ( symbol fpsym ) *strVar @[gsx+200,gsy+100];

    sprintf(strVar, "DLL1_%d_%d", lsx+3, lsy+1);
    s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s1schm = device DLL ( symbol fpsym ) *strVar @[gsx+60,gsy+100];

    map ( s0schm => s0Ref, s1schm => s1Ref );


}; // end of function draw_dll_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place pll tile fp]
  
  IF dir == -1, PLL in top
  ---------|---------|---------|---------   
                                 C[3,2]
   V[0,1]                                    Tile 0
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 1
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 2
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 3
   G[0,0]   R[1,0]    I[2,0]        
  ---------|---------|---------|---------   
                                 C[3,2]
   V[0,1]                                    Tile 4
   G[0,0]   R[1,0]    I[2,0]     PLL[3,0]
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 5
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 6
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------     
                                 C[3,2]
   V[0,1]                                    Tile 7
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------   
  
  //
  IF dir == 1, PLL in bottom
  ---------|---------|---------|---------   
                                 C[3,2]
   V[0,1]                                    Tile 7
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 6
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 5
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 4
   G[0,0]   R[1,0]    I[2,0]     PLL[3,0]   
  ---------|---------|---------|---------   
                                 C[3,2]
   V[0,1]                                    Tile 3
   G[0,0]   R[1,0]    I[2,0]     
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 2
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 1
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------     
                                 C[3,2]
   V[0,1]                                    Tile 0
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------     

  Revision History:

*****************************************************************************************/
function place_pll_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int dir,
    unsigned int blank_x0
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx, lsy, fsy;

    // device reference variables
    &device s0Ref ;
    &device s0fl ;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = (ty + 4*dir) * TILE_NUM_SITE_Y;
    
    fsx = ( lsx + 3 ) / 2 + 2;
    fsy = ( lsy + 0 ) / 3 + 1;
    
    if( fsx > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx = fsx - 2;          
    }       
    
    if( fsy <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy = fsy;   
    }    
    else if( fsy <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 1;        
    }
    else if( fsy <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 2;        
    }
    else if( fsy <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 3;        
    }
    else 
    {
         fsy = fsy - 4;         
    }            

    // Pull out the device instances from logic structure
    s0Ref = <device PLL @[lsx+3,lsy]   of ARCHITECTURE>;
    
    // Instantiate the device. 
    sprintf(strVar, "PLL_%d_%d", lsx+3, lsy);
    s0fl = device PLL  *strVar @[fsx,fsy];
             
    map ( s0fl => s0Ref);  

}; // end of function place_pll_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw pll tile fp]
  
  IF dir == -1, PLL in top
  ---------|---------|---------|---------   
                                 C[3,2]
   V[0,1]                                    Tile 0
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 1
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 2
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 3
   G[0,0]   R[1,0]    I[2,0]        
  ---------|---------|---------|---------   
                                 C[3,2]
   V[0,1]                                    Tile 4
   G[0,0]   R[1,0]    I[2,0]     PLL[3,0]
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 5
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 6
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------     
                                 C[3,2]
   V[0,1]                                    Tile 7
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------   
  
  //
  IF dir == 1, PLL in bottom
  ---------|---------|---------|---------   
                                 C[3,2]
   V[0,1]                                    Tile 7
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 6
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 5
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 4
   G[0,0]   R[1,0]    I[2,0]     PLL[3,0]   
  ---------|---------|---------|---------   
                                 C[3,2]
   V[0,1]                                    Tile 3
   G[0,0]   R[1,0]    I[2,0]     
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 2
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------  
                                 C[3,2]
   V[0,1]                                    Tile 1
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------     
                                 C[3,2]
   V[0,1]                                    Tile 0
   G[0,0]   R[1,0]    I[2,0]    
  ---------|---------|---------|---------     

  Revision History:

*****************************************************************************************/
function draw_pll_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int dir 
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx, lsy, fsy;

    // device reference variables
    &device s0Ref ;
    &symbol s0fl ;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = (ty + 4*dir) * TILE_NUM_SITE_Y;
    fsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    
    if(dir == 1)
    {
        fsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;                    
    }
    else
    {
        fsy = (ty + 7*dir) * TILE_NUM_FLOORPLAN_GUI_GRID_Y;                
    }

    
    // Instantiate the device. 
    sprintf(strVar, "PLL_%d_%d", lsx+3, lsy);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0fl  = device PLL ( symbol fpsym ) *strVar @[fsx+60, fsy+80];
             
    map ( s0fl => s0Ref);  

}; // end of function draw_pll_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place dqs tile fp]
  
  ---------|---------|---------|--------- 
                                C[3,2]         
   V[0,1]             
   G[0,0]  R[1,0]    I[2,0]     DQS[3,0] 
  ---------|---------|---------|---------   

  Revision History:

*****************************************************************************************/
function place_dqs_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int blank_x0
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx, lsy, fsy;

    // device reference variables
    &device s0Ref;
    &device s0fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    
    fsx = ( lsx + 3 ) / 2 + 2;
    fsy = ( lsy + 0 ) / 3 + 1;
    
    if( fsx > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx = fsx - 2;          
    }       
    
    if( fsy <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy = fsy;   
    }    
    else if( fsy <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 1;        
    }
    else if( fsy <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 2;        
    }
    else if( fsy <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 3;        
    }
    else 
    {
         fsy = fsy - 4;         
    }            
   
    // Pull out the device instances from logic structure
    s0Ref = <device DQS @[lsx+3,lsy]   of ARCHITECTURE>;

    // Instantiate the device. 
    sprintf(strVar, "DQS_%d_%d", lsx+3, lsy);
    s0fl = device DQS  *strVar @[fsx,fsy];

    map ( s0fl => s0Ref);


}; // end of function place_dqs_tile_fp  



/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw dqs tile fp]
  
  ---------|---------|---------|--------- 
                                C[3,2]         
   V[0,1]             
   G[0,0]  R[1,0]    I[2,0]     DQS[3,0] 
  ---------|---------|---------|---------   

  Revision History:

*****************************************************************************************/
function draw_dqs_tile_fp 
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref;
    &symbol s0schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "DQS_%d_%d", lsx+3, lsy);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device DQS ( symbol fpsym) *strVar @[gsx+120,gsy+120];

    map ( s0schm => s0Ref);

}; // end of function draw_dqs_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io tile fp]
  
---------|---------|---------|--------- 
          IOL[1,2]  IOB_B[2,2] C[3,2]                            
  V[0,1]  IOL[1,1]  IOB_A[2,1] 
  G[0,0]  R[1,0]    I[2,0]      
---------|---------|---------|---------   

  Revision History:

*****************************************************************************************/
function place_io_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, fsx_0, fsy_0, fsx_1, fsy_1, fsx_a, fsy_a, fsx_b, fsy_b;
    unsigned int lsx_0, lsy_0, lsx_1, lsy_1, lsx_a, lsy_a, lsx_b, lsy_b;
    unsigned int lsx_0_n, lsy_0_n, lsx_1_n, lsy_1_n, lsx_a_n, lsy_a_n, lsx_b_n, lsy_b_n;      
    unsigned int T;

    // device reference variables
    &device s0Ref,s1Ref,d0Ref,d1Ref;
    &device s0fl,s1fl,d0fl,d1fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;

    lsx_0 = lsx + 1;
    lsy_0 = lsy + 2;

    lsx_1 = lsx + 1;
    lsy_1 = lsy + 1; 

    lsx_b = lsx + 2;
    lsy_b = lsy + 2;

    lsx_a = lsx + 2;
    lsy_a = lsy + 1;     

    ////////////////////////////////////////////////////////// 
    if(lsy_a > 429 )   //IOB_A
    {
        T = 4;
    }
    else if(lsy_a > 306)
    {
        T = 3;  
    }
    else if(lsy_a > 183)
    {
        T = 2;  
    }
    else if(lsy_a > 60)
    {
        T = 1;  
    }
    else
    {
        T = 0;     
    }
    lsy_a_n = lsy_a - 3 * T;
    lsx_a_n = lsx_a;               
    if(lsx_a > 280)
    {
        lsx_a_n = lsx_a - 4; 
    }             
    ////////////////////////////////////////////////////////// 
    if(lsy_b > 429 )   //IOB_B
    {
        T = 4;
    }
    else if(lsy_b > 306)
    {
        T = 3;  
    }
    else if(lsy_b > 183)
    {
        T = 2;  
    }
    else if(lsy_b > 60)
    {
        T = 1;  
    }
    else
    {
        T = 0;     
    }
    lsy_b_n = lsy_b - 3 * T;
    lsx_b_n = lsx_b;          
    if(lsx_b > 280)
    {
        lsx_b_n = lsx_b - 4; 
    }
    ////////////////////////////////////////////////////////// 
    if(lsy_0 > 429 )   //IOL_0
    {
        T = 4;
    }
    else if(lsy_0 > 306)
    {
        T = 3;  
    }
    else if(lsy_0 > 183)
    {
        T = 2;  
    }
    else if(lsy_0 > 60)
    {
        T = 1;  
    }
    else
    {
        T = 0;     
    }
    lsy_0_n = lsy_0 - 3 * T;
    lsx_0_n = lsx_0;         
    if(lsx_0 > 280)
    {
        lsx_0_n = lsx_0 - 4; 
    }            
    ////////////////////////////////////////////////////////// 
    if(lsy_1 > 429 )   //IOL_1
    {
        T = 4;
    }
    else if(lsy_1 > 306)
    {
        T = 3;  
    }
    else if(lsy_1 > 183)
    {
        T = 2;  
    }
    else if(lsy_1 > 60)
    {
        T = 1;  
    }
    else
    {
        T = 0;     
    }
    lsy_1_n = lsy_1 - 3 * T;
    lsx_1_n = lsx_1;         
    if(lsx_1 > 280)
    {
        lsx_1_n = lsx_1 - 4; 
    }       
    ////////////////////////////////////////////////////////// 
    
    ////////////////////////////////////////////////////////// 
    if(ty == 0)// bottom
    {
        if(lsy_a_n < 3)    //IOB_A
        {
            fsx_a = lsx_a_n / 2 + 2;
            fsy_a = lsy_a_n - 1;    
        }           

        if(lsy_b_n < 3)    //IOB_B
        {
            fsx_b = lsx_b_n / 2 + 2;
            fsy_b = lsy_b_n - 1;    
        }     

        if(lsy_0_n < 3)    //IOL_0
        {
            fsx_0 = lsx_0_n / 2 + 2;
            fsy_0 = lsy_0_n - 1;    
        }          

        if(lsy_1_n < 3)    //IOL_1
        {
            fsx_1 = lsx_1_n / 2 + 2;
            fsy_1 = lsy_1_n - 1;    
        }      
    }
    else if(ty == num_tile_y - 1) // top
    {
        fsx_a = lsx_a_n / 2 + 2;  //IOB_A
        fsy_a = lsy_a_n / 3 + 1; 
        if((lsy_a_n % 3) == 2 )
        {
            fsy_a = fsy_a + 1;     
        }   
        fsx_b = lsx_b_n / 2 + 2;  //IOB_B
        fsy_b = lsy_b_n / 3 + 1; 
        if((lsy_b_n % 3) == 2 )
        {
            fsy_b = fsy_b + 1;     
        }     

        fsx_0 = lsx_0_n / 2 + 2;  //IOL_0
        fsy_0 = lsy_0_n / 3 + 1; 
        if((lsy_0_n % 3) == 2 )
        {
            fsy_0 = fsy_0 + 1;     
        }   

        fsx_1 = lsx_1_n / 2 + 2;  //IOL_1
        fsy_1 = lsy_1_n / 3 + 1; 
        if((lsy_1_n % 3) == 2 )
        {
            fsy_1 = fsy_1 + 1;     
        }
    }
    else if(tx == 0) // left
    {        
        fsx_a = lsy_a_n % 6; //IOB_A
        if(fsx_a < 3)
        {
            fsx_a = 1;   
        }
        else
        {
            fsx_a = 3;
            lsy_a_n = lsy_a_n - 3;           
        }
        fsy_a = lsy_a_n / 3 + lsy_a_n % 6 - 1;

        fsx_b = lsy_b_n % 6; //IOB_B
        if(fsx_b < 3)
        {
            fsx_b = 1;   
        }
        else
        {
            fsx_b = 3;
            lsy_b_n = lsy_b_n - 3;           
        }
        fsy_b = lsy_b_n / 3 + lsy_b_n % 6 - 1;

        fsx_0 = lsy_0_n % 6;  //IOL_0        
        if(fsx_0 < 3)      
        {
            fsx_0 = 0;
        }
        else
        {
            fsx_0 = 2;  
            lsy_0_n = lsy_0_n - 3;  
        }
        fsy_0 = lsy_0_n / 3 + lsy_0_n % 6 - 1;

        fsx_1 = lsy_1_n % 6;  //IOL_1        
        if(fsx_1 < 3)      
        {
            fsx_1 = 0;
        }
        else
        {
            fsx_1 = 2;  
            lsy_1_n = lsy_1_n - 3;  
        }
        fsy_1 = lsy_1_n / 3 + lsy_1_n % 6 - 1;
    }
    else if(tx == num_tile_x - 1) // right
    {        
        fsx_a = lsx_a_n / 2 + 2;  //IOB_A
        if((lsy_a_n % 6) > 3 )
        {
            fsx_a = fsx_a + 2;
            lsy_a_n = lsy_a_n - 3;     
        }     
        fsy_a = lsy_a_n / 3 + lsy_a_n % 6 - 1;

        fsx_b = lsx_b_n / 2 + 2;  //IOB_B
        if((lsy_b_n % 6) > 3 )
        {
            fsx_b = fsx_b + 2;
            lsy_b_n = lsy_b_n - 3;     
        }     
        fsy_b = lsy_b_n / 3 + lsy_b_n % 6 - 1;

        fsx_0 = lsx_0_n / 2 + 2;  //IOL_0
        if((lsy_0_n % 6) > 3 )
        {
            fsx_0 = fsx_0 + 2;
            lsy_0_n = lsy_0_n - 3;     
        }     
        fsy_0 = lsy_0_n / 3 + lsy_0_n % 6 - 1;

        fsx_1 = lsx_1_n / 2 + 2;  //IOL_1
        if((lsy_1_n % 6) > 3 )
        {
            fsx_1 = fsx_1 + 2;
            lsy_1_n = lsy_1_n - 3;     
        }     
        fsy_1 = lsy_1_n / 3 + lsy_1_n % 6 - 1;
    }

    // Pull out the device instances from logic structure
    s0Ref = <device IOL   @[lsx+1,lsy+2]   of ARCHITECTURE>;
    s1Ref = <device IOL   @[lsx+1,lsy+1]   of ARCHITECTURE>;

    d0Ref = <device IOB_B @[lsx+2,lsy+2]   of ARCHITECTURE>;
    d1Ref = <device IOB_A @[lsx+2,lsy+1]   of ARCHITECTURE>;    

    // Instantiate the device. 
    sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+2);
    s0fl = device IOL ( structure fp_struct ) *strVar @[fsx_0,fsy_0];

    sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+1);
    s1fl = device IOL ( structure fp_struct ) *strVar @[fsx_1,fsy_1];

    sprintf(strVar, "IOB_B_%d_%d", lsx+2, lsy+2);
    d0fl = device IOB_B ( structure fp_struct ) *strVar @[fsx_b,fsy_b];

    sprintf(strVar, "IOB_A_%d_%d", lsx+2, lsy+1);
    d1fl = device IOB_A ( structure fp_struct ) *strVar @[fsx_a,fsy_a];     

    map ( 
        s0fl => s0Ref, 
        s1fl => s1Ref, 
        d0fl => d0Ref, 
        d1fl => d1Ref                   
        );

}; // end of function place_io_tile_fp  


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io tile fp]
  
---------|---------|---------|--------- 
          IOL[1,2]  IOB_B[2,2] C[3,2]                            
  V[0,1]  IOL[1,1]  IOB_A[2,1] 
  G[0,0]  R[1,0]    I[2,0]      
---------|---------|---------|---------   

  Revision History:

*****************************************************************************************/
function draw_io_tile_fp 
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref, s1Ref, d0Ref, d1Ref;
    &schematic s0schm, s1schm, d0schm, d1schm;

    string strVar;
    if(tx == 0) //left
    {
        lsx = tx * TILE_NUM_SITE_X;
        lsy = ty * TILE_NUM_SITE_Y;
        gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
        gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;
        
        // Pull out the device instances from logic structure
        
        // Instantiate the schematic. 
        sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+2);
        s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s0schm = device IOL ( schematic floorplan_view ) *strVar @[gsx+160,gsy+160];
        
        sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+1);
        s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s1schm = device IOL ( schematic floorplan_view ) *strVar @[gsx+160,gsy];
        
        sprintf(strVar, "IOB_B_%d_%d", lsx+2, lsy+2);
        d0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        d0schm = device IOB_B ( schematic floorplan_view ) *strVar @[gsx,gsy+160];
        
        sprintf(strVar, "IOB_A_%d_%d", lsx+2, lsy+1);
        d1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        d1schm = device IOB_A ( schematic floorplan_view ) *strVar @[gsx,gsy];     
    
    }     
    
    if(tx == num_tile_x - 1) //right
    {
        lsx = tx * TILE_NUM_SITE_X;
        lsy = ty * TILE_NUM_SITE_Y;
        gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
        gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;
        
        // Pull out the device instances from logic structure
        
        // Instantiate the schematic. 
        sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+2);
        s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s0schm = device IOL ( schematic floorplan_view ) *strVar @[gsx,gsy+160];
        
        sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+1);
        s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s1schm = device IOL ( schematic floorplan_view ) *strVar @[gsx,gsy];
        
        sprintf(strVar, "IOB_B_%d_%d", lsx+2, lsy+2);
        d0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        d0schm = device IOB_B ( schematic floorplan_view ) *strVar @[gsx+160,gsy+160];
        
        sprintf(strVar, "IOB_A_%d_%d", lsx+2, lsy+1);
        d1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        d1schm = device IOB_A ( schematic floorplan_view ) *strVar @[gsx+160,gsy];     
    }     
    
    if(ty == 0) //bottom
    {
         lsx = tx * TILE_NUM_SITE_X;
         lsy = ty * TILE_NUM_SITE_Y;
         gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
         gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

         // Pull out the device instances from logic structure
         
         // Instantiate the schematic. 
         sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+2);
         s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
         s0schm = device IOL ( schematic floorplan_view ) *strVar @[gsx+160,gsy+160];
         
         sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+1);
         s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
         s1schm = device IOL ( schematic floorplan_view ) *strVar @[gsx,gsy+160];
         
         sprintf(strVar, "IOB_B_%d_%d", lsx+2, lsy+2);
         d0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
         d0schm = device IOB_B ( schematic floorplan_view ) *strVar @[gsx+160,gsy];
         
         sprintf(strVar, "IOB_A_%d_%d", lsx+2, lsy+1);
         d1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
         d1schm = device IOB_A ( schematic floorplan_view ) *strVar @[gsx,gsy]; 
        
    }
    
    if(ty == num_tile_y - 1) //top
    {
         lsx = tx * TILE_NUM_SITE_X;
         lsy = ty * TILE_NUM_SITE_Y;
         gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
         gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;
         
         // Pull out the device instances from logic structure
         
         // Instantiate the schematic. 
         sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+2);
         s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
         s0schm = device IOL ( schematic floorplan_view ) *strVar @[gsx+160,gsy];
         
         sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+1);
         s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
         s1schm = device IOL ( schematic floorplan_view ) *strVar @[gsx,gsy];
         
         sprintf(strVar, "IOB_B_%d_%d", lsx+2, lsy+2);
         d0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
         d0schm = device IOB_B ( schematic floorplan_view ) *strVar @[gsx+160,gsy+160];
         
         sprintf(strVar, "IOB_A_%d_%d", lsx+2, lsy+1);
         d1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
         d1schm = device IOB_A ( schematic floorplan_view ) *strVar @[gsx,gsy+160]; 
        
    }
      
                   
    map ( 
            s0schm => s0Ref, 
            s1schm => s1Ref,
            d0schm => d0Ref, 
            d1schm => d1Ref         
        );


}; // end of function draw_io_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io_l tile fp]
  
  ---------|---------|---------|--------- 
            IOL_L[1,2]  IOB_LB[2,2] C[3,2]                           
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1] 
    G[0,0]  R[1,0]      I[2,0]       
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function place_io_l_tile_fp
( 
    unsigned int tx,
    unsigned int ty
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, fsx_l0, fsy_l0, fsx_l1, fsy_l1, fsx_la, fsy_la, fsx_lb, fsy_lb;
    unsigned int lsx_l0, lsy_l0, lsx_l1, lsy_l1, lsx_la, lsy_la, lsx_lb, lsy_lb;
    unsigned int lsx_l0_n, lsy_l0_n, lsx_l1_n, lsy_l1_n, lsx_la_n, lsy_la_n, lsx_lb_n, lsy_lb_n;      
    unsigned int T;    
    
    // device reference variables
    &device s0Ref,s1Ref,d0Ref,d1Ref;
    &device s0fl,s1fl,d0fl,d1fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
 
    lsx_l0 = lsx + 1;
    lsy_l0 = lsy + 2;
    
    lsx_l1 = lsx + 1;
    lsy_l1 = lsy + 1; 
    
    lsx_lb = lsx + 2;
    lsy_lb = lsy + 2;
    
    lsx_la = lsx + 2;
    lsy_la = lsy + 1;         
////////////////////////////////////////////////////////// 
    if(lsy_lb > 183 )   //IOB_LB
    {
      T = 2;
    }
    else if(lsy_lb > 60)
    {
      T = 1;  
    }
    else
    {
      T = 0;     
    }
    lsy_lb_n = lsy_lb - 3 * T;
    
    lsx_lb_n = lsx_lb;        
    if(lsx_lb > 100)
    {
      lsx_lb_n = lsx_lb - 4; 
    }
    
    if(lsy_la > 183 )   //IOB_LA
    {
      T = 2;   
    }
    else if(lsy_la > 60)
    {
      T = 1; 
    }
    else
    {
      T = 0;  
    }
    lsy_la_n = lsy_la - 3 * T;

    lsx_la_n = lsx_la;     
    if(lsx_la > 100)
    {
      lsx_la_n = lsx_la - 4; 
    }
    
    if(lsy_l0 > 183 )   //IO_L0
    {
      T = 2;   
    }
    else if(lsy_l0 > 60)
    {
      T = 1; 
    }
    else
    {
      T = 0;  
    }
    lsy_l0_n = lsy_l0 - 3 * T;
    
    lsx_l0_n = lsx_l0; 
    
    if(lsy_l1 > 183 )   //IO_L1
    {
      T = 2;   
    }
    else if(lsy_l1 > 60)
    {
      T = 1; 
    }
    else
    {
      T = 0;  
    }
    lsy_l1_n = lsy_l1 - 3 * T;
    
    lsx_l1_n = lsx_l1;  
  
////////////////////////////////////////////////////////// 
    if(lsx_lb < 3)      //IOB_LB
    {
      fsx_lb = lsy_lb_n % 6;
      if(fsx_lb < 3)
      {
          fsx_lb = 1;   
      }
      else
      {
          fsx_lb = 3;
          lsy_lb_n = lsy_lb_n - 3;           
      }
      fsy_lb = lsy_lb_n / 3 + lsy_lb_n % 6 - 1;
    }
    
    if(lsx_la < 3)      //IOB_LA
    {
      fsx_la = lsy_la_n % 6;
      if(fsx_la < 3)
      {
          fsx_la = 1;   
      }
      else
      {
          fsx_la = 3;
          lsy_la_n = lsy_la_n - 3;           
      }
      fsy_la = lsy_la_n / 3 + lsy_la_n % 6 - 1;
    }
    
    fsx_l0 = lsy_l0_n % 6;  //IO_L0
    
    if(fsx_l0 < 3)      
    {
      fsx_l0 = 0;
    }
    else
    {
      fsx_l0 = 2;  
      lsy_l0_n = lsy_l0_n - 3;  
    }
    fsy_l0 = lsy_l0_n / 3 + lsy_l0_n % 6 - 1;
    
    fsx_l1 = lsy_l1_n % 6;  //IO_L1
    
    if(fsx_l1 < 3)      
    {
      fsx_l1 = 0;
    }
    else
    {
      fsx_l1 = 2;  
      lsy_l1_n = lsy_l1_n - 3;  
    }
    fsy_l1 = lsy_l1_n / 3 + lsy_l1_n % 6 - 1;       
            
     //Pull out the device instances from logic structure
    s0Ref = <device IOL_L   @[lsx+1,lsy+2]   of ARCHITECTURE>;
    s1Ref = <device IOL_L   @[lsx+1,lsy+1]   of ARCHITECTURE>;
    
    d0Ref = <device IOB_LB  @[lsx+2,lsy+2]   of ARCHITECTURE>;
    d1Ref = <device IOB_LA  @[lsx+2,lsy+1]   of ARCHITECTURE>;    

    // Instantiate the device. 
    sprintf(strVar, "IOL_L_%d_%d", lsx+1, lsy+2);
    s0fl = device IOL_L ( structure fp_struct ) *strVar @[fsx_l0,fsy_l0];

    sprintf(strVar, "IOL_L_%d_%d", lsx+1, lsy+1);
    s1fl = device IOL_L ( structure fp_struct ) *strVar @[fsx_l1,fsy_l1];

    sprintf(strVar, "IOB_LB_%d_%d", lsx+2, lsy+2);
    d0fl = device IOB_LB ( structure fp_struct ) *strVar @[fsx_lb,fsy_lb];

    sprintf(strVar, "IOB_LA_%d_%d", lsx+2, lsy+1);
    d1fl = device IOB_LA ( structure fp_struct ) *strVar @[fsx_la,fsy_la];      
           
    map ( 
            s0fl => s0Ref, 
            s1fl => s1Ref, 
            d0fl => d0Ref, 
            d1fl => d1Ref
         );


}; // end of function place_io_l_tile_fp  


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_l tile fp]
  
  ---------|---------|---------|--------- 
            IOL_L[1,2]  IOB_LB[2,2] C[3,2]                           
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1] 
    G[0,0]  R[1,0]      I[2,0]       
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function draw_io_l_tile_fp 
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref, s1Ref, d0Ref, d1Ref;
    &schematic s0schm, s1schm, d0schm, d1schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "IOL_L_%d_%d", lsx+1, lsy+2);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device IOL_L ( schematic floorplan_view ) *strVar @[gsx+160,gsy+160];

    sprintf(strVar, "IOL_L_%d_%d", lsx+1, lsy+1);
    s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s1schm = device IOL_L ( schematic floorplan_view ) *strVar @[gsx+160,gsy];

    sprintf(strVar, "IOB_LB_%d_%d", lsx+2, lsy+2);
    d0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d0schm = device IOB_LB ( schematic floorplan_view ) *strVar @[gsx,gsy+160];

    sprintf(strVar, "IOB_LA_%d_%d", lsx+2, lsy+1);
    d1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d1schm = device IOB_LA ( schematic floorplan_view ) *strVar @[gsx,gsy];    
                   
    map ( 
            s0schm => s0Ref, 
            s1schm => s1Ref,
            d0schm => d0Ref, 
            d1schm => d1Ref         
        );


}; // end of function draw_io_l_tile_fp

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io_l_1b tile fp]
  
  ---------|---------|---------|--------- 
            IOL_L[1,2]  IOB_LB[2,2] C[3,2]                           
    V[0,1]  
    G[0,0]  R[1,0]      I[2,0]       
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function place_io_l_1b_tile_fp
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, fsx_l0, fsy_l0, fsx_lb, fsy_lb;
    unsigned int lsx_l0, lsy_l0, lsx_lb, lsy_lb;
    unsigned int lsx_l0_n, lsy_l0_n, lsx_lb_n, lsy_lb_n;      
    unsigned int T;    
    
    // device reference variables
    &device s0Ref,d0Ref;
    &device s0fl,d0fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    
    lsx_l0 = lsx + 1;
    lsy_l0 = lsy + 2;    
    
    lsx_lb = lsx + 2;
    lsy_lb = lsy + 2;
            
////////////////////////////////////////////////////////// 
    if(lsy_lb > 429 )   //IOB_LB, left
    {
      T = 4;
    }
    else if(lsy_lb > 306)
    {
      T = 3;  
    }
    else if(lsy_lb > 183)
    {
      T = 2;  
    }
    else if(lsy_lb > 60)
    {
      T = 1;  
    }
    else
    {
      T = 0;     
    }
    lsy_lb_n = lsy_lb - 3 * T;
    
    lsx_lb_n = lsx_lb;        
    if(lsx_lb > 280)
    {
      lsx_lb_n = lsx_lb - 4; 
    }    
////////////////////////////////////////////////////////// 
    if(lsy_l0 > 429 )   //IOL
    {
      T = 4;
    }
    else if(lsy_l0 > 306)
    {
      T = 3;  
    }
    else if(lsy_l0 > 183)
    {
      T = 2;  
    }
    else if(lsy_l0 > 60)
    {
      T = 1;  
    }
    else
    {
      T = 0;     
    }
    lsy_l0_n = lsy_l0 - 3 * T;
    
    lsx_l0_n = lsx_l0; 
    if(lsx_l0 > 280)
    {
        lsx_l0_n = lsx_l0 - 4; 
    }

    
////////////////////////////////////////////////////////// 
    if(lsx_lb < 3)      //IOB_LB
    {
      fsx_lb = lsy_lb_n % 6;
      if(fsx_lb < 3)
      {
          fsx_lb = 1;   
      }
      else
      {
          fsx_lb = 3;
          lsy_lb_n = lsy_lb_n - 3;           
      }
      fsy_lb = lsy_lb_n / 3 + lsy_lb_n % 6 - 1;
    }
    
    ////////////////////////////////////////////////////////// 
    fsx_l0 = lsy_l0_n % 6;  //IOL
    
    if(fsx_l0 < 3)      
    {
      fsx_l0 = 0;
    }
    else
    {
      fsx_l0 = 2;  
      lsy_l0_n = lsy_l0_n - 3;  
    }
    fsy_l0 = lsy_l0_n / 3 + lsy_l0_n % 6 - 1;
            
     //Pull out the device instances from logic structure
    s0Ref = <device IOL   @[lsx+1,lsy+2]   of ARCHITECTURE>;    
    d0Ref = <device IOB_LB  @[lsx+2,lsy+2]   of ARCHITECTURE>;  

    // Instantiate the device. 
    sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+2);
    s0fl = device IOL ( structure fp_struct ) *strVar @[fsx_l0,fsy_l0];

    sprintf(strVar, "IOB_LB_%d_%d", lsx+2, lsy+2);
    d0fl = device IOB_LB ( structure fp_struct ) *strVar @[fsx_lb,fsy_lb];    
           
    map ( 
            s0fl => s0Ref, 
            d0fl => d0Ref
         );

}; // end of function place_io_l_tile_fp  


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_l_1b tile fp]
  
  ---------|---------|---------|--------- 
            IOL_L[1,2]  IOB_LB[2,2] C[3,2]                           
    V[0,1]  
    G[0,0]  R[1,0]      I[2,0]       
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function draw_io_l_1b_tile_fp 
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref, d0Ref;
    &schematic s0schm, d0schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+2);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device IOL ( schematic floorplan_view ) *strVar @[gsx+160,gsy+160];

    sprintf(strVar, "IOB_LB_%d_%d", lsx+2, lsy+2);
    d0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d0schm = device IOB_LB ( schematic floorplan_view ) *strVar @[gsx,gsy+160];    
                   
    map ( 
            s0schm => s0Ref, 
            d0schm => d0Ref        
        );


}; // end of function draw_io_l_tile_fp

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io_f tile fp]
  
---------|---------|---------|--------- 
          IOL[1,2]  IOB_LB[2,2] C[3,2]                            
  V[0,1]  IOL[1,1]  IOB_LA[2,1] 
  G[0,0]  R[1,0]    I[2,0]      
---------|---------|---------|---------   

  Revision History:

*****************************************************************************************/
function place_io_f_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, fsx_0, fsy_0, fsx_1, fsy_1, fsx_la, fsy_la, fsx_lb, fsy_lb;
    unsigned int lsx_0, lsy_0, lsx_1, lsy_1, lsx_la, lsy_la, lsx_lb, lsy_lb;
    unsigned int lsx_0_n, lsy_0_n, lsx_1_n, lsy_1_n, lsx_la_n, lsy_la_n, lsx_lb_n, lsy_lb_n;      
    unsigned int T;    
    // device reference variables
    &device s0Ref,s1Ref,d0Ref,d1Ref;
    &device s0fl,s1fl,d0fl,d1fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;

    lsx_0 = lsx + 1;
    lsy_0 = lsy + 2;

    lsx_1 = lsx + 1;
    lsy_1 = lsy + 1; 

    lsx_lb = lsx + 2;
    lsy_lb = lsy + 2;

    lsx_la = lsx + 2;
    lsy_la = lsy + 1;    

    //////////////////////////////////////////////////////////
    if(lsy_la > 429 )   //IOB_LA
    {
        T = 4;
    }
    else if(lsy_la > 306)
    {
        T = 3;  
    }
    else if(lsy_la > 183)
    {
        T = 2;  
    }
    else if(lsy_la > 60)
    {
        T = 1;  
    }
    else
    {
        T = 0;     
    }
    lsy_la_n = lsy_la - 3 * T;
    lsx_la_n = lsx_la;         
    if(lsx_la > 280)
    {
        lsx_la_n = lsx_la - 4; 
    }
    //////////////////////////////////////////////////////////
    if(lsy_lb > 429 )   //IOB_LB
    {
        T = 4;
    }
    else if(lsy_lb > 306)
    {
        T = 3;  
    }
    else if(lsy_lb > 183)
    {
        T = 2;  
    }
    else if(lsy_lb > 60)
    {
        T = 1;  
    }
    else
    {
        T = 0;     
    }
    lsy_lb_n = lsy_lb - 3 * T;
    lsx_lb_n = lsx_lb;            
    if(lsx_lb > 280)
    {
        lsx_lb_n = lsx_lb - 4; 
    }
    //////////////////////////////////////////////////////////
    if(lsy_0 > 429 )   //IOL_0
    {
        T = 4;
    }
    else if(lsy_0 > 306)
    {
        T = 3;  
    }
    else if(lsy_0 > 183)
    {
        T = 2;  
    }
    else if(lsy_0 > 60)
    {
        T = 1;  
    }
    else
    {
        T = 0;     
    }
    lsy_0_n = lsy_0 - 3 * T;
    lsx_0_n = lsx_0;         
    if(lsx_0 > 280)
    {
        lsx_0_n = lsx_0 - 4; 
    }            
    //////////////////////////////////////////////////////////
    if(lsy_1 > 429 )   //IOL_1
    {
        T = 4;
    }
    else if(lsy_1 > 306)
    {
        T = 3;  
    }
    else if(lsy_1 > 183)
    {
        T = 2;  
    }
    else if(lsy_1 > 60)
    {
        T = 1;  
    }
    else
    {
        T = 0;     
    }
    lsy_1_n = lsy_1 - 3 * T;
    lsx_1_n = lsx_1;         
    if(lsx_1 > 280)
    {
        lsx_1_n = lsx_1 - 4; 
    }    
//////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
    if(ty == 0)// bottom
    {
        if(lsy_la_n < 3)    //IOB_LA
        {
            fsx_la = lsx_la_n / 2 + 2;
            fsy_la = lsy_la_n - 1;    
        }  

        if(lsy_lb_n < 3)    //IOB_LB
        {
            fsx_lb = lsx_lb_n / 2 + 2;
            fsy_lb = lsy_lb_n - 1;    
        }  

        if(lsy_0_n < 3)    //IOL_0
        {
            fsx_0 = lsx_0_n / 2 + 2;
            fsy_0 = lsy_0_n - 1;    
        }          

        if(lsy_1_n < 3)    //IOL_1
        {
            fsx_1 = lsx_1_n / 2 + 2;
            fsy_1 = lsy_1_n - 1;    
        }             
    }
    else if(ty == num_tile_y - 1) // top
    {
        fsx_lb = lsx_lb_n / 2 + 2;  //IOB_LB
        fsy_lb = lsy_lb_n / 3 + 1; 
        if((lsy_lb_n % 3) == 2 )
        {
            fsy_lb = fsy_lb + 1;     
        }  

        fsx_la = lsx_la_n / 2 + 2;  //IOB_LA
        fsy_la = lsy_la_n / 3 + 1; 
        if((lsy_la_n % 3) == 2 )
        {
            fsy_la = fsy_la + 1;     
        }   

        fsx_0 = lsx_0_n / 2 + 2;  //IOL_0
        fsy_0 = lsy_0_n / 3 + 1; 
        if((lsy_0_n % 3) == 2 )
        {
            fsy_0 = fsy_0 + 1;     
        }   

        fsx_1 = lsx_1_n / 2 + 2;  //IOL_1
        fsy_1 = lsy_1_n / 3 + 1; 
        if((lsy_1_n % 3) == 2 )
        {
            fsy_1 = fsy_1 + 1;     
        }        
    }
    else if(tx == 0) // left
    {        
        fsx_la = lsy_la_n % 6; //IOB_LA
        if(fsx_la < 3)
        {
            fsx_la = 1;   
        }
        else
        {
            fsx_la = 3;
            lsy_la_n = lsy_la_n - 3;           
        }
        fsy_la = lsy_la_n / 3 + lsy_la_n % 6 - 1;

        fsx_lb = lsy_lb_n % 6; //IOB_LB
        if(fsx_lb < 3)
        {
            fsx_lb = 1;   
        }
        else
        {
            fsx_lb = 3;
            lsy_lb_n = lsy_lb_n - 3;           
        }
        fsy_lb = lsy_lb_n / 3 + lsy_lb_n % 6 - 1;

        fsx_0 = lsy_0_n % 6;  //IOL_0        
        if(fsx_0 < 3)      
        {
            fsx_0 = 0;
        }
        else
        {
            fsx_0 = 2;  
            lsy_0_n = lsy_0_n - 3;  
        }
        fsy_0 = lsy_0_n / 3 + lsy_0_n % 6 - 1;

        fsx_1 = lsy_1_n % 6;  //IOL_1        
        if(fsx_1 < 3)      
        {
            fsx_1 = 0;
        }
        else
        {
            fsx_1 = 2;  
            lsy_1_n = lsy_1_n - 3;  
        }
        fsy_1 = lsy_1_n / 3 + lsy_1_n % 6 - 1;
    }
    else if(tx == num_tile_x - 1) // right
    {        
        fsx_la = lsx_la_n / 2 + 2;  //IOB_LA
        if((lsy_la_n % 6) > 3 )
        {
            fsx_la = fsx_la + 2;
            lsy_la_n = lsy_la_n - 3;     
        }     
        fsy_la = lsy_la_n / 3 + lsy_la_n % 6 - 1;

        fsx_lb = lsx_lb_n / 2 + 2;  //IOB_LB
        if((lsy_lb_n % 6) > 3 )
        {
            fsx_lb = fsx_lb + 2;
            lsy_lb_n = lsy_lb_n - 3;     
        }     
        fsy_lb = lsy_lb_n / 3 + lsy_lb_n % 6 - 1;

        fsx_0 = lsx_0_n / 2 + 2;  //IOL_0
        if((lsy_0_n % 6) > 3 )
        {
            fsx_0 = fsx_0 + 2;
            lsy_0_n = lsy_0_n - 3;     
        }     
        fsy_0 = lsy_0_n / 3 + lsy_0_n % 6 - 1;

        fsx_1 = lsx_1_n / 2 + 2;  //IOL_1
        if((lsy_1_n % 6) > 3 )
        {
            fsx_1 = fsx_1 + 2;
            lsy_1_n = lsy_1_n - 3;     
        }     
        fsy_1 = lsy_1_n / 3 + lsy_1_n % 6 - 1;
    }

    //////////////////////////////////////////////////////////               
    // Pull out the device instances from logic structure
    s0Ref = <device IOL   @[lsx+1,lsy+2]   of ARCHITECTURE>;
    s1Ref = <device IOL   @[lsx+1,lsy+1]   of ARCHITECTURE>;

    d0Ref = <device IOB_LB @[lsx+2,lsy+2]   of ARCHITECTURE>;
    d1Ref = <device IOB_LA @[lsx+2,lsy+1]   of ARCHITECTURE>;    

    // Instantiate the device. 
    sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+2);
    s0fl = device IOL ( structure fp_struct ) *strVar @[fsx_0,fsy_0];

    sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+1);
    s1fl = device IOL ( structure fp_struct ) *strVar @[fsx_1,fsy_1];

    sprintf(strVar, "IOB_LB_%d_%d", lsx+2, lsy+2);
    d0fl = device IOB_LB ( structure fp_struct ) *strVar @[fsx_lb,fsy_lb];

    sprintf(strVar, "IOB_LA_%d_%d", lsx+2, lsy+1);
    d1fl = device IOB_LA ( structure fp_struct ) *strVar @[fsx_la,fsy_la];     

    map ( 
        s0fl => s0Ref, 
        s1fl => s1Ref, 
        d0fl => d0Ref, 
        d1fl => d1Ref                   
        );

}; // end of function place_io_f_tile_fp  


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_f tile fp]
  
---------|---------|---------|--------- 
          IOL[1,2]  IOB_LB[2,2] C[3,2]                            
  V[0,1]  IOL[1,1]  IOB_LA[2,1] 
  G[0,0]  R[1,0]    I[2,0]      
---------|---------|---------|---------   

  Revision History:

*****************************************************************************************/
function draw_io_f_tile_fp 
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref, s1Ref, d0Ref, d1Ref;
    &schematic s0schm, s1schm, d0schm, d1schm;

    string strVar;
    if(tx == 0) //left
    {
        lsx = tx * TILE_NUM_SITE_X;
        lsy = ty * TILE_NUM_SITE_Y;
        gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
        gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;
        
        // Pull out the device instances from logic structure
        
        // Instantiate the schematic. 
        sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+2);
        s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s0schm = device IOL ( schematic floorplan_view ) *strVar @[gsx+160,gsy+160];
        
        sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+1);
        s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s1schm = device IOL ( schematic floorplan_view ) *strVar @[gsx+160,gsy];
        
        sprintf(strVar, "IOB_LB_%d_%d", lsx+2, lsy+2);
        d0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        d0schm = device IOB_LB ( schematic floorplan_view ) *strVar @[gsx,gsy+160];
        
        sprintf(strVar, "IOB_LA_%d_%d", lsx+2, lsy+1);
        d1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        d1schm = device IOB_LA ( schematic floorplan_view ) *strVar @[gsx,gsy];     
    
    }     
    
    if(tx == num_tile_x - 1) //right
    {
        lsx = tx * TILE_NUM_SITE_X;
        lsy = ty * TILE_NUM_SITE_Y;
        gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
        gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;
        
        // Pull out the device instances from logic structure
        
        // Instantiate the schematic. 
        sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+2);
        s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s0schm = device IOL ( schematic floorplan_view ) *strVar @[gsx,gsy+160];
        
        sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+1);
        s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s1schm = device IOL ( schematic floorplan_view ) *strVar @[gsx,gsy];
        
        sprintf(strVar, "IOB_LB_%d_%d", lsx+2, lsy+2);
        d0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        d0schm = device IOB_LB ( schematic floorplan_view ) *strVar @[gsx+160,gsy+160];
        
        sprintf(strVar, "IOB_LA_%d_%d", lsx+2, lsy+1);
        d1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        d1schm = device IOB_LA ( schematic floorplan_view ) *strVar @[gsx+160,gsy];     
    
    }     
    if(ty == 0) //bottom
    {
         lsx = tx * TILE_NUM_SITE_X;
         lsy = ty * TILE_NUM_SITE_Y;
         gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
         gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

         // Pull out the device instances from logic structure
         
         // Instantiate the schematic. 
         sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+2);
         s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
         s0schm = device IOL ( schematic floorplan_view ) *strVar @[gsx+160,gsy+160];
         
         sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+1);
         s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
         s1schm = device IOL ( schematic floorplan_view ) *strVar @[gsx,gsy+160];
         
         sprintf(strVar, "IOB_LB_%d_%d", lsx+2, lsy+2);
         d0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
         d0schm = device IOB_LB ( schematic floorplan_view ) *strVar @[gsx+160,gsy];
         
         sprintf(strVar, "IOB_LA_%d_%d", lsx+2, lsy+1);
         d1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
         d1schm = device IOB_LA ( schematic floorplan_view ) *strVar @[gsx,gsy]; 
        
    }
    
    if(ty == num_tile_y - 1) //top
    {
         lsx = tx * TILE_NUM_SITE_X;
         lsy = ty * TILE_NUM_SITE_Y;
         gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
         gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;
         
         // Pull out the device instances from logic structure
         
         // Instantiate the schematic. 
         sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+2);
         s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
         s0schm = device IOL ( schematic floorplan_view ) *strVar @[gsx+160,gsy];
         
         sprintf(strVar, "IOL_%d_%d", lsx+1, lsy+1);
         s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
         s1schm = device IOL ( schematic floorplan_view ) *strVar @[gsx,gsy];
         
         sprintf(strVar, "IOB_LB_%d_%d", lsx+2, lsy+2);
         d0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
         d0schm = device IOB_LB ( schematic floorplan_view ) *strVar @[gsx+160,gsy+160];
         
         sprintf(strVar, "IOB_LA_%d_%d", lsx+2, lsy+1);
         d1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
         d1schm = device IOB_LA ( schematic floorplan_view ) *strVar @[gsx,gsy+160]; 
        
    }
                   
    map ( 
            s0schm => s0Ref, 
            s1schm => s1Ref,
            d0schm => d0Ref, 
            d1schm => d1Ref         
        );

}; // end of function draw_io_f_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io_4cim_6io_ttfftt_h tile fp]
  
  ---------|---------|---------|---------   ---------|---------|---------|---------    ---------|---------|---------|---------  ---------|---------|---------|---------   
            IOL[1,2]  IOB_B[2,2]                      IOL[1,2]  IOB_LB[2,2]                                                               IOL[1,2]  IOB_B[2,2]       
    V[0,1]  IOL[1,1]  IOB_A[2,1]            V[0,1]    IOL[1,1]  IOB_LA[2,1]            V[0,1]                                   V[0,1]    IOL[1,1]  IOB_A[2,1]       
    G[0,0]  R[1,0]    I[2,0]                G[0,0]    R[1,0]    I[2,0]                 G[0,0]    R[1,0]    I[2,0]               G[0,0]    R[1,0]    I[2,0]            
  ---------|---------|---------|---------   ---------|---------|---------|---------    ---------|---------|---------|---------  ---------|---------|---------|---------  

  Revision History:

*****************************************************************************************/
function place_io_4cim_6io_ttfftt_h_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    place_io_tile_fp(tx, ty, num_tile_x, num_tile_y);
    place_io_f_tile_fp(tx+1, ty, num_tile_x, num_tile_y);
    place_io_tile_fp(tx+3, ty, num_tile_x, num_tile_y);

}; // end of function place_io_4cim_6io_ttfftt_h_tile_fp  


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_4cim_6io_ttfftt_h tile fp]
  
  ---------|---------|---------|---------   ---------|---------|---------|---------    ---------|---------|---------|---------  ---------|---------|---------|---------   
            IOL[1,2]  IOB_B[2,2]                      IOL[1,2]  IOB_LB[2,2]                                                               IOL[1,2]  IOB_B[2,2]       
    V[0,1]  IOL[1,1]  IOB_A[2,1]            V[0,1]    IOL[1,1]  IOB_LA[2,1]            V[0,1]                                   V[0,1]    IOL[1,1]  IOB_A[2,1]       
    G[0,0]  R[1,0]    I[2,0]                G[0,0]    R[1,0]    I[2,0]                 G[0,0]    R[1,0]    I[2,0]               G[0,0]    R[1,0]    I[2,0]            
  ---------|---------|---------|---------   ---------|---------|---------|---------    ---------|---------|---------|---------  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function draw_io_4cim_6io_ttfftt_h_tile_fp 
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    draw_io_tile_fp(tx, ty, num_tile_x, num_tile_y);
    draw_io_f_tile_fp(tx+1, ty, num_tile_x, num_tile_y);
    draw_io_tile_fp(tx+3, ty, num_tile_x, num_tile_y);

}; // end of function draw_io_4cim_6io_ttfftt_h_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io_4cim_6io_ffttff_h tile fp]
  
  ---------|---------|---------|---------   ---------|---------|---------|---------    ---------|---------|---------|---------  ---------|---------|---------|---------   
            IOL[1,2]  IOB_LB[2,2]                     IOL[1,2]  IOB_B[2,2]                                                                IOL[1,2]  IOB_LB[2,2]       
    V[0,1]  IOL[1,1]  IOB_LA[2,1]           V[0,1]    IOL[1,1]  IOB_A[2,1]             V[0,1]                                   V[0,1]    IOL[1,1]  IOB_LA[2,1]       
    G[0,0]  R[1,0]    I[2,0]                G[0,0]    R[1,0]    I[2,0]                 G[0,0]    R[1,0]    I[2,0]               G[0,0]    R[1,0]    I[2,0]            
  ---------|---------|---------|---------   ---------|---------|---------|---------    ---------|---------|---------|---------  ---------|---------|---------|---------  

  Revision History:

*****************************************************************************************/
function place_io_4cim_6io_ffttff_h_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    place_io_f_tile_fp(tx, ty, num_tile_x, num_tile_y);
    place_io_tile_fp(tx+1, ty, num_tile_x, num_tile_y);
    place_io_f_tile_fp(tx+3, ty, num_tile_x, num_tile_y);

}; // end of function place_io_4cim_6io_ffttff_h_tile_fp  


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_4cim_6io_ffttff_h tile fp]
  
  ---------|---------|---------|---------   ---------|---------|---------|---------    ---------|---------|---------|---------  ---------|---------|---------|---------   
            IOL[1,2]  IOB_LB[2,2]                     IOL[1,2]  IOB_B[2,2]                                                                IOL[1,2]  IOB_LB[2,2]       
    V[0,1]  IOL[1,1]  IOB_LA[2,1]           V[0,1]    IOL[1,1]  IOB_A[2,1]             V[0,1]                                   V[0,1]    IOL[1,1]  IOB_LA[2,1]       
    G[0,0]  R[1,0]    I[2,0]                G[0,0]    R[1,0]    I[2,0]                 G[0,0]    R[1,0]    I[2,0]               G[0,0]    R[1,0]    I[2,0]            
  ---------|---------|---------|---------   ---------|---------|---------|---------    ---------|---------|---------|---------  ---------|---------|---------|--------- 

  Revision History:

*****************************************************************************************/
function draw_io_4cim_6io_ffttff_h_tile_fp 
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    draw_io_f_tile_fp(tx, ty, num_tile_x, num_tile_y);
    draw_io_tile_fp(tx+1, ty, num_tile_x, num_tile_y);
    draw_io_f_tile_fp(tx+3, ty, num_tile_x, num_tile_y);

}; // end of function draw_io_4cim_6io_ffttff_h_tile_fp



/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io_4cim_6io_dqs_h tile fp]
  
  ---------|---------|---------|---------   ---------|---------|---------|---------    ---------|---------|---------|---------  ---------|---------|---------|---------   
            IOL[1,2]  IOB_B[2,2]                      IOL[1,2]  IOB_LB[2,2]                                                               IOL[1,2]  IOB_B[2,2]       
    V[0,1]  IOL[1,1]  IOB_A[2,1]            V[0,1]    IOL[1,1]  IOB_LA[2,1]            V[0,1]                                   V[0,1]    IOL[1,1]  IOB_A[2,1]       
    G[0,0]  R[1,0]    I[2,0]                G[0,0]    R[1,0]    I[2,0]                 G[0,0]    R[1,0]    I[2,0]    DQS[3,0]   G[0,0]    R[1,0]    I[2,0]            
  ---------|---------|---------|---------   ---------|---------|---------|---------    ---------|---------|---------|---------  ---------|---------|---------|---------    
  
                TILE 0                                  TILE 1                                      TILE 2                                  TILE 3 

  Revision History:

*****************************************************************************************/
function place_io_4cim_6io_dqs_h_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y,
    unsigned int blank_x0
)
{
    place_io_tile_fp(tx, ty, num_tile_x, num_tile_y);
    place_io_f_tile_fp(tx+1, ty, num_tile_x, num_tile_y);
    place_dqs_tile_fp(tx+2, ty, blank_x0);
    place_io_tile_fp(tx+3, ty, num_tile_x, num_tile_y);

}; // end of function place_io_4cim_6io_dqs_h_tile_fp  


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_4cim_6io_dqs_h tile fp]
  
  ---------|---------|---------|---------   ---------|---------|---------|---------    ---------|---------|---------|---------  ---------|---------|---------|---------   
            IOL[1,2]  IOB_B[2,2]                      IOL[1,2]  IOB_LB[2,2]                                                               IOL[1,2]  IOB_B[2,2]       
    V[0,1]  IOL[1,1]  IOB_A[2,1]            V[0,1]    IOL[1,1]  IOB_LA[2,1]            V[0,1]                                   V[0,1]    IOL[1,1]  IOB_A[2,1]       
    G[0,0]  R[1,0]    I[2,0]                G[0,0]    R[1,0]    I[2,0]                 G[0,0]    R[1,0]    I[2,0]    DQS[3,0]   G[0,0]    R[1,0]    I[2,0]            
  ---------|---------|---------|---------   ---------|---------|---------|---------    ---------|---------|---------|---------  ---------|---------|---------|---------    
  
                TILE 0                                  TILE 1                                      TILE 2                                  TILE 3    

  Revision History:

*****************************************************************************************/
function draw_io_4cim_6io_dqs_h_tile_fp 
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    draw_io_tile_fp(tx, ty, num_tile_x, num_tile_y);
    draw_io_f_tile_fp(tx+1, ty, num_tile_x, num_tile_y);
    draw_dqs_tile_fp(tx+2, ty);
    draw_io_tile_fp(tx+3, ty, num_tile_x, num_tile_y);

}; // end of function draw_io_4cim_6io_dqs_h_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io_8cim_h tile fp]
  
  Revision History:

*****************************************************************************************/
function place_io_8cim_h_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y,    
    unsigned int blank_x0
)
{
   
    place_io_4cim_6io_ffttff_h_tile_fp(tx, ty, num_tile_x, num_tile_y);
    place_io_4cim_6io_dqs_h_tile_fp(tx+4, ty, num_tile_x, num_tile_y, blank_x0);  

}; // end of function place_io_8cim_h_tile_fp  


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_8cim_h tile fp]
  
  Revision History:

*****************************************************************************************/
function draw_io_8cim_h_tile_fp 
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    
    draw_io_4cim_6io_ffttff_h_tile_fp(tx, ty, num_tile_x, num_tile_y);
    draw_io_4cim_6io_dqs_h_tile_fp(tx+4, ty, num_tile_x, num_tile_y);  
    
}; // end of function draw_io_8cim_h_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io_dqs_tt_2cim_v tile fp]

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_B[2,2]        
    V[0,1]  IOL[1,1]  IOB_A[2,1]             TILE 0
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 1
    G[0,0]  R[1,0]    I[2,0]    DQS[3,0] 
  ---------|---------|---------|---------

  Revision History:

*****************************************************************************************/
function place_io_dqs_tt_2cim_v_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y,
    unsigned int blank_x0
)
{
    place_io_tile_fp(tx, ty, num_tile_x, num_tile_y);
    place_dqs_tile_fp(tx, ty - 1, blank_x0);

}; // end of function place_io_dqs_tt_2cim_v_tile_fp  


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_dqs_tt_2cim_v tile fp]
  
  ---------|---------|---------|---------    
            IOL[1,2]  IOB_B[2,2]        
    V[0,1]  IOL[1,1]  IOB_A[2,1]             TILE 0
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 1
    G[0,0]  R[1,0]    I[2,0]    DQS[3,0] 
  ---------|---------|---------|---------   

  Revision History:

*****************************************************************************************/
function draw_io_dqs_tt_2cim_v_tile_fp 
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    draw_io_tile_fp(tx, ty, num_tile_x, num_tile_y);
    draw_dqs_tile_fp(tx, ty - 1);

}; // end of function draw_io_dqs_tt_2cim_v_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io_dqs_ff_2cim_v tile fp]

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL[1,1]  IOB_LA[2,1]            TILE 0
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 1
    G[0,0]  R[1,0]    I[2,0]    DQS[3,0] 
  ---------|---------|---------|---------

  Revision History:

*****************************************************************************************/
function place_io_dqs_ff_2cim_v_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y,
    unsigned int blank_x0
)
{
    place_io_f_tile_fp(tx, ty, num_tile_x, num_tile_y);
    place_dqs_tile_fp(tx, ty - 1, blank_x0);

}; // end of function place_io_dqs_ff_2cim_v_tile_fp  

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_dqs_ff_2cim_v tile fp]
  
  ---------|---------|---------|---------    
            IOL[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL[1,1]  IOB_LA[2,1]            TILE 0
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 1
    G[0,0]  R[1,0]    I[2,0]    DQS[3,0] 
  ---------|---------|---------|---------   

  Revision History:

*****************************************************************************************/
function draw_io_dqs_ff_2cim_v_tile_fp 
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    draw_io_f_tile_fp(tx, ty, num_tile_x, num_tile_y);
    draw_dqs_tile_fp(tx, ty - 1);

}; // end of function draw_io_dqs_ff_2cim_v_tile_fp

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io_3cim_4io_v_u tile fp]

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_B[2,2]        
    V[0,1]  IOL[1,1]  IOB_A[2,1]             TILE 0
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 1
    G[0,0]  R[1,0]    I[2,0]     
  ---------|---------|---------|---------
  
  ---------|---------|---------|---------
            IOL[1,2]  IOB_LB[2,2]      
    V[0,1]  IOL[1,1]  IOB_LA[2,1]            TILE 2
    G[0,0]  R[1,0]    I[2,0]           
  ---------|---------|---------|---------

  Revision History:

*****************************************************************************************/
function place_io_3cim_4io_v_u_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    place_io_tile_fp(tx, ty, num_tile_x, num_tile_y);
    place_io_f_tile_fp(tx, ty - 2, num_tile_x, num_tile_y);

}; // end of function place_io_3cim_4io_v_u_tile_fp  


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_3cim_4io_v_u tile fp]
  
  ---------|---------|---------|---------    
            IOL[1,2]  IOB_B[2,2]        
    V[0,1]  IOL[1,1]  IOB_A[2,1]             TILE 0
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 1
    G[0,0]  R[1,0]    I[2,0]     
  ---------|---------|---------|---------
  
  ---------|---------|---------|---------
            IOL[1,2]  IOB_LB[2,2]      
    V[0,1]  IOL[1,1]  IOB_LA[2,1]            TILE 2
    G[0,0]  R[1,0]    I[2,0]           
  ---------|---------|---------|---------  

  Revision History:

*****************************************************************************************/
function draw_io_3cim_4io_v_u_tile_fp 
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    draw_io_tile_fp(tx, ty, num_tile_x, num_tile_y);
    draw_io_f_tile_fp(tx, ty - 2, num_tile_x, num_tile_y);

}; // end of function draw_io_3cim_4io_v_u_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io_4cim_6io_ttfftt_v tile fp]

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_B[2,2]        
    V[0,1]  IOL[1,1]  IOB_A[2,1]             TILE 0
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL[1,1]  IOB_LA[2,1]            TILE 1
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------    
  
  ---------|---------|---------|---------
                  
    V[0,1]                                   TILE 2
    G[0,0]  R[1,0]    I[2,0]           
  ---------|---------|---------|---------

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_B[2,2]        
    V[0,1]  IOL[1,1]  IOB_A[2,1]             TILE 3
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function place_io_4cim_6io_ttfftt_v_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    place_io_tile_fp(tx, ty, num_tile_x, num_tile_y);
    place_io_f_tile_fp(tx, ty - 1, num_tile_x, num_tile_y);
    place_io_tile_fp(tx, ty - 3, num_tile_x, num_tile_y);    

}; // end of function place_io_4cim_6io_ttfftt_v_tile_fp  


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_4cim_6io_ttfftt_v tile fp]
  
  ---------|---------|---------|---------    
            IOL[1,2]  IOB_B[2,2]        
    V[0,1]  IOL[1,1]  IOB_A[2,1]             TILE 0
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL[1,1]  IOB_LA[2,1]            TILE 1
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------    
  
  ---------|---------|---------|---------
                  
    V[0,1]                                   TILE 2
    G[0,0]  R[1,0]    I[2,0]           
  ---------|---------|---------|---------

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_B[2,2]        
    V[0,1]  IOL[1,1]  IOB_A[2,1]             TILE 3
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function draw_io_4cim_6io_ttfftt_v_tile_fp 
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    draw_io_tile_fp(tx, ty, num_tile_x, num_tile_y);
    draw_io_f_tile_fp(tx, ty - 1, num_tile_x, num_tile_y);
    draw_io_tile_fp(tx, ty - 3, num_tile_x, num_tile_y);    

}; // end of function draw_io_4cim_6io_ttfftt_v_tile_fp

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io_4cim_6io_ffttff_v tile fp]

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL[1,1]  IOB_LA[2,1]            TILE 0
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_B[2,2]        
    V[0,1]  IOL[1,1]  IOB_A[2,1]             TILE 1
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------    
  
  ---------|---------|---------|---------
                  
    V[0,1]                                   TILE 2
    G[0,0]  R[1,0]    I[2,0]           
  ---------|---------|---------|---------

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL[1,1]  IOB_LA[2,1]            TILE 3
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function place_io_4cim_6io_ffttff_v_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    place_io_f_tile_fp(tx, ty, num_tile_x, num_tile_y);
    place_io_tile_fp(tx, ty - 1, num_tile_x, num_tile_y);
    place_io_f_tile_fp(tx, ty - 3, num_tile_x, num_tile_y);    

}; // end of function place_io_4cim_6io_ffttff_v_tile_fp  


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_4cim_6io_ttfftt_v tile fp]
  
  ---------|---------|---------|---------    
            IOL[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL[1,1]  IOB_LA[2,1]            TILE 0
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_B[2,2]        
    V[0,1]  IOL[1,1]  IOB_A[2,1]             TILE 1
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------    
  
  ---------|---------|---------|---------
                  
    V[0,1]                                   TILE 2
    G[0,0]  R[1,0]    I[2,0]           
  ---------|---------|---------|---------

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL[1,1]  IOB_LA[2,1]             TILE 3
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function draw_io_4cim_6io_ffttff_v_tile_fp 
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    draw_io_f_tile_fp(tx, ty, num_tile_x, num_tile_y);
    draw_io_tile_fp(tx, ty - 1, num_tile_x, num_tile_y);
    draw_io_f_tile_fp(tx, ty - 3, num_tile_x, num_tile_y);    

}; // end of function draw_io_4cim_6io_ffttff_v_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io_3cim_4io_v_d tile fp]

  ---------|---------|---------|---------    
            IOL[1,2]  IOB_B[2,2]        
    V[0,1]  IOL[1,1]  IOB_A[2,1]             TILE 0
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------     
  
  ---------|---------|---------|---------
            IOL[1,2]  IOB_LB[2,2]      
    V[0,1]  IOL[1,1]  IOB_LA[2,1]            TILE 1
    G[0,0]  R[1,0]    I[2,0]           
  ---------|---------|---------|---------

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 2
    G[0,0]  R[1,0]    I[2,0]     
  ---------|---------|---------|---------

  Revision History:

*****************************************************************************************/
function place_io_3cim_4io_v_d_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    place_io_tile_fp(tx, ty, num_tile_x, num_tile_y);
    place_io_f_tile_fp(tx, ty - 1, num_tile_x, num_tile_y);   

}; // end of function place_io_3cim_4io_v_d_tile_fp  


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_3cim_4io_v_d tile fp]
  
  ---------|---------|---------|---------    
            IOL[1,2]  IOB_B[2,2]        
    V[0,1]  IOL[1,1]  IOB_A[2,1]             TILE 0
    G[0,0]  R[1,0]    I[2,0]             
  ---------|---------|---------|---------     
  
  ---------|---------|---------|---------
            IOL[1,2]  IOB_LB[2,2]      
    V[0,1]  IOL[1,1]  IOB_LA[2,1]             TILE 1
    G[0,0]  R[1,0]    I[2,0]           
  ---------|---------|---------|---------

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 2
    G[0,0]  R[1,0]    I[2,0]     
  ---------|---------|---------|---------

  Revision History:

*****************************************************************************************/
function draw_io_3cim_4io_v_d_tile_fp 
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    draw_io_tile_fp(tx, ty, num_tile_x, num_tile_y);
    draw_io_f_tile_fp(tx, ty - 1, num_tile_x, num_tile_y);  

}; // end of function draw_io_3cim_4io_v_d_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io_9cim_v_u tile fp]

  Revision History:

*****************************************************************************************/
function place_io_9cim_v_u_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y,
    unsigned int blank_x0
)
{
    place_io_3cim_4io_v_u_tile_fp(tx, ty, num_tile_x, num_tile_y);
    place_io_dqs_tt_2cim_v_tile_fp(tx, ty - 3, num_tile_x, num_tile_y, blank_x0);
    place_io_4cim_6io_ffttff_v_tile_fp(tx, ty - 5, num_tile_x, num_tile_y);  

}; // end of function place_io_9cim_v_u_tile_fp  


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_9cim_v_u tile fp]

  Revision History:

*****************************************************************************************/
function draw_io_9cim_v_u_tile_fp 
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    draw_io_3cim_4io_v_u_tile_fp(tx, ty, num_tile_x, num_tile_y);
    draw_io_dqs_tt_2cim_v_tile_fp(tx, ty - 3, num_tile_x, num_tile_y);
    draw_io_4cim_6io_ffttff_v_tile_fp(tx, ty - 5, num_tile_x, num_tile_y);

}; // end of function draw_io_9cim_v_u_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io_9cim_v_d tile fp]

  Revision History:

*****************************************************************************************/
function place_io_9cim_v_d_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y,
    unsigned int blank_x0
)
{
    place_io_4cim_6io_ttfftt_v_tile_fp(tx, ty, num_tile_x, num_tile_y);
    place_io_dqs_ff_2cim_v_tile_fp(tx, ty - 4, num_tile_x, num_tile_y, blank_x0);
    place_io_3cim_4io_v_d_tile_fp(tx, ty - 6, num_tile_x, num_tile_y);  

}; // end of function place_io_9cim_v_d_tile_fp  


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_9cim_v_d tile fp]

  Revision History:

*****************************************************************************************/
function draw_io_9cim_v_d_tile_fp 
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y
)
{
    draw_io_4cim_6io_ttfftt_v_tile_fp(tx, ty, num_tile_x, num_tile_y);
    draw_io_dqs_ff_2cim_v_tile_fp(tx, ty - 4, num_tile_x, num_tile_y);
    draw_io_3cim_4io_v_d_tile_fp(tx, ty - 6, num_tile_x, num_tile_y);

}; // end of function draw_io_9cim_v_d_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io_10cim_v tile fp]

  Revision History:

*****************************************************************************************/
function place_io_10cim_v_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y,
    unsigned int false_true_flag,
    unsigned int blank_x0
)
{
   if(false_true_flag == 0)
   {
        place_io_4cim_6io_ttfftt_v_tile_fp(tx, ty, num_tile_x, num_tile_y);
        place_io_dqs_ff_2cim_v_tile_fp(tx, ty - 4, num_tile_x, num_tile_y, blank_x0);
        place_io_4cim_6io_ttfftt_v_tile_fp(tx, ty - 6, num_tile_x, num_tile_y);        
   }    
   else
   {
        place_io_4cim_6io_ffttff_v_tile_fp(tx, ty, num_tile_x, num_tile_y);
        place_io_dqs_tt_2cim_v_tile_fp(tx, ty - 4, num_tile_x, num_tile_y, blank_x0);
        place_io_4cim_6io_ffttff_v_tile_fp(tx, ty - 6, num_tile_x, num_tile_y);    
   } 

}; // end of function place_io_10cim_v_tile_fp  

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_10cim_v tile fp]

  Revision History:

*****************************************************************************************/
function draw_io_10cim_v_tile_fp 
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y,
    unsigned int false_true_flag     
)
{
   if(false_true_flag == 0)
   {
        draw_io_4cim_6io_ttfftt_v_tile_fp(tx, ty, num_tile_x, num_tile_y);
        draw_io_dqs_ff_2cim_v_tile_fp(tx, ty - 4, num_tile_x, num_tile_y);
        draw_io_4cim_6io_ttfftt_v_tile_fp(tx, ty - 6, num_tile_x, num_tile_y);        
   }    
   else
   {
        draw_io_4cim_6io_ffttff_v_tile_fp(tx, ty, num_tile_x, num_tile_y);
        draw_io_dqs_tt_2cim_v_tile_fp(tx, ty - 4, num_tile_x, num_tile_y);
        draw_io_4cim_6io_ffttff_v_tile_fp(tx, ty - 6, num_tile_x, num_tile_y);    
   } 

}; // end of function draw_io_10cim_v_tile_fp

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io_l_3cim_4io_v_u tile fp]

  ---------|---------|---------|---------    
            IOL_L[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 0
    G[0,0]  R[1,0]      I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 1
    G[0,0]  R[1,0]      I[2,0]     
  ---------|---------|---------|---------
  
  ---------|---------|---------|---------
            IOL_L[1,2]  IOB_LB[2,2]      
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 2
    G[0,0]  R[1,0]      I[2,0]           
  ---------|---------|---------|---------
  
  Revision History:

*****************************************************************************************/
function place_io_l_3cim_4io_v_u_tile_fp
( 
    unsigned int tx,
    unsigned int ty
)    
{
    place_io_l_tile_fp(tx , ty);
    place_io_l_tile_fp(tx , ty - 2);  

}; // end of function place_io_l_3cim_4io_v_u_tile_fp  


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_l_3cim_4io_v_u tile fp]
  
  ---------|---------|---------|---------    
            IOL_L[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 0
    G[0,0]  R[1,0]      I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 1
    G[0,0]  R[1,0]      I[2,0]     
  ---------|---------|---------|---------
  
  ---------|---------|---------|---------
            IOL_L[1,2]  IOB_LB[2,2]      
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 2
    G[0,0]  R[1,0]      I[2,0]           
  ---------|---------|---------|---------

  Revision History:

*****************************************************************************************/
function draw_io_l_3cim_4io_v_u_tile_fp 
( 
    unsigned int tx,
    unsigned int ty
)
{
    draw_io_l_tile_fp(tx , ty);
    draw_io_l_tile_fp(tx , ty - 2); 

}; // end of function draw_io_l_3cim_4io_v_u_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io_l_4cim_6io_v tile fp]

  ---------|---------|---------|---------    
            IOL_L[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 0
    G[0,0]  R[1,0]      I[2,0]             
  ---------|---------|---------|---------   
  
  ---------|---------|---------|---------    
            IOL_L[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 1
    G[0,0]  R[1,0]      I[2,0]             
  ---------|---------|---------|---------       

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 2
    G[0,0]  R[1,0]      I[2,0]     
  ---------|---------|---------|---------
  
  ---------|---------|---------|---------
            IOL_L[1,2]  IOB_LB[2,2]      
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 3
    G[0,0]  R[1,0]      I[2,0]           
  ---------|---------|---------|---------
  
  Revision History:

*****************************************************************************************/
function place_io_l_4cim_6io_v_tile_fp
( 
    unsigned int tx,
    unsigned int ty
)
{
    place_io_l_tile_fp(tx , ty);
    place_io_l_tile_fp(tx , ty - 1);    
    place_io_l_tile_fp(tx , ty - 3);  

}; // end of function place_io_l_4cim_6io_v_tile_fp  


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_l_4cim_6io_v tile fp]
  
  ---------|---------|---------|---------    
            IOL_L[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 0
    G[0,0]  R[1,0]      I[2,0]             
  ---------|---------|---------|---------   
  
  ---------|---------|---------|---------    
            IOL_L[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 1
    G[0,0]  R[1,0]      I[2,0]             
  ---------|---------|---------|---------       

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 2
    G[0,0]  R[1,0]      I[2,0]     
  ---------|---------|---------|---------
  
  ---------|---------|---------|---------
            IOL_L[1,2]  IOB_LB[2,2]      
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 3
    G[0,0]  R[1,0]      I[2,0]           
  ---------|---------|---------|---------

  Revision History:

*****************************************************************************************/
function draw_io_l_4cim_6io_v_tile_fp 
( 
    unsigned int tx,
    unsigned int ty
)
{
    draw_io_l_tile_fp(tx , ty);
    draw_io_l_tile_fp(tx , ty - 1);    
    draw_io_l_tile_fp(tx , ty - 3); 

}; // end of function draw_io_l_4cim_6io_v_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place io_l_3cim_4io_v_d tile fp]

  ---------|---------|---------|---------    
            IOL_L[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 0
    G[0,0]  R[1,0]      I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------
            IOL_L[1,2]  IOB_LB[2,2]      
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 1
    G[0,0]  R[1,0]      I[2,0]           
  ---------|---------|---------|---------

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 2
    G[0,0]  R[1,0]      I[2,0]     
  ---------|---------|---------|---------
  
  Revision History:

*****************************************************************************************/
function place_io_l_3cim_4io_v_d_tile_fp
( 
    unsigned int tx,
    unsigned int ty
)
{
    place_io_l_tile_fp(tx , ty);
    place_io_l_tile_fp(tx , ty - 1);  

}; // end of function place_io_l_3cim_4io_v_d_tile_fp  


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_l_3cim_4io_v_d tile fp]
  
  ---------|---------|---------|---------    
            IOL_L[1,2]  IOB_LB[2,2]        
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 0
    G[0,0]  R[1,0]      I[2,0]             
  ---------|---------|---------|---------     

  ---------|---------|---------|---------
            IOL_L[1,2]  IOB_LB[2,2]      
    V[0,1]  IOL_L[1,1]  IOB_LA[2,1]          TILE 1
    G[0,0]  R[1,0]      I[2,0]           
  ---------|---------|---------|---------

  ---------|---------|---------|---------
                                         
    V[0,1]                                   TILE 2
    G[0,0]  R[1,0]      I[2,0]     
  ---------|---------|---------|---------

  Revision History:

*****************************************************************************************/
function draw_io_l_3cim_4io_v_d_tile_fp 
( 
    unsigned int tx,
    unsigned int ty
)
{
    draw_io_l_tile_fp(tx , ty);
    draw_io_l_tile_fp(tx , ty - 1); 

}; // end of function draw_io_l_3cim_4io_v_d_tile_fp

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [place io_l_b_2cim_v tile fp]

  ---------|---------|---------|--------- 
            IOL_L[1,2]  IOB_LB[2,2] C[3,2]                           
    V[0,1]  
    G[0,0]  R[1,0]      I[2,0]       
  ---------|---------|---------|--------- 
  
 
  Revision History:

*****************************************************************************************/
function place_io_l_b_2cim_v_tile_fp
( 
    unsigned int tx,
    unsigned int ty
)
{
    
    place_io_l_1b_tile_fp(tx , ty);
      
};// end of function place_io_l_b_2cim_v_tile_fp

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw io_l_b_2cim_v tile fp]

  ---------|---------|---------|--------- 
            IOL_L[1,2]  IOB_LB[2,2] C[3,2]                           
    V[0,1]  
    G[0,0]  R[1,0]      I[2,0]       
  ---------|---------|---------|--------- 
  
 
  Revision History:

*****************************************************************************************/
function draw_io_l_b_2cim_v_tile_fp
( 
    unsigned int tx,
    unsigned int ty
)
{
    
    draw_io_l_1b_tile_fp(tx , ty);
      
};// end of function draw_io_l_b_2cim_v_tile_fp

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place uscm tile fp]

  ------------|---------------|---------------|-------------   

    USCM[0,1]      USCM[1,1]       USCM[2,1]       
    USCM[0,0]      USCM[1,0]       USCM[2,0]        USCM[3,0]
  ------------|---------------|---------------|------------- 
  Revision History:

*****************************************************************************************/
function place_uscm_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int uscm_idx,
    unsigned int tile_num    
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx, lsy, fsy;

    // device reference variables
    &device s0Ref,s1Ref,s2Ref,s3Ref,s4Ref,s5Ref,s6Ref;
    &device s0fl,s1fl,s2fl,s3fl,s4fl,s5fl,s6fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    fsx = lsx / 2 - 1;
    fsy = lsy / 3;

    // Pull out the device instances from logic structure
    s0Ref = <device USCM @[lsx,lsy]       of ARCHITECTURE>;
    s1Ref = <device USCM @[lsx+1,lsy]     of ARCHITECTURE>;
    s2Ref = <device USCM @[lsx+2,lsy]     of ARCHITECTURE>;
    s3Ref = <device USCM @[lsx+3,lsy]     of ARCHITECTURE>;    
                                         
    s4Ref = <device USCM @[lsx,lsy+1]     of ARCHITECTURE>;
    s5Ref = <device USCM @[lsx+1,lsy+1]   of ARCHITECTURE>;
    s6Ref = <device USCM @[lsx+2,lsy+1]   of ARCHITECTURE>;     
               
    // Instantiate the device. 
    sprintf(strVar, "USCM%d_%d", uscm_idx, 0+7*tile_num);
    s0fl = device USCM  *strVar @[fsx,fsy];

    sprintf(strVar, "USCM%d_%d", uscm_idx, 1+7*tile_num);
    s1fl = device USCM  *strVar @[fsx,fsy];

    sprintf(strVar, "USCM%d_%d", uscm_idx, 2+7*tile_num);
    s2fl = device USCM  *strVar @[fsx,fsy];

    sprintf(strVar, "USCM%d_%d", uscm_idx, 3+7*tile_num);
    s3fl = device USCM  *strVar @[fsx,fsy];

    sprintf(strVar, "USCM%d_%d", uscm_idx, 4+7*tile_num);
    s4fl = device USCM  *strVar @[fsx,fsy];

    sprintf(strVar, "USCM%d_%d", uscm_idx, 5+7*tile_num);
    s5fl = device USCM  *strVar @[fsx,fsy];

    sprintf(strVar, "USCM%d_%d", uscm_idx, 6+7*tile_num);
    s6fl = device USCM  *strVar @[fsx,fsy];


    map ( 
            s0fl => s0Ref,
            s1fl => s1Ref, 
            s2fl => s2Ref,
            s3fl => s3Ref, 
            s4fl => s4Ref,
            s5fl => s5Ref, 
            s6fl => s6Ref                  
          );


}; // end of function place_uscm_tile_fp  



/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw uscm_w tile fp]
  
  ------------|---------------|---------------|-------------   

    USCM[0,1]      USCM[1,1]       USCM[2,1]       
    USCM[0,0]      USCM[1,0]       USCM[2,0]        USCM[3,0]
  ------------|---------------|---------------|-------------   

  Revision History:

*****************************************************************************************/
function draw_uscm_w_tile_fp 
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int uscm_idx,
    unsigned int tile_num      
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref, s1Ref, s2Ref, s3Ref, s4Ref, s5Ref, s6Ref;
    &symbol s0schm, s1schm, s2schm, s3schm, s4schm, s5schm, s6schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "USCM%d_%d", uscm_idx, 0+7*tile_num);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device USCM ( symbol fpsym ) *strVar @[gsx,gsy-80];

    sprintf(strVar, "USCM%d_%d", uscm_idx, 1+7*tile_num);
    s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s1schm = device USCM ( symbol fpsym ) *strVar @[gsx,gsy-40];

    sprintf(strVar, "USCM%d_%d", uscm_idx, 2+7*tile_num);
    s2Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s2schm = device USCM ( symbol fpsym ) *strVar @[gsx,gsy];

    sprintf(strVar, "USCM%d_%d", uscm_idx, 3+7*tile_num);
    s3Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s3schm = device USCM ( symbol fpsym ) *strVar @[gsx,gsy+40];

    sprintf(strVar, "USCM%d_%d", uscm_idx, 4+7*tile_num);
    s4Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s4schm = device USCM ( symbol fpsym ) *strVar @[gsx,gsy+80];

    sprintf(strVar, "USCM%d_%d", uscm_idx, 5+7*tile_num);
    s5Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s5schm = device USCM ( symbol fpsym ) *strVar @[gsx,gsy+120];

    sprintf(strVar, "USCM%d_%d", uscm_idx, 6+7*tile_num);
    s6Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s6schm = device USCM ( symbol fpsym ) *strVar @[gsx,gsy+160];

   
    
    map ( 
            s0schm => s0Ref, 
            s1schm => s1Ref,
            s2schm => s2Ref, 
            s3schm => s3Ref,
            s4schm => s4Ref, 
            s5schm => s5Ref,
            s6schm => s6Ref                 
         );


}; // end of function draw_uscm_w_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw uscm_e tile fp]
  
  ------------|---------------|---------------|-------------   

    USCM[0,1]      USCM[1,1]       USCM[2,1]       
    USCM[0,0]      USCM[1,0]       USCM[2,0]        USCM[3,0]
  ------------|---------------|---------------|-------------   

  Revision History:

*****************************************************************************************/
function draw_uscm_e_tile_fp 
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int uscm_idx,
    unsigned int tile_num     
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref, s1Ref, s2Ref, s3Ref, d0Ref, d1Ref, d2Ref;
    &symbol s0schm, s1schm, s2schm, s3schm, d0schm, d1schm, d2schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "USCM%d_%d", uscm_idx, 0+7*tile_num);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device USCM ( symbol fpsym ) *strVar @[gsx+200,gsy+560];

    sprintf(strVar, "USCM%d_%d", uscm_idx, 1+7*tile_num);
    s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s1schm = device USCM ( symbol fpsym ) *strVar @[gsx+200,gsy+600];

    sprintf(strVar, "USCM%d_%d", uscm_idx, 2+7*tile_num);
    s2Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s2schm = device USCM ( symbol fpsym ) *strVar @[gsx+200,gsy+640];

    sprintf(strVar, "USCM%d_%d", uscm_idx, 3+7*tile_num);
    s3Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s3schm = device USCM ( symbol fpsym ) *strVar @[gsx+200,gsy+680];

    sprintf(strVar, "USCM%d_%d", uscm_idx, 4+7*tile_num);
    d0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d0schm = device USCM ( symbol fpsym ) *strVar @[gsx+200,gsy+720];

    sprintf(strVar, "USCM%d_%d", uscm_idx, 5+7*tile_num);
    d1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d1schm = device USCM ( symbol fpsym ) *strVar @[gsx+200,gsy+760];

    sprintf(strVar, "USCM%d_%d", uscm_idx, 6+7*tile_num);
    d2Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d2schm = device USCM ( symbol fpsym ) *strVar @[gsx+200,gsy+800];

   
    
    map ( 
            s0schm => s0Ref, 
            s1schm => s1Ref,
            s2schm => s2Ref, 
            s3schm => s3Ref,
            d0schm => d0Ref, 
            d1schm => d1Ref,
            d2schm => d2Ref                 
         );


}; // end of function draw_uscm_e_tile_fp

/**VFunction******************************************************************************

  Author    [xiawei]

  Abstract  [This function places the devices within REGIONAL_V_CLKMUX block tiles. Each REGIONAL_V_CLKMUX block takes
             the size of 1 tiles. 
             
     
              ---------|---------|---------|---------   
                                            RCLK_BUF1[3,2]
                                            RCLK_BUF0[3,1]
                                            REG_VMUX[3,0]
              ---------|---------|---------|---------  
              
            ]

  Revision History:

*****************************************************************************************/
function place_reg_vmux_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int BLANK_X0
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, fsx, fsy;

    // device reference variables
    &device g0Ref, g1Ref;        
    &device s0fl,s1fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    fsx = lsx / 2 + 2;
    fsy = lsy / 3 + 1;
    
    if( fsx > ( ( BLANK_X0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx = fsx - 2;          
    }       
    
    if( fsy <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy = fsy;   
    }    
    else if( fsy <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 1;        
    }
    else if( fsy <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 2;        
    }
    else if( fsy <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 3;        
    }
    else 
    {
         fsy = fsy - 4;         
    }            

    // Pull out the device instances from logic structure
    g0Ref  = <device RCLK_BUF  @[lsx+3,lsy+1]    of ARCHITECTURE>;
    g1Ref  = <device RCLK_BUF  @[lsx+3,lsy+2]    of ARCHITECTURE>;
   
    // Instantiate the device. 
    sprintf(strVar, "RCLK_BUF_%d_%d", lsx+3,lsy+1);
    s0fl = device RCLK_BUF  *strVar @[fsx,fsy];

    sprintf(strVar, "RCLK_BUF_%d_%d", lsx+3,lsy+2);
    s1fl = device RCLK_BUF  *strVar @[fsx,fsy];

    map ( 
             s0fl => g0Ref ,
             s1fl => g1Ref
          );
    
}; // end of function place_reg_vmux_tile_fp  

/**VFunction******************************************************************************

  Author    [xiawei]

  Abstract  [Draw reg_vmux_w tile]
  
  ---------|---------|---------|---------   
                                RCLK_BUF1[3,2]
                                RCLK_BUF0[3,1]
                                REG_VMUX[3,0]
  ---------|---------|---------|---------    

  Revision History:

*****************************************************************************************/
function draw_reg_vmux_w_tile_fp
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;

    // device reference variables
    &device s0Ref, s1Ref;
    &symbol s0schm, s1schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "RCLK_BUF_%d_%d", lsx+3,lsy+1);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device RCLK_BUF ( symbol fpsym ) *strVar @[gsx+30,gsy+80];

    sprintf(strVar, "RCLK_BUF_%d_%d", lsx+3,lsy+2);
    s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s1schm = device RCLK_BUF ( symbol fpsym ) *strVar @[gsx+30,gsy+240];
    
    map ( 
            s0schm => s0Ref, 
            s1schm => s1Ref                       
         );

}; // end of function draw_reg_vmux_w_tile_fp

/**VFunction******************************************************************************

  Author    [xiawei]

  Abstract  [Draw reg_vmux_e tile]
  
  ---------|---------|---------|---------   
                                RCLK_BUF1[3,2]
                                RCLK_BUF0[3,1]
                                REG_VMUX[3,0]
  ---------|---------|---------|---------    
  

  Revision History:

*****************************************************************************************/
function draw_reg_vmux_e_tile_fp
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;

    // device reference variables
    &device s0Ref, s1Ref;
    &symbol s0schm, s1schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "RCLK_BUF_%d_%d", lsx+3,lsy+1);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device RCLK_BUF ( symbol fpsym ) *strVar @[gsx+30,gsy+80];

    sprintf(strVar, "RCLK_BUF_%d_%d", lsx+3,lsy+2);
    s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s1schm = device RCLK_BUF ( symbol fpsym ) *strVar @[gsx+30,gsy+240];
    
    map ( 
            s0schm => s0Ref, 
            s1schm => s1Ref                       
         );

}; // end of function draw_reg_vmux_e_tile_fp

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place ioclkgen_tile fp]

  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
  IOCLKGATE4[0,2]  IOCLKGATE5[1,2]  IOCLKGATE6[2,2]  IOCLKGATE7[3,2]      
  IOCLKGATE0[0,1]  IOCLKGATE1[1,1]  IOCLKGATE2[2,1]  IOCLKGATE3[3,1]   USCMMUX2TO1[0,1] USCMMUX2TO1[1,1] USCMMUX2TO1[2,1] USCMMUX2TO1[3,1]
                   IOCLKMUX[1,0]                                       IOCLKDIV[0,0]   IOCLKDIV[1,0]   IOCLKDIV[2,0]   IOCLKDIV[3,0]
  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
                                      Tile 0                                                               Tile 1
  Revision History:

*****************************************************************************************/
function place_ioclkgen_r_tile_fp
( 
    unsigned int tx,
    unsigned int ty
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsx1, fsx, lsy, fsy;

    // device reference variables
    &device xRef, g0Ref, g1Ref, g2Ref, g3Ref, g4Ref, g5Ref, g6Ref, g7Ref, d0Ref, d1Ref, d2Ref, d3Ref;     
   
    &device s0fl,s1fl,s2fl,s3fl,s4fl,s5fl,s6fl,s7fl,h0fl,h1fl,h2fl,h3fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsx1 = (tx+1) * TILE_NUM_SITE_X;    
    lsy = ty * TILE_NUM_SITE_Y;
    fsx = lsx / 2 - 1;
    fsy = lsy / 3;

    // Pull out the device instances from logic structure
    g0Ref  = <device IOCLKGATE  @[lsx,lsy+1]      of ARCHITECTURE>;
    g1Ref  = <device IOCLKGATE  @[lsx+1,lsy+1]    of ARCHITECTURE>;
    g2Ref  = <device IOCLKGATE  @[lsx+2,lsy+1]    of ARCHITECTURE>;
    g3Ref  = <device IOCLKGATE  @[lsx+3,lsy+1]    of ARCHITECTURE>;
    g4Ref  = <device IOCLKGATE  @[lsx,lsy+2]      of ARCHITECTURE>;
    g5Ref  = <device IOCLKGATE  @[lsx+1,lsy+2]    of ARCHITECTURE>;
    g6Ref  = <device IOCLKGATE  @[lsx+2,lsy+2]    of ARCHITECTURE>;
    g7Ref  = <device IOCLKGATE  @[lsx+3,lsy+2]    of ARCHITECTURE>;    
    
    d0Ref  = <device IOCLKDIV   @[lsx1,lsy]       of ARCHITECTURE>;
    d1Ref  = <device IOCLKDIV   @[lsx1+1,lsy]     of ARCHITECTURE>;
    d2Ref  = <device IOCLKDIV   @[lsx1+2,lsy]     of ARCHITECTURE>;
    d3Ref  = <device IOCLKDIV   @[lsx1+3,lsy]     of ARCHITECTURE>;
                                                                          
    // Instantiate the device. 
    sprintf(strVar, "IOCLKGATE_%d_%d", lsx, lsy+1);
    s0fl = device IOCLKGATE  *strVar @[fsx,fsy];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+1, lsy+1);
    s1fl = device IOCLKGATE  *strVar @[fsx,fsy];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+2, lsy+1);
    s2fl = device IOCLKGATE  *strVar @[fsx,fsy];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+3, lsy+1);
    s3fl = device IOCLKGATE  *strVar @[fsx,fsy];

    sprintf(strVar, "BRGCLKGATE_%d_%d", lsx, lsy+2);
    s4fl = device IOCLKGATE  *strVar @[fsx,fsy];

    sprintf(strVar, "BRGCLKGATE_%d_%d", lsx+1, lsy+2);
    s5fl = device IOCLKGATE  *strVar @[fsx,fsy];

    sprintf(strVar, "BRGCLKGATE_%d_%d", lsx+2, lsy+2);
    s6fl = device IOCLKGATE  *strVar @[fsx,fsy];

    sprintf(strVar, "BRGCLKGATE_%d_%d", lsx+3, lsy+2);
    s7fl = device IOCLKGATE  *strVar @[fsx,fsy];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1, lsy);
    h0fl = device IOCLKDIV  *strVar @[fsx,fsy];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+1, lsy);
    h1fl = device IOCLKDIV  *strVar @[fsx,fsy];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+2, lsy);
    h2fl = device IOCLKDIV  *strVar @[fsx,fsy];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+3, lsy);
    h3fl = device IOCLKDIV  *strVar @[fsx,fsy];


    map ( 
             s0fl => g0Ref ,
             s1fl => g1Ref ,
             s2fl => g2Ref ,
             s3fl => g3Ref ,
             s4fl => g4Ref ,
             s5fl => g5Ref ,
             s6fl => g6Ref ,
             s7fl => g7Ref , 
             h0fl => d0Ref ,
             h1fl => d1Ref ,
             h2fl => d2Ref ,
             h3fl => d3Ref 
                                    
          );


}; // end of function place_ioclkgen_r_tile_fp  

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place ioclkgen_tile fp]

  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
  IOCLKGATE4[0,2]  IOCLKGATE5[1,2]        
  IOCLKGATE0[0,1]  IOCLKGATE1[1,1]  IOCLKGATE2[2,1]  IOCLKGATE3[3,1]   USCMMUX2TO1[0,1] USCMMUX2TO1[1,1] USCMMUX2TO1[2,1] USCMMUX2TO1[3,1]
                   IOCLKMUX[1,0]                                       IOCLKDIV[0,0]   IOCLKDIV[1,0]   IOCLKDIV[2,0]   IOCLKDIV[3,0]
  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
                                      Tile 0                                                               Tile 1
  Revision History:

*****************************************************************************************/
function place_ioclkgen_tb_tile_fp
( 
    unsigned int tx,
    unsigned int ty
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsx1, fsx, lsy, fsy;

    // device reference variables
    &device xRef, g0Ref, g1Ref, g2Ref, g3Ref, g4Ref, g5Ref, d0Ref, d1Ref, d2Ref, d3Ref;     
   
    &device s0fl,s1fl,s2fl,s3fl,s4fl,s5fl,s6fl,s7fl,h0fl,h1fl,h2fl,h3fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsx1 = (tx+1) * TILE_NUM_SITE_X;    
    lsy = ty * TILE_NUM_SITE_Y;
    fsx = lsx / 2 - 1;
    fsy = lsy / 3;

    // Pull out the device instances from logic structure
    g0Ref  = <device IOCLKGATE  @[lsx,lsy+1]      of ARCHITECTURE>;
    g1Ref  = <device IOCLKGATE  @[lsx+1,lsy+1]    of ARCHITECTURE>;
    g2Ref  = <device IOCLKGATE  @[lsx+2,lsy+1]    of ARCHITECTURE>;
    g3Ref  = <device IOCLKGATE  @[lsx+3,lsy+1]    of ARCHITECTURE>;
    g4Ref  = <device IOCLKGATE  @[lsx,lsy+2]      of ARCHITECTURE>;
    g5Ref  = <device IOCLKGATE  @[lsx+1,lsy+2]    of ARCHITECTURE>;      
    
    d0Ref  = <device IOCLKDIV   @[lsx1,lsy]       of ARCHITECTURE>;
    d1Ref  = <device IOCLKDIV   @[lsx1+1,lsy]     of ARCHITECTURE>;
    d2Ref  = <device IOCLKDIV   @[lsx1+2,lsy]     of ARCHITECTURE>;
    d3Ref  = <device IOCLKDIV   @[lsx1+3,lsy]     of ARCHITECTURE>;
                                                                          
    // Instantiate the device. 
    sprintf(strVar, "IOCLKGATE_%d_%d", lsx, lsy+1);
    s0fl = device IOCLKGATE  *strVar @[fsx,fsy];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+1, lsy+1);
    s1fl = device IOCLKGATE  *strVar @[fsx,fsy];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+2, lsy+1);
    s2fl = device IOCLKGATE  *strVar @[fsx,fsy];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+3, lsy+1);
    s3fl = device IOCLKGATE  *strVar @[fsx,fsy];

    sprintf(strVar, "BRGCLKGATE_%d_%d", lsx, lsy+2);
    s4fl = device IOCLKGATE  *strVar @[fsx,fsy];

    sprintf(strVar, "BRGCLKGATE_%d_%d", lsx+1, lsy+2);
    s5fl = device IOCLKGATE  *strVar @[fsx,fsy];    

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1, lsy);
    h0fl = device IOCLKDIV  *strVar @[fsx,fsy];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+1, lsy);
    h1fl = device IOCLKDIV  *strVar @[fsx,fsy];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+2, lsy);
    h2fl = device IOCLKDIV  *strVar @[fsx,fsy];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+3, lsy);
    h3fl = device IOCLKDIV  *strVar @[fsx,fsy];


    map ( 
             s0fl => g0Ref ,
             s1fl => g1Ref ,
             s2fl => g2Ref ,
             s3fl => g3Ref ,
             s4fl => g4Ref ,
             s5fl => g5Ref ,            
             h0fl => d0Ref ,
             h1fl => d1Ref ,
             h2fl => d2Ref ,
             h3fl => d3Ref 
                                    
          );


}; // end of function place_ioclkgen_tb_tile_fp  

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place ioclkgen_tile fp]

  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
        
  IOCLKGATE0[0,1]  IOCLKGATE1[1,1]  IOCLKGATE2[2,1]  IOCLKGATE3[3,1]   USCMMUX2TO1[0,1] USCMMUX2TO1[1,1] USCMMUX2TO1[2,1] USCMMUX2TO1[3,1]
                   IOCLKMUX[1,0]                                       IOCLKDIV[0,0]   IOCLKDIV[1,0]   IOCLKDIV[2,0]   IOCLKDIV[3,0]
  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
                                      Tile 0                                                               Tile 1
  Revision History:

*****************************************************************************************/
function place_ioclkgen_l_tile_fp
( 
    unsigned int tx,
    unsigned int ty
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsx1, fsx, lsy, fsy;

    // device reference variables
    &device xRef, g0Ref, g1Ref, g2Ref, g3Ref, d0Ref, d1Ref, d2Ref, d3Ref;     
   
    &device s0fl,s1fl,s2fl,s3fl,s4fl,s5fl,s6fl,s7fl,h0fl,h1fl,h2fl,h3fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsx1 = (tx+1) * TILE_NUM_SITE_X;    
    lsy = ty * TILE_NUM_SITE_Y;
    fsx = lsx / 2 - 1;
    fsy = lsy / 3;

    // Pull out the device instances from logic structure
    g0Ref  = <device IOCLKGATE  @[lsx,lsy+1]      of ARCHITECTURE>;
    g1Ref  = <device IOCLKGATE  @[lsx+1,lsy+1]    of ARCHITECTURE>;
    g2Ref  = <device IOCLKGATE  @[lsx+2,lsy+1]    of ARCHITECTURE>;
    g3Ref  = <device IOCLKGATE  @[lsx+3,lsy+1]    of ARCHITECTURE>;       
    
    d0Ref  = <device IOCLKDIV   @[lsx1,lsy]       of ARCHITECTURE>;
    d1Ref  = <device IOCLKDIV   @[lsx1+1,lsy]     of ARCHITECTURE>;
    d2Ref  = <device IOCLKDIV   @[lsx1+2,lsy]     of ARCHITECTURE>;
    d3Ref  = <device IOCLKDIV   @[lsx1+3,lsy]     of ARCHITECTURE>;
                                                                          
    // Instantiate the device. 
    sprintf(strVar, "IOCLKGATE_%d_%d", lsx, lsy+1);
    s0fl = device IOCLKGATE  *strVar @[fsx,fsy];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+1, lsy+1);
    s1fl = device IOCLKGATE  *strVar @[fsx,fsy];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+2, lsy+1);
    s2fl = device IOCLKGATE  *strVar @[fsx,fsy];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+3, lsy+1);
    s3fl = device IOCLKGATE  *strVar @[fsx,fsy];    

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1, lsy);
    h0fl = device IOCLKDIV  *strVar @[fsx,fsy];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+1, lsy);
    h1fl = device IOCLKDIV  *strVar @[fsx,fsy];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+2, lsy);
    h2fl = device IOCLKDIV  *strVar @[fsx,fsy];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+3, lsy);
    h3fl = device IOCLKDIV  *strVar @[fsx,fsy];


    map ( 
             s0fl => g0Ref ,
             s1fl => g1Ref ,
             s2fl => g2Ref ,
             s3fl => g3Ref ,             
             h0fl => d0Ref ,
             h1fl => d1Ref ,
             h2fl => d2Ref ,
             h3fl => d3Ref 
                                    
          );


}; // end of function place_ioclkgen_l_tile_fp  

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw ioclkgen_b tile fp]
  
  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
  IOCLKGATE4[0,2]  IOCLKGATE5[1,2]        
  IOCLKGATE0[0,1]  IOCLKGATE1[1,1]  IOCLKGATE2[2,1]  IOCLKGATE3[3,1]   USCMMUX2TO1[0,1] USCMMUX2TO1[1,1] USCMMUX2TO1[2,1] USCMMUX2TO1[3,1]
                   IOCLKMUX[1,0]                                       IOCLKDIV[0,0]   IOCLKDIV[1,0]   IOCLKDIV[2,0]   IOCLKDIV[3,0]
  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
                                      Tile 0                                                               Tile 1 

  Revision History:

*****************************************************************************************/
function draw_ioclkgen_b_tile_fp 
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsx1, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref, s1Ref, s2Ref, s3Ref, s4Ref, s5Ref, d0Ref, d1Ref, d2Ref, d3Ref;
    &symbol s0schm, s1schm, s2schm, s3schm, s4schm, s5schm, s6schm, s7schm, d0schm, d1schm, d2schm, d3schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsx1 = (tx+1) * TILE_NUM_SITE_X;   
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "IOCLKGATE_%d_%d", lsx, lsy+1);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx,gsy+400];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+1, lsy+1);
    s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s1schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+40,gsy+400];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+2, lsy+1);
    s2Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s2schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+80,gsy+400];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+3, lsy+1);
    s3Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s3schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+120,gsy+400];

    sprintf(strVar, "BRGCLKGATE_%d_%d", lsx, lsy+2);
    s4Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s4schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+160,gsy+400];

    sprintf(strVar, "BRGCLKGATE_%d_%d", lsx+1, lsy+2);
    s5Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s5schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+200,gsy+400];
  

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1, lsy);
    d0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d0schm = device IOCLKDIV ( symbol fpsym ) *strVar @[gsx+80,gsy+500];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+1, lsy);
    d1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d1schm = device IOCLKDIV ( symbol fpsym ) *strVar @[gsx+120,gsy+500];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+2, lsy);
    d2Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d2schm = device IOCLKDIV ( symbol fpsym ) *strVar @[gsx+160,gsy+500];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+3, lsy);
    d3Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d3schm = device IOCLKDIV ( symbol fpsym ) *strVar @[gsx+200,gsy+500];   
    
    map ( 
            s0schm => s0Ref, 
            s1schm => s1Ref,
            s2schm => s2Ref, 
            s3schm => s3Ref,
            s4schm => s4Ref, 
            s5schm => s5Ref,                
            d0schm => d0Ref, 
            d1schm => d1Ref,
            d2schm => d2Ref,
            d3schm => d3Ref                            
         );


}; // end of function draw_ioclkgen_b_tile_fp

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw ioclkgen_t tile fp]
  
  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
  IOCLKGATE4[0,2]  IOCLKGATE5[1,2]        
  IOCLKGATE0[0,1]  IOCLKGATE1[1,1]  IOCLKGATE2[2,1]  IOCLKGATE3[3,1]   USCMMUX2TO1[0,1] USCMMUX2TO1[1,1] USCMMUX2TO1[2,1] USCMMUX2TO1[3,1]
                   IOCLKMUX[1,0]                                       IOCLKDIV[0,0]   IOCLKDIV[1,0]   IOCLKDIV[2,0]   IOCLKDIV[3,0]
  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
                                      Tile 0                                                               Tile 1 

  Revision History:

*****************************************************************************************/
function draw_ioclkgen_t_tile_fp 
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsx1, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref, s1Ref, s2Ref, s3Ref, s4Ref, s5Ref, d0Ref, d1Ref, d2Ref, d3Ref;
    &symbol s0schm, s1schm, s2schm, s3schm, s4schm, s5schm, s6schm, s7schm, d0schm, d1schm, d2schm, d3schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsx1 = (tx+1) * TILE_NUM_SITE_X;   
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "IOCLKGATE_%d_%d", lsx, lsy+1);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx,gsy-100];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+1, lsy+1);
    s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s1schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+40,gsy-100];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+2, lsy+1);
    s2Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s2schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+80,gsy-100];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+3, lsy+1);
    s3Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s3schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+120,gsy-100];

    sprintf(strVar, "BRGCLKGATE_%d_%d", lsx, lsy+2);
    s4Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s4schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+160,gsy-100];

    sprintf(strVar, "BRGCLKGATE_%d_%d", lsx+1, lsy+2);
    s5Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s5schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+200,gsy-100];
  

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1, lsy);
    d0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d0schm = device IOCLKDIV ( symbol fpsym ) *strVar @[gsx+80,gsy-200];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+1, lsy);
    d1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d1schm = device IOCLKDIV ( symbol fpsym ) *strVar @[gsx+120,gsy-200];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+2, lsy);
    d2Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d2schm = device IOCLKDIV ( symbol fpsym ) *strVar @[gsx+160,gsy-200];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+3, lsy);
    d3Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d3schm = device IOCLKDIV ( symbol fpsym ) *strVar @[gsx+200,gsy-200];   
   
   
   
   
    
    map ( 
            s0schm => s0Ref, 
            s1schm => s1Ref,
            s2schm => s2Ref, 
            s3schm => s3Ref,
            s4schm => s4Ref, 
            s5schm => s5Ref,                      
            d0schm => d0Ref, 
            d1schm => d1Ref,
            d2schm => d2Ref, 
            d3schm => d3Ref                            
         );


}; // end of function draw_ioclkgen_t_tile_fp

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw ioclkgen_r tile fp]
  
  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
  IOCLKGATE4[0,2]  IOCLKGATE5[1,2]  IOCLKGATE6[2,2]  IOCLKGATE7[3,2]      
  IOCLKGATE0[0,1]  IOCLKGATE1[1,1]  IOCLKGATE2[2,1]  IOCLKGATE3[3,1]   USCMMUX2TO1[0,1] USCMMUX2TO1[1,1] USCMMUX2TO1[2,1] USCMMUX2TO1[3,1]
                   IOCLKMUX[1,0]                                       IOCLKDIV[0,0]   IOCLKDIV[1,0]   IOCLKDIV[2,0]   IOCLKDIV[3,0]
  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
                                      Tile 0                                                               Tile 1 

  Revision History:

*****************************************************************************************/
function draw_ioclkgen_r_tile_fp 
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsx1, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref, s1Ref, s2Ref, s3Ref, s4Ref, s5Ref, s6Ref, s7Ref, d0Ref, d1Ref, d2Ref, d3Ref;
    &symbol s0schm, s1schm, s2schm, s3schm, s4schm, s5schm, s6schm, s7schm, d0schm, d1schm, d2schm, d3schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsx1 = (tx+1) * TILE_NUM_SITE_X;   
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "IOCLKGATE_%d_%d", lsx, lsy+1);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+480,gsy+650];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+1, lsy+1);
    s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s1schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+480,gsy+690];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+2, lsy+1);
    s2Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s2schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+480,gsy+730];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+3, lsy+1);
    s3Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s3schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+480,gsy+770];

    sprintf(strVar, "BRGCLKGATE_%d_%d", lsx, lsy+2);
    s4Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s4schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+480,gsy+810];

    sprintf(strVar, "BRGCLKGATE_%d_%d", lsx+1, lsy+2);
    s5Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s5schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+480,gsy+850];

    sprintf(strVar, "BRGCLKGATE_%d_%d", lsx+2, lsy+2);
    s6Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s6schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+480,gsy+890];

    sprintf(strVar, "BRGCLKGATE_%d_%d", lsx+3, lsy+2);
    s7Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s7schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+480,gsy+930];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1, lsy);
    d0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d0schm = device IOCLKDIV ( symbol fpsym ) *strVar @[gsx+440,gsy+730];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+1, lsy);
    d1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d1schm = device IOCLKDIV ( symbol fpsym ) *strVar @[gsx+440,gsy+770];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+2, lsy);
    d2Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d2schm = device IOCLKDIV ( symbol fpsym ) *strVar @[gsx+440,gsy+810];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+3, lsy);
    d3Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d3schm = device IOCLKDIV ( symbol fpsym ) *strVar @[gsx+440,gsy+850];   
    
    map ( 
            s0schm => s0Ref, 
            s1schm => s1Ref,
            s2schm => s2Ref, 
            s3schm => s3Ref,
            s4schm => s4Ref, 
            s5schm => s5Ref,
            s6schm => s6Ref, 
            s7schm => s7Ref,            
            d0schm => d0Ref, 
            d1schm => d1Ref,
            d2schm => d2Ref,
            d3schm => d3Ref                             
         );


}; // end of function draw_ioclkgen_r_tile_fp

/**VFunction******************************************************************************

  Author    [xiawei]

  Abstract  [Draw ioclkgen_l tile fp]
  
  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
        
  IOCLKGATE0[0,1]  IOCLKGATE1[1,1]  IOCLKGATE2[2,1]  IOCLKGATE3[3,1]   USCMMUX2TO1[0,1] USCMMUX2TO1[1,1] USCMMUX2TO1[2,1] USCMMUX2TO1[3,1]
                   IOCLKMUX[1,0]                                       IOCLKDIV[0,0]   IOCLKDIV[1,0]   IOCLKDIV[2,0]   IOCLKDIV[3,0]
  ------------|---------------|---------------|-------------          ------------|---------------|---------------|-------------
                                      Tile 0                                                               Tile 1 

  Revision History:

*****************************************************************************************/
function draw_ioclkgen_l_tile_fp 
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsx1, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref, s1Ref, s2Ref, s3Ref, d0Ref, d1Ref, d2Ref, d3Ref;
    &symbol s0schm, s1schm, s2schm, s3schm, s4schm, s5schm, s6schm, s7schm, d0schm, d1schm, d2schm, d3schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsx1 = (tx+1) * TILE_NUM_SITE_X;   
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "IOCLKGATE_%d_%d", lsx, lsy+1);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+180,gsy+10];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+1, lsy+1);
    s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s1schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+180,gsy+50];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+2, lsy+1);
    s2Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s2schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+180,gsy+90];

    sprintf(strVar, "IOCLKGATE_%d_%d", lsx+3, lsy+1);
    s3Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s3schm = device IOCLKGATE ( symbol fpsym ) *strVar @[gsx+180,gsy+130];
   

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1, lsy);
    d0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d0schm = device IOCLKDIV ( symbol fpsym ) *strVar @[gsx+220,gsy+90];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+1, lsy);
    d1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d1schm = device IOCLKDIV ( symbol fpsym ) *strVar @[gsx+220,gsy+130];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+2, lsy);
    d2Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d2schm = device IOCLKDIV ( symbol fpsym ) *strVar @[gsx+220,gsy+170];

    sprintf(strVar, "IOCLKDIV_%d_%d", lsx1+3, lsy);
    d3Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    d3schm = device IOCLKDIV ( symbol fpsym ) *strVar @[gsx+220,gsy+210];   
    
    map ( 
            s0schm => s0Ref, 
            s1schm => s1Ref,
            s2schm => s2Ref, 
            s3schm => s3Ref,
            d0schm => d0Ref, 
            d1schm => d1Ref,
            d2schm => d2Ref,
            d3schm => d3Ref                             
         );


}; // end of function draw_ioclkgen_l_tile_fp

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place start tile fp]
  
  ------------|---------------|---------------|-------------   
 
 
                                                START[3,0]
  ------------|---------------|---------------|-------------   

  Revision History:

*****************************************************************************************/
function place_start_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int blank_x0
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx, lsy, fsy;

    // device reference variables
    &device s0Ref;
    &device s0fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    
    fsx = ( lsx + 3 ) / 2 + 2;
    fsy = ( lsy + 0 ) / 3 + 1;
    
    if( fsx > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx = fsx - 2;          
    }       
    
    if( fsy <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy = fsy;   
    }    
    else if( fsy <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 1;        
    }
    else if( fsy <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 2;        
    }
    else if( fsy <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 3;        
    }
    else 
    {
         fsy = fsy - 4;         
    }            

    // Pull out the device instances from logic structure
    s0Ref = <device START @[lsx+3,lsy]   of ARCHITECTURE>;

    // Instantiate the device. 
    sprintf(strVar, "START_%d_%d", lsx+3, lsy);
    s0fl = device START  *strVar @[fsx,fsy];

    map ( s0fl => s0Ref);


}; // end of function place_start_tile_fp  



/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw start tile fp]
  
  ------------|---------------|---------------|-------------   
 
 
                                                START[3,0]
  ------------|---------------|---------------|-------------  

  Revision History:

*****************************************************************************************/
function draw_start_tile_fp 
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref;
    &symbol s0schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "START_%d_%d", lsx+3, lsy);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device START ( symbol fpsym) *strVar @[gsx+120,gsy+120];

    map ( s0schm => s0Ref);

}; // end of function draw_start_tile_fp

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place grs tile fp]
  
  ------------|---------------|---------------|-------------   
 
 
                                                GRS[3,1]
  ------------|---------------|---------------|-------------   

  Revision History:

*****************************************************************************************/
function place_grs_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int blank_x0
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx, lsy, fsy;

    // device reference variables
    &device s0Ref;
    &device s0fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    
    fsx = ( lsx + 3 ) / 2 + 2;
    fsy = ( lsy + 1 ) / 3 + 1;
    
    if( fsx > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx = fsx - 2;          
    }       
    
    if( fsy <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy = fsy;   
    }    
    else if( fsy <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 1;        
    }
    else if( fsy <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 2;        
    }
    else if( fsy <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 3;        
    }
    else 
    {
         fsy = fsy - 4;         
    }            

    // Pull out the device instances from logic structure
    s0Ref = <device GRS @[lsx+3,lsy+1]   of ARCHITECTURE>;

    // Instantiate the device. 
    sprintf(strVar, "GRS_%d_%d", lsx+3, lsy+1);
    s0fl = device GRS  *strVar @[fsx,fsy];

    map ( s0fl => s0Ref);


}; // end of function place_grs_tile_fp  

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw grs tile fp]
  
  ------------|---------------|---------------|-------------   
 
 
                                                GRS[3,1]
  ------------|---------------|---------------|-------------  

  Revision History:

*****************************************************************************************/
function draw_grs_tile_fp 
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref;
    &symbol s0schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "GRS_%d_%d", lsx+3, lsy+1);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device GRS ( symbol fpsym) *strVar @[gsx+140,gsy+240];

    map ( s0schm => s0Ref);

}; // end of function draw_start_tile_fp

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place osc tile fp]
  
  ------------|---------------|---------------|-------------   
 
 
                                                OSC[3,0]
  ------------|---------------|---------------|-------------   

  Revision History:

*****************************************************************************************/
function place_osc_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int blank_x0
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx, lsy, fsy;

    // device reference variables
    &device s0Ref;
    &device s0fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    
    fsx = ( lsx + 3 ) / 2 + 2;
    fsy = ( lsy ) / 3 + 1;
    
    if( fsx > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx = fsx - 2;          
    }       
    
    if( fsy <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy = fsy;   
    }    
    else if( fsy <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 1;        
    }
    else if( fsy <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 2;        
    }
    else if( fsy <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 3;        
    }
    else 
    {
         fsy = fsy - 4;         
    }            

    // Pull out the device instances from logic structure
    s0Ref = <device OSC @[lsx+3,lsy]   of ARCHITECTURE>;

    // Instantiate the device. 
    sprintf(strVar, "OSC_%d_%d", lsx+3, lsy);
    s0fl = device OSC  *strVar @[fsx,fsy];

    map ( s0fl => s0Ref);


}; // end of function place_grs_tile_fp  

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw osc tile fp]
  
  ------------|---------------|---------------|-------------   
 
 
                                                OSC[3,0]
  ------------|---------------|---------------|-------------  

  Revision History:

*****************************************************************************************/
function draw_osc_tile_fp 
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref;
    &symbol s0schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "OSC_%d_%d", lsx+3, lsy);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device OSC ( symbol fpsym) *strVar @[gsx+140,gsy+240];

    map ( s0schm => s0Ref);

}; // end of function draw_start_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place efusecode tile fp]
  
  ------------|---------------|---------------|-------------   
 
 
                                               EFUSECODE[3,0]
  ------------|---------------|---------------|-------------   

  Revision History:

*****************************************************************************************/
function place_efusecode_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int blank_x0
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx, lsy, fsy;

    // device reference variables
    &device s0Ref;
    &device s0fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    fsx = ( lsx + 3 ) / 2 + 2;
    fsy = ( lsy + 0 ) / 3 + 1;

    if( fsx > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx = fsx - 2;          
    }       
    
    if( fsy <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy = fsy;   
    }    
    else if( fsy <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 1;        
    }
    else if( fsy <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 2;        
    }
    else if( fsy <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 3;        
    }
    else 
    {
         fsy = fsy - 4;         
    }            

    // Pull out the device instances from logic structure
    s0Ref = <device EFUSECODE @[lsx+3,lsy]   of ARCHITECTURE>;

    // Instantiate the device. 
    sprintf(strVar, "EFUSECODE_%d_%d", lsx+3, lsy);
    s0fl = device EFUSECODE  *strVar @[fsx,fsy];

    map ( s0fl => s0Ref);


}; // end of function place_efusecode_tile_fp  



/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw efusecode tile fp]
  
  ------------|---------------|---------------|-------------   
 
 
                                               EFUSECODE[3,0]
  ------------|---------------|---------------|-------------   

  Revision History:

*****************************************************************************************/
function draw_efusecode_tile_fp 
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref;
    &symbol s0schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "EFUSECODE_%d_%d", lsx+3, lsy);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device EFUSECODE ( symbol fpsym) *strVar @[gsx+120,gsy+120];

    map ( s0schm => s0Ref);

}; // end of function draw_efusecode_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place ipal tile fp]
  
  ------------|---------------|---------------|-------------   
 
 
                                               IPAL[3,0]
  ------------|---------------|---------------|-------------  

  Revision History:

*****************************************************************************************/
function place_ipal_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int blank_x0
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx, lsy, fsy;

    // device reference variables
    &device s0Ref;
    &device s0fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    fsx = ( lsx + 3 ) / 2 + 2;
    fsy = ( lsy + 0 ) / 3 + 1;

    if( fsx > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx = fsx - 2;          
    }       
    
    if( fsy <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy = fsy;   
    }    
    else if( fsy <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 1;        
    }
    else if( fsy <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 2;        
    }
    else if( fsy <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy = fsy - 3;        
    }
    else 
    {
         fsy = fsy - 4;         
    }            

    // Pull out the device instances from logic structure
    s0Ref = <device IPAL @[lsx+3,lsy]   of ARCHITECTURE>;

    // Instantiate the device. 
    sprintf(strVar, "IPAL_%d_%d", lsx+3, lsy);
    s0fl = device IPAL  *strVar @[fsx,fsy];

    map ( s0fl => s0Ref);


}; // end of function place_ipal_tile_fp  



/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw ipal tile fp]
  
  ------------|---------------|---------------|-------------   
 
 
                                               IPAL[3,0]
  ------------|---------------|---------------|-------------   

  Revision History:

*****************************************************************************************/
function draw_ipal_tile_fp 
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref;
    &symbol s0schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "IPAL_%d_%d", lsx+3, lsy);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device IPAL ( symbol fpsym) *strVar @[gsx+120,gsy+120];

    map ( s0schm => s0Ref);

}; // end of function draw_ipal_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place scanchain0 tile fp]
  
  ------------|---------------|---------------|-------------   
 
 
                                               SCANCHAIN1[3,1]
                                               SCANCHAIN0[3,0]
  ------------|---------------|---------------|-------------  

  Revision History:

*****************************************************************************************/
function place_scanchain0_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int blank_x0
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx0, lsy, fsy0, fsx1, fsy1;

    // device reference variables
    &device s0Ref, s1Ref;
    &device s0fl, s1fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    
    fsx0 = ( lsx + 3 ) / 2 + 2;
    if( ( lsy + 0 ) % 3 == 0 )
    {
        fsx0 = fsx0 - 1;        
    }
    fsy0 = ( lsy + 0 ) / 3 + 1;
    
    fsx1 = ( lsx + 3 ) / 2 + 2;
    if( ( lsy + 1 ) % 3 == 0 )
    {
        fsx1 = fsx1 - 1;        
    }            
    fsy1 = ( lsy + 1 ) / 3 + 1;  
    
    if( fsx0 > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx0 = fsx0 - 2;          
    }       
    
    if( fsy0 <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy0 = fsy0;   
    }    
    else if( fsy0 <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy0 = fsy0 - 1;        
    }
    else if( fsy0 <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy0 = fsy0 - 2;        
    }
    else if( fsy0 <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy0 = fsy0 - 3;        
    }
    else 
    {
         fsy0 = fsy0 - 4;         
    }            

    if( fsx1 > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx1 = fsx1 - 2;          
    }       
    
    if( fsy1 <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy1 = fsy1;   
    }    
    else if( fsy1 <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy1 = fsy1 - 1;        
    }
    else if( fsy1 <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy1 = fsy1 - 2;        
    }
    else if( fsy1 <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy1 = fsy1 - 3;        
    }
    else 
    {
         fsy1 = fsy1 - 4;         
    }            

    // Pull out the device instances from logic structure
    s0Ref = <device SCANCHAIN @[lsx+3,lsy+0]   of ARCHITECTURE>;
    s1Ref = <device SCANCHAIN @[lsx+3,lsy+1]   of ARCHITECTURE>;

    // Instantiate the device. 
    sprintf(strVar, "SCANCHAIN_%d_%d", lsx+3, lsy+0);
    s0fl = device SCANCHAIN  *strVar @[fsx0,fsy0];

    sprintf(strVar, "SCANCHAIN_%d_%d", lsx+3, lsy+1);
    s1fl = device SCANCHAIN  *strVar @[fsx1,fsy1];

    map ( s0fl => s0Ref, s1fl => s1Ref );


}; // end of function place_scanchain0_tile_fp  



/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [draw scanchain0 tile fp]
  
  ------------|---------------|---------------|-------------   
 
 
                                               SCANCHAIN1[3,1]
                                               SCANCHAIN0[3,0]
  ------------|---------------|---------------|-------------  

  Revision History:

*****************************************************************************************/
function  draw_scanchain0_tile_fp
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref, s1Ref;
    &symbol s0schm, s1schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "SCANCHAIN_%d_%d", lsx+3, lsy+0);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device SCANCHAIN ( symbol fpsym ) *strVar @[gsx+120,gsy+50];

    sprintf(strVar, "SCANCHAIN_%d_%d", lsx+3, lsy+1);
    s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s1schm = device SCANCHAIN ( symbol fpsym ) *strVar @[gsx+120,gsy+200];

    map ( s0schm => s0Ref, s1schm => s1Ref );


}; // end of function draw_scanchain0_tile_fp

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place scanchain1 tile fp]
  
  ------------|---------------|---------------|-------------   
 
 
                                               SCANCHAIN3[3,1]
                                               SCANCHAIN2[3,0]
  ------------|---------------|---------------|-------------  

  Revision History:

*****************************************************************************************/
function place_scanchain1_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int blank_x0
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx2, lsy, fsy2, fsx3, fsy3;

    // device reference variables
    &device s0Ref, s1Ref;
    &device s0fl, s1fl;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    
    fsx2 = ( lsx + 3 ) / 2 + 2;
    if( ( lsy + 0 ) % 3 == 0 )
    {
        fsx2 = fsx2 - 1;        
    }
    fsy2 = ( lsy + 0 ) / 3 + 1;
    
    fsx3 = ( lsx + 3 ) / 2 + 2;
    if( ( lsy + 1 ) % 3 == 0 )
    {
        fsx3 = fsx3 - 1;        
    }            
    fsy3 = ( lsy + 1 ) / 3 + 1;  

    if( fsx2 > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx2 = fsx2 - 2;          
    }       
    
    if( fsy2 <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy2 = fsy2;   
    }    
    else if( fsy2 <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy2 = fsy2 - 1;        
    }
    else if( fsy2 <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy2 = fsy2 - 2;        
    }
    else if( fsy2 <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy2 = fsy2 - 3;        
    }
    else 
    {
         fsy2 = fsy2 - 4;         
    }            
    
    if( fsx3 > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
    {        
        fsx3 = fsx3 - 2;          
    }       
    
    if( fsy3 <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
    {
         fsy3 = fsy3;   
    }    
    else if( fsy3 <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy3 = fsy3 - 1;        
    }
    else if( fsy3 <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy3 = fsy3 - 2;        
    }
    else if( fsy3 <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
    {
         fsy3 = fsy3 - 3;        
    }
    else 
    {
         fsy3 = fsy3 - 4;         
    }            

    // Pull out the device instances from logic structure
    s0Ref = <device SCANCHAIN @[lsx+3,lsy+0]   of ARCHITECTURE>;
    s1Ref = <device SCANCHAIN @[lsx+3,lsy+1]   of ARCHITECTURE>;

    // Instantiate the device. 
    sprintf(strVar, "SCANCHAIN_%d_%d", lsx+3, lsy+0);
    s0fl = device SCANCHAIN  *strVar @[fsx2,fsy2];

    sprintf(strVar, "SCANCHAIN_%d_%d", lsx+3, lsy+1);
    s1fl = device SCANCHAIN  *strVar @[fsx3,fsy3];

    map ( s0fl => s0Ref, s1fl => s1Ref );


}; // end of function place_scanchain1_tile_fp  



/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [draw scanchain1 tile fp]
  
  ------------|---------------|---------------|-------------   
 
 
                                               SCANCHAIN3[3,1]
                                               SCANCHAIN2[3,0]
  ------------|---------------|---------------|-------------  

  Revision History:

*****************************************************************************************/
function  draw_scanchain1_tile_fp
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref, s1Ref;
    &symbol s0schm, s1schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X;
    gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y;

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "SCANCHAIN_%d_%d", lsx+3, lsy+0);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device SCANCHAIN ( symbol fpsym ) *strVar @[gsx+120,gsy+50];

    sprintf(strVar, "SCANCHAIN_%d_%d", lsx+3, lsy+1);
    s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s1schm = device SCANCHAIN ( symbol fpsym ) *strVar @[gsx+120,gsy+200];

    map ( s0schm => s0Ref, s1schm => s1Ref );


}; // end of function draw_scanchain1_tile_fp


/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Place clk_delay tile fp]
  
  ---------|---------|---------|--------- 
                                     
                                CLKDELAY[3,1]
  
  ---------|---------|---------|---------   

  Revision History:

*****************************************************************************************/
function place_clk_delay_tile_fp
( 
    unsigned int tx,
    unsigned int ty,
    unsigned int num_tile_x,
    unsigned int num_tile_y,
    unsigned int blank_x0
)
{

    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, fsx, lsy, fsy;

    // device reference variables
    &device s0Ref;
    &device s0fl;

    string strVar;
   
    if(tx == num_tile_x - 1) // right
    {        
        lsx = tx * TILE_NUM_SITE_X;
        lsy = ty * TILE_NUM_SITE_Y; 
        
        fsx = ( lsx + 3 ) / 2 + 2;
        if( ( lsy + 1 ) % 3 == 2 )
        {
            fsx = fsx + 2;                
        }
        fsy = ( lsy + 1 ) / 3 + 1;
                
        if( fsx > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
        {        
            fsx = fsx - 2;          
        }       
        
        if( fsy <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
        {
             fsy = fsy;   
        }    
        else if( fsy <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
        {
             fsy = fsy - 1;        
        }
        else if( fsy <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
        {
             fsy = fsy - 2;        
        }
        else if( fsy <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
        {
             fsy = fsy - 3;        
        }
        else 
        {
             fsy = fsy - 4;         
        }            
        
        // Pull out the device instances from logic structure
        s0Ref = <device CLKDELAY @[lsx+3,lsy+1]   of ARCHITECTURE>;

        // Instantiate the device. 
        sprintf(strVar, "CLKDELAY_%d_%d", lsx+3, lsy+1);
        s0fl = device CLKDELAY  *strVar @[fsx,fsy];           
    
    }    
    if(ty == 0) // bottom
    {        
        lsx = tx * TILE_NUM_SITE_X;
        lsy = ty * TILE_NUM_SITE_Y; 
        
        fsx = ( lsx + 3 ) / 2 + 2;
        fsy = ( lsy + 1 ) - 1;        
                 
         if( fsx > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
         {        
             fsx = fsx - 2;          
         }       
         
         if( fsy <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
         {
              fsy = fsy;   
         }    
         else if( fsy <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
         {
              fsy = fsy - 1;        
         }
         else if( fsy <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
         {
              fsy = fsy - 2;        
         }
         else if( fsy <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
         {
              fsy = fsy - 3;        
         }
         else 
         {
              fsy = fsy - 4;         
         }            
               
        // Pull out the device instances from logic structure
        s0Ref = <device CLKDELAY @[lsx+3,lsy+1]   of ARCHITECTURE>;

        // Instantiate the device. 
        sprintf(strVar, "CLKDELAY_%d_%d", lsx+3, lsy+1);
        s0fl = device CLKDELAY  *strVar @[fsx,fsy];           
    
    }          
    if(ty == num_tile_y - 1) // top
    {        
        lsx = tx * TILE_NUM_SITE_X;
        lsy = ty * TILE_NUM_SITE_Y; 
        
        fsx = ( lsx + 3 ) / 2 + 2;
        fsy = ( lsy + 1 ) / 3 + 1; 
        if( ( lsy + 1 ) % 3 == 2 )
        {
            fsy = fsy + 1;    
        }       
                
        if( fsx > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
        {        
            fsx = fsx - 2;          
        }       
        
        if( fsy <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
        {
             fsy = fsy;   
        }    
        else if( fsy <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
        {
             fsy = fsy - 1;        
        }
        else if( fsy <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
        {
             fsy = fsy - 2;        
        }
        else if( fsy <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
        {
             fsy = fsy - 3;        
        }
        else 
        {
             fsy = fsy - 4;         
        }            
                
        // Pull out the device instances from logic structure
        s0Ref = <device CLKDELAY @[lsx+3,lsy+1]   of ARCHITECTURE>;

        // Instantiate the device. 
        sprintf(strVar, "CLKDELAY_%d_%d", lsx+3, lsy+1);
        s0fl = device CLKDELAY  *strVar @[fsx,fsy];           
    
    }       
    if(tx == 0) // left
    {        
        lsx = tx * TILE_NUM_SITE_X;
        lsy = ty * TILE_NUM_SITE_Y; 
        
        fsx = 1;
        fsy = ( lsy + 1 ) / 3 + 1;        
                
        if( fsx > ( ( blank_x0 * TILE_NUM_SITE_X + 1 ) / 2 + 2 ) )
        {        
            fsx = fsx - 2;          
        }       
        
        if( fsy <= ( ( BLANK_Y0 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) ) 
        {
             fsy = fsy;   
        }    
        else if( fsy <= ( ( BLANK_Y1 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
        {
             fsy = fsy - 1;        
        }
        else if( fsy <= ( ( BLANK_Y2 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
        {
             fsy = fsy - 2;        
        }
        else if( fsy <= ( ( BLANK_Y3 * TILE_NUM_SITE_Y + 1 ) / 3 + 1 ) )
        {
             fsy = fsy - 3;        
        }
        else 
        {
             fsy = fsy - 4;         
        }            
                
        // Pull out the device instances from logic structure
        s0Ref = <device CLKDELAY @[lsx+3,lsy+1]   of ARCHITECTURE>;

        // Instantiate the device. 
        sprintf(strVar, "CLKDELAY_%d_%d", lsx+3, lsy+1);
        s0fl = device CLKDELAY  *strVar @[fsx,fsy];           
    
    }       

    map ( s0fl => s0Ref);

}; // end of function place_clk_delay_tile_fp  

/**VFunction******************************************************************************

  Author    [XIAWEI]

  Abstract  [Draw clk_delay tile fp]
  
  ---------|---------|---------|--------- 
                                     
                                CLKDELAY[3,1]
  
  ---------|---------|---------|---------  

  Revision History:

*****************************************************************************************/
function draw_clk_delay_tile_fp 
( 
    unsigned int tx,
    unsigned int ty
)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, gsx, lsy, gsy;

    // device reference variables
    &device s0Ref;
    &symbol s0schm;

    string strVar;

    lsx = tx * TILE_NUM_SITE_X;
    lsy = ty * TILE_NUM_SITE_Y;
    
    if( tx == 63 )
    {
       gsx = 62 * TILE_NUM_FLOORPLAN_GUI_GRID_X + 80;
       gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y + 160;                
    }
    if( tx == 67 )
    {
       gsx = 62 * TILE_NUM_FLOORPLAN_GUI_GRID_X + 160;
       gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y + 160;                
    }
    
    if( tx == 70 )
    {
       gsx = 72 * TILE_NUM_FLOORPLAN_GUI_GRID_X + 80;
       gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y + 160;                
    }
    if( tx == 74)
    {
       gsx = 72 * TILE_NUM_FLOORPLAN_GUI_GRID_X + 160;
       gsy = ty * TILE_NUM_FLOORPLAN_GUI_GRID_Y + 160;                
    }

    if( ty == 19 )
    {
       gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X + 160;
       gsy = 20 * TILE_NUM_FLOORPLAN_GUI_GRID_Y + 80;          
    }
    if( ty == 21 )
    {
       gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X + 160;
       gsy = 20 * TILE_NUM_FLOORPLAN_GUI_GRID_Y + 160;          
    }

    if( ty == 60 )
    {
       gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X + 160;
       gsy = 61 * TILE_NUM_FLOORPLAN_GUI_GRID_Y + 80;          
    }
    if( ty == 62 )
    {
       gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X + 160;
       gsy = 61 * TILE_NUM_FLOORPLAN_GUI_GRID_Y + 160;          
    }
    
    if( ty == 101 )
    {
       gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X + 160;
       gsy = 102 * TILE_NUM_FLOORPLAN_GUI_GRID_Y + 80;          
    }
    if( ty == 103 )
    {
       gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X + 160;
       gsy = 102 * TILE_NUM_FLOORPLAN_GUI_GRID_Y + 160;          
    }

    if( ty == 142 )
    {
       gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X + 160;
       gsy = 143 * TILE_NUM_FLOORPLAN_GUI_GRID_Y + 80;          
    }
    if( ty == 144 )
    {
       gsx = tx * TILE_NUM_FLOORPLAN_GUI_GRID_X + 160;
       gsy = 143 * TILE_NUM_FLOORPLAN_GUI_GRID_Y + 160;          
    }

    // Pull out the device instances from logic structure

    // Instantiate the schematic. 
    sprintf(strVar, "CLKDELAY_%d_%d", lsx+3, lsy+1);
    s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
    s0schm = device CLKDELAY ( symbol fpsym) *strVar @[gsx,gsy];

    map ( s0schm => s0Ref);
}; // end of function draw_clk_delay_tile_fp

}; // end of package pango_schm_funcs


