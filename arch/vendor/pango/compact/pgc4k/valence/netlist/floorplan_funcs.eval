*******************************************************************

  Package   [pango_floorplan_funcs]

  Author    [jiang tao]

  Abstract  [Floorplan description common to pango architecture]

  Revision History:

********************************************************************************/
library work;
USE pgc_defs, pgc4k_defs, pango_defs;

package pgc_floorplan_funcs
{
    unsigned int fsx = 0;
    unsigned int fsy = 0;       
    
    function get_coordinate_of_clm
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        //adjust floorplan gap
        if(lsx > 66)//blank column
        {
            tmp_x = lsx-NUM_GRID_X;
        }
        
        if(lsy > 114)    //blank column
        {
            tmp_y = lsy-NUM_GRID_Y;
        }
        
        fsx = 2*(tmp_x/NUM_GRID_X)+10+tmp_y%2;
        fsy = tmp_y/NUM_GRID_Y+6;
        
        if (tmp_x >= 66)//blank column
        {
            fsx = fsx+2;
        }
        
        fsy = fsy + 2;
    };
    
    function get_coordinate_of_iol
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        //adjust floorplan gap
        if(lsx > 66)//blank column
        {
            tmp_x = lsx-NUM_GRID_X;
        }
        
        if(lsy > 114)    //blank column
        {
            tmp_y = lsy-NUM_GRID_Y;
        }
        
        if (lsy <= 10)
        {
            int tmp = tmp_x / NUM_GRID_X;

            if (tmp < 10)
            {
                if (1 == tmp % 2)
                {
                    fsx = 12 + (tmp / 2) * 4;
                    fsy = lsy - 7;
                }
                else
                {
                    fsx = 12 + (tmp / 2) * 4;
                    fsy = lsy - 3;
                }
            }
            else
            {
                if (1 == tmp % 2)
                {
                    fsx = 16 + (tmp / 2) * 4;
                    fsy = lsy - 7;
                }
                else
                {
                    fsx = 16 + (tmp / 2 - 1) * 4;
                    fsy = lsy - 3;
                }
            }
            
            if (lsx == 10)
            {
                fsx = 12;
                fsy = lsy - 3;
            }
            
            //Fix P/N reverse
            if (lsy % 2 == 0)
            {
                fsy = fsy - 1;
            }
            else
            {
                fsy = fsy + 1;
            }
        }
        else if (lsy >= 205)  //top
        {
            int tmp = tmp_x / NUM_GRID_X;

            if (tmp < 10)
            {
                if (1 == tmp % 2)
                {
                    fsx = 12 + (tmp / 2) * 4;
                    fsy = lsy - 203;
                }
                else
                {
                    fsx = 12 + (tmp / 2) * 4;
                    fsy = lsy - 199;
                }
            }
            else
            {
                if (1 == tmp % 2)
                {
                    fsx = 16 + (tmp / 2) * 4;
                    fsy = lsy - 203;
                }
                else
                {
                    fsx = 16 + (tmp / 2 - 1) * 4;
                    fsy = lsy - 199;
                }
            }

            if (lsx == 10)
            {
                fsx = 12;
                fsy = lsy - 203;
            }

            fsy += 40;
            
            //Fix P/N reverse
            if (lsy % 2 == 0)
            {
                fsy = fsy - 1;
            }
            else
            {
                fsy = fsy + 1;
            }
        }
        else if (lsx == 10) //left
        {
            if (lsy < 114)
            {
                int tmp = lsy / 6;
                if (lsy >= 79 && lsy <= 94)
                {
                    tmp = tmp - 1;
                }
                
                fsx = (tmp % 4) * 4;
                fsy = (tmp / 4 + 2) * 4 + (lsy % 6 - 1);
            } 
            else
            {
                int tmp = lsy / 6;
                if (lsy >= 163)
                {
                    tmp = tmp + 1;
                }
                
                fsx = tmp % 4 * 4;
                fsy = (tmp / 4 + 1) * 4 + (lsy % 6 - 1);
            }
        }
        else if (lsx == 124) //right
        {
            if (lsy < 114)
            {
                int tmp = lsy / 6;
                if (lsy >= 79 && lsy <= 94)
                {
                    tmp = tmp - 1;
                }
                
                fsx = (tmp % 4) * 4;
                fsy = (tmp / 4 + 2) * 4 + (lsy % 6 - 1);
            } 
            else
            {
                int tmp = lsy / 6;
                if (lsy >= 163)
                {
                    tmp = tmp + 1;
                }
                
                fsx = tmp % 4 * 4;
                fsy = (tmp / 4 + 1) * 4 + (lsy % 6 - 1);
            }

            fsx = fsx + 52;
        }
    };
    
    function get_coordinate_of_iob
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        //adjust floorplan gap
        if(lsx > 66)//blank column
        {
            tmp_x = lsx-NUM_GRID_X;
        }
        
        if(lsy > 114)    //blank column
        {
            tmp_y = lsy-NUM_GRID_Y;
        }
        
                //bottom
        if (lsy == 0)
        {
            int tmp = tmp_x / NUM_GRID_X;

            if (tmp < 10)
            {
                if (1 == tmp % 2)
                {
                    fsx = 12 + (tmp / 2) * 4;
                    fsy = 3 - tmp_x % NUM_GRID_X;
                }
                else
                {
                    fsx = 12 + (tmp / 2) * 4;
                    fsy = 7 - tmp_x % NUM_GRID_X;
                }
            } 
            else
            {
                if (1 == tmp % 2)
                {
                    fsx = 16 + (tmp / 2) * 4;
                    fsy = 3 - tmp_x % NUM_GRID_X;
                }
                else
                {
                    fsx = 16 + (tmp / 2 - 1) * 4;
                    fsy = 7 - tmp_x % NUM_GRID_X;
                }
            }

            if (lsx < 10)
            {
                fsx = 12;
                fsy = 7-lsx%6;
            }
            
            //Fix P/N reverse
            if (lsx % 2 == 0)
            {
                fsy = fsy - 1;
            }
            else
            {
                fsy = fsy + 1;
            }
        }
        else if (lsy == 210)  //top
        {
            int tmp = tmp_x / NUM_GRID_X;

            if (tmp < 10)
            {
                if (1 == tmp % 2)
                {
                    fsx = 12 + (tmp / 2) * 4;
                    fsy = 3 - tmp_x % NUM_GRID_X;
                }
                else
                {
                    fsx = 12 + (tmp / 2) * 4;
                    fsy = 7 - tmp_x % NUM_GRID_X;
                }
            } 
            else
            {
                if (1 == tmp % 2)
                {
                    fsx = 16 + (tmp / 2) * 4;
                    fsy = 3 - tmp_x % NUM_GRID_X;
                }
                else
                {
                    fsx = 16 + (tmp / 2 - 1) * 4;
                    fsy = 7 - tmp_x % NUM_GRID_X;
                }
            }

            if (lsx < 10)
            {
                fsx = 12;
                fsy = 3-lsx%6;
            }

            fsy += 42;
            
            //Fix P/N reverse
            if (lsx % 2 == 0)
            {
                fsy = fsy - 1;
            }
            else
            {
                fsy = fsy + 1;
            }
        }
        else if (lsx == 0) //left
        {
            int lsy_m = lsy + 1;
            if (lsy_m < 114)
            {
                int tmp = lsy_m / 6;
                if (lsy_m >= 79 && lsy_m <= 94)
                {
                    tmp = tmp - 1;
                }
                
                fsx = tmp % 4 * 4;
                fsy = (tmp / 4 + 2) * 4 + (lsy_m % 6 - 1);
            } 
            else
            {
                int tmp = lsy_m / 6;
                if (lsy_m >= 163)
                {
                    tmp = tmp + 1;
                }
                
                fsx = tmp % 4 * 4;
                fsy = (tmp / 4 + 1) * 4 + (lsy_m % 6 - 1);
            }
        }
        else if (lsx == 126) //right
        {
            int lsy_m = lsy + 1;
            if (lsy_m < 114)
            {
                int tmp = lsy_m / 6;
                if (lsy_m >= 79 && lsy_m <= 94)
                {
                    tmp = tmp - 1;
                }
                
                fsx = (tmp % 4) * 4;
                fsy = (tmp / 4 + 2) * 4 + (lsy_m % 6 - 1);
            } 
            else
            {
                int tmp = lsy_m / 6;
                if (lsy_m >= 163)
                {
                    tmp = tmp + 1;
                }
                
                fsx = tmp % 4 * 4;
                fsy = (tmp / 4 + 1) * 4 + (lsy_m % 6 - 1);
            }

            fsx = fsx + 52;
        }

        fsx = fsx + 1;
    };
        
    function get_coordinate_of_ioldly
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        int lsx_iol = lsx + 1;
        int lsy_iol = lsy;
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx_iol;
        tmp_y = lsy_iol;
        
        //adjust floorplan gap
        if(lsx_iol > 66)//blank column
        {
            tmp_x = lsx_iol-NUM_GRID_X;
        }
        
        if(lsy_iol > 114)    //blank column
        {
            tmp_y = lsy_iol-NUM_GRID_Y;
        }
        
        if (lsy_iol <= 10)
        {
            int tmp = tmp_x / NUM_GRID_X;

            if (tmp < 10)
            {
                if (1 == tmp % 2)
                {
                    fsx = 12 + (tmp / 2) * 4;
                    fsy = lsy_iol - 7;
                }
                else
                {
                    fsx = 12 + (tmp / 2) * 4;
                    fsy = lsy_iol - 3;
                }
            }
            else
            {
                if (1 == tmp % 2)
                {
                    fsx = 16 + (tmp / 2) * 4;
                    fsy = lsy_iol - 7;
                }
                else
                {
                    fsx = 16 + (tmp / 2 - 1) * 4;
                    fsy = lsy_iol - 3;
                }
            }
            
            if (lsx_iol == 10)
            {
                fsx = 12;
                fsy = lsy_iol - 3;
            }
            
            //Fix P/N reverse
            if (lsy % 2 == 0)
            {
                fsy = fsy - 1;
            }
            else
            {
                fsy = fsy + 1;
            }
        }
        else if (lsy_iol >= 205)  //top
        {
            int tmp = tmp_x / NUM_GRID_X;

            if (tmp < 10)
            {
                if (1 == tmp % 2)
                {
                    fsx = 12 + (tmp / 2) * 4;
                    fsy = lsy_iol - 203;
                }
                else
                {
                    fsx = 12 + (tmp / 2) * 4;
                    fsy = lsy_iol - 199;
                }
            }
            else
            {
                if (1 == tmp % 2)
                {
                    fsx = 16 + (tmp / 2) * 4;
                    fsy = lsy_iol - 203;
                }
                else
                {
                    fsx = 16 + (tmp / 2 - 1) * 4;
                    fsy = lsy_iol - 199;
                }
            }

            if (lsx == 10)
            {
                fsx = 12;
                fsy = lsy - 203;
            }

            fsy += 40;
            
            //Fix P/N reverse
            if (lsy % 2 == 0)
            {
                fsy = fsy - 1;
            }
            else
            {
                fsy = fsy + 1;
            }
        }
        else if (lsx_iol == 10) //left
        {
            if (lsy_iol < 114)
            {
                int tmp = lsy_iol / 6;
                if (lsy_iol >= 79 && lsy_iol <= 94)
                {
                    tmp = tmp - 1;
                }
                
                fsx = (tmp % 4) * 4;
                fsy = (tmp / 4 + 2) * 4 + (lsy_iol % 6 - 1);
            } 
            else
            {
                int tmp = lsy_iol / 6;
                if (lsy_iol >= 163)
                {
                    tmp = tmp + 1;
                }
                
                fsx = tmp % 4 * 4;
                fsy = (tmp / 4 + 1) * 4 + (lsy_iol % 6 - 1);
            }
        }
        else if (lsx_iol == 124) //right
        {
            if (lsy_iol < 114)
            {
                int tmp = lsy_iol / 6;
                if (lsy_iol >= 79 && lsy_iol <= 94)
                {
                    tmp = tmp - 1;
                }
                
                fsx = (tmp % 4) * 4;
                fsy = (tmp / 4 + 2) * 4 + (lsy_iol % 6 - 1);
            } 
            else
            {
                int tmp = lsy / 6;
                if (lsy >= 163)
                {
                    tmp = tmp + 1;
                }
                
                fsx = tmp % 4 * 4;
                fsy = (tmp / 4 + 1) * 4 + (lsy_iol % 6 - 1);
            }

            fsx = fsx + 52;
        }
        
        fsx = fsx + 2;
    }; 
    
    
    function get_coordinate_of_oserdes
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        int lsy_iol = lsy - 4;

        if (lsy_iol < 114)
        {
            int tmp = lsy / 6;
            if (lsy_iol >= 79 && lsy_iol <= 94)
            {
                tmp = tmp - 1;
            }
                
            fsx = tmp % 4 * 4;
            fsy = (tmp / 4 + 2) * 4 + (lsy_iol % 6 - 1);
        }
        else
        {
            int tmp = lsy_iol / 6;
            if (lsy_iol >= 163)
            {
                tmp = tmp + 1;
            }
            
            fsx = tmp % 4 * 4;
            fsy = (tmp / 4 + 1) * 4 + (lsy_iol % 6 - 1);
        }

        fsx =fsx + 3;
    };
    
    function get_coordinate_of_iserdes
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        int lsy_iol = lsy - 4;
        if (lsy_iol < 114)
        {
            int tmp = lsy_iol / 6;
            if (lsy_iol >= 79 && lsy_iol <= 94)
            {
                tmp = tmp - 1;
            }
                
            fsx = tmp % 4 * 4;
            fsy = (tmp / 4 + 2) * 4 + (lsy_iol % 6 - 1);
        }
        else
        {
            int tmp = lsy_iol / 6;
            if (lsy_iol >= 163)
            {
                tmp = tmp + 1;
            }
            
            fsx = tmp % 4 * 4;
            fsy = (tmp / 4 + 1) * 4 + (lsy_iol % 6 - 1);
        }

        fsx += 3;
        fsx += 52;
    };
    
    function get_coordinate_of_drm
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        //adjust floorplan gap
        if(lsx > 66)//blank column
        {
            tmp_x = lsx-NUM_GRID_X;
        }
        
        if(lsy > 114)    //blank column
        {
            tmp_y = lsy-NUM_GRID_Y;
        }
        
        fsx = 31;
        fsy = tmp_y/NUM_GRID_Y + 8;
    };
    
    function get_coordinate_of_pll
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        fsx = 13;
        fsy = tmp_y / NUM_GRID_Y + 7;
    };
    
    function get_coordinate_of_uscmdc
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        fsx = tmp_x / 3 + 10;
        fsy = tmp_y / 6 + tmp_y % 6 + ((tmp_x-1) % 2) * 8 - 4;
    };
    
    function get_coordinate_of_uscmd
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        fsx = tmp_x / 3 + 10;
        fsy = tmp_y % 3 + 28;
    };
    
    function get_coordinate_of_iockbrg
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        fsx = tmp_x / 3 + 10;
        fsy = tmp_y/6-3;
    };
    
    function get_coordinate_of_dll
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        if (lsx == 9)
        {
            fsx = 13;
            fsy = 34;
        }
        else
        {
            fsx = 50;
            fsy = 9;
        }
    };
    
    function get_coordinate_of_iockgate
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        if (lsx < 56)
        {
            fsx = 9 + lsy % 2;
        }
        else
        {
            fsx = 60 + lsy % 2;
        }
        
        fsy = 27;
    };
    
    function get_coordinate_of_bkcl
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        
        if (lsy < 5)
        {
            fsx = 29;
            if (lsx < 48)
            {
                fsx = 19;
            }
            else if (lsx > 82)
            {
                fsx = 44;
            }
            fsy = 9;
        }
        else if (lsy == 211)
        {
            fsx = 27;
            fsy = 42;
        }
        else
        {
            fsx = 13 + tmp_y % 2 * 38;
            fsy = 22;
        }
    };
    
    function get_coordinate_of_clkdiv
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        if (lsx < 56)
        {
            fsx = 9 + lsy % 2;
        }
        else
        {
            fsx = 60 + lsy % 2;
        }
        fsy = 26;
    };
    
    function get_coordinate_of_clkdly
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        if (lsx < 54)
        {
            fsx = 10;
            fsy = 25 - (tmp_y % 2);
        }
        else if ((lsx == 66 || lsx == 67) && lsy < 12)
        {
            fsx = 32+(lsy%3);
            fsy = 9;
        }
        else if (lsx == 66 && lsy == 204)
        {
            fsx = 32;
            fsy = 40;
        }
        else
        {
            fsx = 60;
            fsy = 25-(lsy%2);
        }
    };
    
    function get_coordinate_of_mfgtest
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        fsx = 11;
        fsy = 30;
    };
    
    function get_coordinate_of_ldo
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        if (lsx < 10)
        {
            fsx = 11;
            fsy = 29;
        }
        else
        {
            fsx = 51;
            fsy = 9;
        }
    };
    
    function get_coordinate_of_osc
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        fsx = 13;
        fsy = 28;
    };
    
    function get_coordinate_of_ccs
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        fsx = 11;
        fsy = 27;
    };
    
    
    ///*****Place CLM*****/
    function place_clm_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy, lsx1, lsy1;
        unsigned int lsx0, lsy0, fsx0, fsy0; 
    
        // device reference variables
        &device s0Ref, s0fl;
        &device s1Ref, s1fl;
        
        string strVar;
        
        lsx = tx * NUM_GRID_X + 3;
        lsy = ty * NUM_GRID_Y;
        
        lsx0 = lsx;
        lsy0 = lsy + 1;
        
        s0Ref  = <device CLMS  @[lsx0, lsy0]     of ARCHITECTURE>;
        sprintf(strVar, "CLMS_%d_%d", lsx0, lsy0);
        
        get_coordinate_of_clm(lsx0, lsy0);
        
        s0fl = device CLMS ( structure fp_struct ) *strVar @[fsx, fsy];
        //printf("%s: %d, %d.", strVar, fsx, fsy);
        
        lsx1 = lsx;
        lsy1 = lsy;
        
        s1Ref  = <device CLMA  @[lsx1, lsy1]     of ARCHITECTURE>;
        sprintf(strVar, "CLMA_%d_%d", lsx1, lsy1);
        
        get_coordinate_of_clm(lsx1, lsy1);
        
        //printf("%s: %d, %d.", strVar, fsx, fsy);
        s1fl = device CLMA ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref,
              s1fl => s1Ref );
        
    }; // end of function place_clm_tile_fp
    
    
    function draw_clm_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0, lsx1, lsy1;
    
        // device reference variables
        &device s0Ref, s0fl;
        &device s1Ref, s1fl;
        
        string strVar;
        
        lsx = tx * NUM_GRID_X + 3;
        lsy = ty * NUM_GRID_Y;
        
        lsx0 = lsx;
        lsy0 = lsy;
        
        unsigned int offset_y = 0;
        get_coordinate_of_clm(lsx0, lsy0);
        if (fsy > 26)    
        {
            offset_y = 320;
        }
        
        // Instantiate the device. 
        sprintf(strVar, "CLMA_%d_%d", lsx0, lsy0);
        s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s0fl = device CLMA ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
         
        lsx1 = lsx;
        lsy1 = lsy + 1;
        
        offset_y = 0;
        get_coordinate_of_clm(lsx1, lsy1);
        if (fsy > 26)    
        {
            offset_y = 320;
        }
        
        // Instantiate the device. 
        sprintf(strVar, "CLMS_%d_%d", lsx1, lsy1);
        s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s1fl = device CLMS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
        
        map ( s0fl => s0Ref,
              s1fl => s1Ref );
              
    }; // end of function draw_clm_tile_fp
    
    function place_clmss_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        unsigned int lsx1, lsy1; 
    
        // device reference variables
        &device s0Ref, s0fl;
        &device s1Ref, s1fl;
        
        string strVar;
        
        lsx = tx * NUM_GRID_X + 3;
        lsy = ty * NUM_GRID_Y;
        
        lsx0 = lsx;
        lsy0 = lsy + 1;
        
        s0Ref  = <device CLMS  @[lsx0, lsy0]     of ARCHITECTURE>;
        sprintf(strVar, "CLMS_%d_%d", lsx0, lsy0);
        
        get_coordinate_of_clm(lsx0, lsy0);
        
        s0fl = device CLMS ( structure fp_struct ) *strVar @[fsx, fsy];
        //printf("%s: %d, %d.", strVar, fsx, fsy);
        
        lsx1 = lsx;
        lsy1 = lsy;
        
        s1Ref  = <device CLMS  @[lsx1, lsy1]     of ARCHITECTURE>;
        sprintf(strVar, "CLMS_%d_%d", lsx1, lsy1);
        
        get_coordinate_of_clm(lsx1, lsy1);
        
        //printf("%s: %d, %d.", strVar, fsx, fsy);
        s1fl = device CLMS ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref,
              s1fl => s1Ref );
        
    }; // end of function place_clmss_tile_fp
    
    
    function draw_clmss_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0, lsx1, lsy1;
    
        // device reference variables
        &device s0Ref, s0fl;
        &device s1Ref, s1fl;
        
        string strVar;
        
        lsx = tx * NUM_GRID_X + 3;
        lsy = ty * NUM_GRID_Y;
        
        lsx0 = lsx;
        lsy0 = lsy;
        
        lsx1 = lsx;
        lsy1 = lsy + 1;
        
        unsigned int offset_y = 0;
        get_coordinate_of_clm(lsx0, lsy0);
        if (fsy > 26)    
        {
            offset_y = 320;
        }
        
        // Instantiate the device. 
        sprintf(strVar, "CLMS_%d_%d", lsx0, lsy0);
        s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s0fl = device CLMS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
         
        offset_y = 0;
        get_coordinate_of_clm(lsx1, lsy1);
        if (fsy > 26)    
        {
            offset_y = 320;
        }
        
        // Instantiate the device. 
        sprintf(strVar, "CLMS_%d_%d", lsx1, lsy1);
        s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s1fl = device CLMS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
        
        map ( s0fl => s0Ref,
              s1fl => s1Ref );
              
    }; // end of function draw_clmss_tile_fp
    
    //    ///*****Place DRM*****/
    function place_drm_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = tx * NUM_GRID_X + 3;
        lsy0 = ty * NUM_GRID_Y;
        
        lsx = lsx0 + 2;
        lsy = lsy0;
        
        s0Ref  = <device DRM  @[lsx,lsy]     of ARCHITECTURE>;
        
        sprintf(strVar, "DRM_%d_%d", lsx, lsy);
        
        get_coordinate_of_drm(lsx, lsy);
        
        //printf("%s: %d, %d.", strVar, fsx, fsy);
        s0fl = device DRM ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref);
    } // end of function place_drm_tile_fp
    
    ///*****Draw DRM*****/
    function draw_drm_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        unsigned int offset_x = 0;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = tx * NUM_GRID_X + 3;
        lsy0 = ty * NUM_GRID_Y;
        
        lsx = lsx0 + 2;
        lsy = lsy0;
        
        unsigned int offset_y = 0;
        get_coordinate_of_drm(lsx, lsy);
        if (fsy > 26)    
        {
            offset_y = 320;
        }
        
        // Instantiate the device. 
        sprintf(strVar, "DRM_%d_%d", lsx, lsy);
        s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s0fl = device DRM ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
        map ( s0fl => s0Ref);
    }; // end of function draw_drm_tile_fp
    
    
    ///*****Place DLL*****/
    function place_dll_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = tx * NUM_GRID_X + 3;
        lsy0 = ty * NUM_GRID_Y;
        
        lsx = lsx0;
        lsy = lsy0;
        
        s0Ref  = <device DLL  @[lsx,lsy]     of ARCHITECTURE>;
        
        sprintf(strVar, "DLL_%d_%d", lsx, lsy);
    
        get_coordinate_of_dll(lsx, lsy);
        
        //printf("%s: %d, %d.", strVar, fsx, fsy);
        s0fl = device DLL ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref);
        
        
    }; // end of function place_dll_tile_fp
    
    ///*****Draw DLL*****/
    function draw_dll_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        lsx0 = tx * NUM_GRID_X + 3;
        lsy0 = ty * NUM_GRID_Y;
        
        lsx = lsx0;
        lsy = lsy0;
        unsigned int offset_y = 0;
        get_coordinate_of_dll(lsx, lsy);
        if (fsy > 26)    
        {
            offset_y = 320;
        }
        
        // Instantiate the device. 
        sprintf(strVar, "DLL_%d_%d", lsx, lsy);
        s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s0fl = device DLL ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
        map ( s0fl => s0Ref);
   }; // end of function draw_dll_tile_fp
   
   
    ///*****Place PLL*****/
    function place_pll_tile_fp
    ( 
        unsigned int PLL_TILE_X,
        unsigned int PLL_TILE_Y
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = PLL_TILE_X * NUM_GRID_X + 3;
        lsy0 = PLL_TILE_Y * NUM_GRID_Y;
        
        lsx = lsx0 + 2;
        lsy = lsy0 + 8;
        
        s0Ref  = <device PLL  @[lsx,lsy]     of ARCHITECTURE>;
        
        sprintf(strVar, "PLL_%d_%d", lsx, lsy);
    
        get_coordinate_of_pll(lsx, lsy);
        
        //printf("%s: %d, %d.", strVar, fsx, fsy);
        s0fl = device PLL ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref);
    } // end of function place_drm_tile_fp
    
    
    ///*****Draw PLL*****/
    function draw_pll_tile_fp
    ( 
        unsigned int PLL_TILE_X,
        unsigned int PLL_TILE_Y
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = PLL_TILE_X * NUM_GRID_X + 3;
        lsy0 = PLL_TILE_Y * NUM_GRID_Y;
        
        lsx = lsx0 + 2;
        lsy = lsy0 + 8;
        
        unsigned int offset_y = 0;
        get_coordinate_of_pll(lsx, lsy);
        if (fsy > 26)    
        {
            offset_y = 320;
        }
        
        // Instantiate the device. 
        sprintf(strVar, "PLL_%d_%d", lsx, lsy);
        s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s0fl = device PLL ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
        map ( s0fl => s0Ref);
    }; // end of function draw_pll_tile_fp
    
    ///*****Place CCS*****/
    function place_ccs_4k_tile_fp
    ( 
        unsigned int CCS_TILE_X,
        unsigned int CCS_TILE_Y,
        unsigned int PLL_TILE_X,
        unsigned int ccs_value1,
        unsigned int ccs_value2,
        unsigned int ccs_value3
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = CCS_TILE_X * NUM_GRID_X + 3;
        lsy0 = CCS_TILE_Y * NUM_GRID_Y;
        
        lsx = lsx0 + 1;
        lsy = lsy0;
        
        s0Ref  = <device CCS  @[lsx,lsy]     of ARCHITECTURE>;
        sprintf(strVar, "CCS_%d_%d", lsx, lsy);
    
        get_coordinate_of_ccs(lsx, lsy);
        
        //printf("%s: %d, %d.", strVar, fsx, fsy);
        s0fl = device CCS ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref);
    } // end of function place_ccs_4k_tile_fp
    
    ///*****Draw CCS*****/
    function draw_ccs_4k_tile_fp
    ( 
        unsigned int CCS_TILE_X,
        unsigned int CCS_TILE_Y,
        unsigned int PLL_TILE_X,
        unsigned int ccs_value1,
        unsigned int ccs_value2,
        unsigned int ccs_value3
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = CCS_TILE_X * NUM_GRID_X + 3;
        lsy0 = CCS_TILE_Y * NUM_GRID_Y;
        
        lsx = lsx0 + 1;
        lsy = lsy0;
        
        unsigned int offset_y = 0;
        get_coordinate_of_ccs(lsx, lsy);
        if (fsy > 26)    
        {
            offset_y = 320;
        }
        
        // Instantiate the device. 
        sprintf(strVar, "CCS_%d_%d", lsx, lsy);
        s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s0fl = device CCS ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
        map ( s0fl => s0Ref);
    }; // end of function draw_ccs_4k_tile_fp
    
    
    // place OSC and MFG_TEST
    function place_analog_tile_fp 
    ( 
        unsigned int ANALOG_TILE_X, 
        unsigned int ANALOG_TILE_Y, 
        unsigned int CCS_TILE_Y, 
        unsigned int analog_value
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        unsigned int indexs[] = {0, 1};
        unsigned int i;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = ANALOG_TILE_X * NUM_GRID_X + 3;
        lsy0 = ANALOG_TILE_Y * NUM_GRID_Y;
        
        foreach i (indexs)
        {
            if (i == 0)
            {
                lsx = lsx0 + 2;
                lsy = lsy0;
                
                s0Ref  = <device OSC  @[lsx,lsy]     of ARCHITECTURE>;
                sprintf(strVar, "OSC_%d_%d", lsx, lsy);
                
                get_coordinate_of_osc(lsx, lsy);
                
                //printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device OSC ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            else if (i == 1)
            {
                lsx = lsx0 + 2;
                lsy = lsy0 + 1;
                
                s0Ref  = <device MFG_TEST  @[lsx,lsy]     of ARCHITECTURE>;
                sprintf(strVar, "MFG_TEST_%d_%d", lsx, lsy);
                
                get_coordinate_of_mfgtest(lsx, lsy);
                
                //printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device MFG_TEST ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
        }
    };
    
    // draw OSC and MFG_TEST
    function draw_analog_tile_fp 
    ( 
        unsigned int ANALOG_TILE_X, 
        unsigned int ANALOG_TILE_Y, 
        unsigned int CCS_TILE_Y, 
        unsigned int analog_value
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        unsigned int indexs[] = {0, 1};
        unsigned int i;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = ANALOG_TILE_X * NUM_GRID_X + 3;
        lsy0 = ANALOG_TILE_Y * NUM_GRID_Y;
        
        foreach i (indexs)
        {
            ///***OSC***/
            if (i == 0)
            {
                lsx = lsx0 + 2;
                lsy = lsy0;
                
                unsigned int offset_y = 0;
                get_coordinate_of_osc(lsx, lsy);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }
        
                // Instantiate the device. 
                sprintf(strVar, "OSC_%d_%d", lsx, lsy);
                s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
                s0fl = device OSC ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref);
            }
            else if (i == 1)
            {
                lsx = lsx0 + 2;
                lsy = lsy0 + 1;
                
                unsigned int offset_y = 0;
                get_coordinate_of_mfgtest(lsx, lsy);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }
                
                // Instantiate the device. 
                sprintf(strVar, "MFG_TEST_%d_%d", lsx, lsy);
                s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
                s0fl = device MFG_TEST ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref);
            }
        }
    };
    
    ///*****place USCM*****/
    unsigned int L_USCM_TILES_X[] = {USCM_TILE_X};
    unsigned int L_USCM_TILES_Y[] = {USCM_TILE_Y};
    int tx_srb = USCM_TILE_X - 1;
    int ty_srb = USCM_TILE_Y - 2;
    
    function place_uscm_tile_fp
    ( 
        unsigned int tx, 
        unsigned int ty, 
        unsigned int tx_srb, 
        unsigned int ty_srb
    )     
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        unsigned int indexs_USCMD[] = {0, 1};
        unsigned int indexs_IOCKBRG[] = {0, 1};
        unsigned int indexs_USCMDC[] = {0, 1, 2, 3, 4, 5, 6, 7};
        unsigned int i;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = tx * NUM_GRID_X;
        lsy0 = ty * NUM_GRID_Y;
        
        ///***USCMD***/
        foreach i (indexs_USCMD)
        {
            lsx = lsx0 + 1;
            lsy = lsy0 + 12 + i;
            
            s0Ref  = <device USCMD  @[lsx, lsy]     of ARCHITECTURE>;
            
            sprintf(strVar, "USCMD_%d_%d", lsx, lsy);
            
            get_coordinate_of_uscmd(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device USCMD ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        
        ///***USCMDC***/
        foreach i (indexs_USCMDC)
        {
            
            if (i < 4)
            {
                lsx = lsx0 + 1;
                lsy = lsy0 + 14 + i;
            }
            else
            {
                lsx = lsx0 + 2;
                lsy = lsy0 + (i - 4);
            }
            
            s0Ref  = <device USCMDC  @[lsx,lsy]     of ARCHITECTURE>;
            
            sprintf(strVar, "USCMDC_%d_%d", lsx, lsy);
            
            get_coordinate_of_uscmdc(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device USCMDC ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        
        ///***IOCKBRG***/
        foreach i (indexs_IOCKBRG)
        {
            lsx = lsx0 + 4;
            lsy = lsy0 + 5 + i;
            
            s0Ref  = <device IOCKBRG  @[lsx,lsy]     of ARCHITECTURE>;
            
            sprintf(strVar, "IOCKBRG_%d_%d", lsx, lsy);
            
            get_coordinate_of_iockbrg(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device IOCKBRG ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
    };
    
    ///*****draw USCM*****/
    function draw_uscm_tile_fp
    ( 
        unsigned int tx, 
        unsigned int ty, 
        unsigned int tx_srb, 
        unsigned int ty_srb
    )     
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        unsigned int indexs_USCMD[] = {0, 1};
        unsigned int indexs_IOCKBRG[] = {0, 1};
        unsigned int indexs_USCMDC[] = {0, 1, 2, 3, 4, 5, 6, 7};
        unsigned int i;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = tx * NUM_GRID_X;
        lsy0 = ty * NUM_GRID_Y;
        
        ///***USCMD***/
        foreach i (indexs_USCMD)
        {
            lsx = lsx0 + 1;
            lsy = lsy0 + 12 + i;
            
            unsigned int offset_y = 0;
            get_coordinate_of_uscmd(lsx, lsy);
            if (fsy > 26)    
            {
                offset_y = 320;
            }
            
            // Instantiate the device. 
            sprintf(strVar, "USCMD_%d_%d", lsx, lsy);
            s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s0fl = device USCMD ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
        }
        
        ///***USCMDC***/
        foreach i (indexs_USCMDC)
        {
            if (i < 4)
            {
                lsx = lsx0 + 1;
                lsy = lsy0 + 14 + i;
            }
            else
            {
                lsx = lsx0 + 2;
                lsy = lsy0 + (i - 4);
            }
            
            unsigned int offset_y = 0;
            get_coordinate_of_uscmdc(lsx, lsy);
            if (fsy > 26)    
            {
                offset_y = 320;
            }
            
            // Instantiate the device. 
            sprintf(strVar, "USCMDC_%d_%d", lsx, lsy);
            s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s0fl = device USCMDC ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
        }
        
        ///***IOCKBRG***/
        foreach i (indexs_IOCKBRG)
        {
            lsx = lsx0 + 4;
            lsy = lsy0 + 5 + i;
            
            s0Ref  = <device IOCKBRG  @[lsx,lsy]     of ARCHITECTURE>;
            
            sprintf(strVar, "IOCKBRG_%d_%d", lsx, lsy);
            
            unsigned int offset_y = 0;
            get_coordinate_of_iockbrg(lsx, lsy);
            if (fsy > 26)    
            {
                offset_y = 320;
            }
            
            // Instantiate the device. 
            s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s0fl = device IOCKBRG ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
            
        }
    };
    
    
    ///*****Place IOCK RIGHT*****/
    function place_iock_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        unsigned int indexs0[] = {0, 1};
        unsigned int i;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = tx * NUM_GRID_X + 3;
        lsy0 = ty * NUM_GRID_Y;
        
        /***IOCKGATE***/
        foreach i (indexs0)
        {
            lsx = lsx0;
            lsy = lsy0 + 15 + i;
            
            s0Ref  = <device IOCKGATE  @[lsx,lsy]     of ARCHITECTURE>;
            
            sprintf(strVar, "IOCKGATE_%d_%d", lsx, lsy);
            
            get_coordinate_of_iockgate(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device IOCKGATE ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        
        ///***CLKDIV***/
        foreach i (indexs0)
        {
            lsx = lsx0 + i;
            lsy = lsy0 + 17 * (1 - i);
            
            s0Ref  = <device CLKDIV  @[lsx,lsy]     of ARCHITECTURE>;
            
            sprintf(strVar, "CLKDIV_%d_%d", lsx, lsy);
            
            get_coordinate_of_clkdiv(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device CLKDIV ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        
        ///***CLKDLY***/
        foreach i (indexs0)
        {
            lsx = lsx0 + 1;
            lsy = lsy0 + 1 + i;
            
            s0Ref  = <device CLKDLY  @[lsx,lsy]     of ARCHITECTURE>;
            
            sprintf(strVar, "CLKDLY_%d_%d", lsx, lsy);
             
            get_coordinate_of_clkdly(lsx, lsy);  
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device CLKDLY ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
    }; // end of function place_ckeb_tile_fp
    
    ///*****Draw IOCK RIGHT*****/
    function draw_iock_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        unsigned int indexs0[] = {0, 1};
        unsigned int i;
        int offset_x;
        
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = tx * NUM_GRID_X + 3;
        lsy0 = ty * NUM_GRID_Y;
       
        ///***IOCKGATE***/
        foreach i (indexs0)
        {
            lsx = lsx0;
            lsy = lsy0 + 15 + i;
            
            s0Ref  = <device IOCKGATE  @[lsx,lsy]     of ARCHITECTURE>;
            
            sprintf(strVar, "IOCKGATE_%d_%d", lsx, lsy);
            
            unsigned int offset_y = 0;
            get_coordinate_of_iockgate(lsx, lsy);
            if (fsy > 26)    
            {
                offset_y = 320;
            }
        
            // Instantiate the device. 
            sprintf(strVar, "IOCKGATE_%d_%d", lsx, lsy);
            s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s0fl = device IOCKGATE ( symbol fpsym ) *strVar @[(fsx+1)*160+80*i, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
        }
        
        ///***CLKDIV***/
        foreach i (indexs0)
        {
            lsx = lsx0 + i;
            lsy = lsy0 + 17 * (1 - i);
            
            s0Ref  = <device CLKDIV  @[lsx,lsy]     of ARCHITECTURE>;
            sprintf(strVar, "CLKDIV_%d_%d", lsx, lsy);
            
            unsigned int offset_y = 0;
            get_coordinate_of_clkdiv(lsx, lsy);
            if (fsy > 26)    
            {
                offset_y = 320;
            }
            
            s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s0fl = device CLKDIV ( symbol fpsym ) *strVar @[(fsx+1)*160+80*i, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
        }
        
        ///***CLKDLY***/
        foreach i (indexs0)
        {
            lsx = lsx0 + 1;
            lsy = lsy0 + 1 + i;
            
            s0Ref  = <device CLKDLY  @[lsx,lsy]     of ARCHITECTURE>;
            sprintf(strVar, "CLKDLY_%d_%d", lsx, lsy);
            
            unsigned int offset_y = 0;
            get_coordinate_of_clkdly(lsx, lsy);
            if (fsy > 26)    
            {
                offset_y = 320;
            }
            
            s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s0fl = device CLKDLY ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
        }
    }; // end of function draw_iock_tile_fp
    
    
    ///*****Place IOCK LEFT*****/
    function place_iock_7k_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        unsigned int indexs0[] = {0, 1};
        unsigned int i;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = tx * NUM_GRID_X + 3;
        lsy0 = ty * NUM_GRID_Y;
        
        /***IOCKGATE***/
        foreach i (indexs0)
        {
            lsx = lsx0;
            lsy = lsy0 + 15 + i;
            
            s0Ref  = <device IOCKGATE  @[lsx,lsy]     of ARCHITECTURE>;
            
            sprintf(strVar, "IOCKGATE_%d_%d", lsx, lsy);
            
            get_coordinate_of_iockgate(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device IOCKGATE ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        
        ///***CLKDIV***/
        foreach i (indexs0)
        {
            lsx = lsx0 + i;
            lsy = lsy0 + 17 * (1 - i);
            
            s0Ref  = <device CLKDIV  @[lsx,lsy]     of ARCHITECTURE>;
            
            sprintf(strVar, "CLKDIV_%d_%d", lsx, lsy);
            
            get_coordinate_of_clkdiv(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device CLKDIV ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        
        ///***CLKDLY***/
        foreach i (indexs0)
        {
            lsx = lsx0 + 1;
            lsy = lsy0 + 1 + i;
            
            s0Ref  = <device CLKDLY  @[lsx,lsy]     of ARCHITECTURE>;
            
            sprintf(strVar, "CLKDLY_%d_%d", lsx, lsy);
            
            get_coordinate_of_clkdly(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device CLKDLY ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
    }; // end of function place_ckeb_7k_tile_fp
    
    ///*****Draw IOCK LEFT*****/
    function draw_iock_7k_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        unsigned int indexs0[] = {0, 1};
        unsigned int i;
        int offset_x;
        
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = tx * NUM_GRID_X + 3;
        lsy0 = ty * NUM_GRID_Y;
       
        ///***IOCKGATE***/
        foreach i (indexs0)
        {
            lsx = lsx0;
            lsy = lsy0 + 15 + i;
            
            s0Ref  = <device IOCKGATE  @[lsx,lsy]     of ARCHITECTURE>;
            
            sprintf(strVar, "IOCKGATE_%d_%d", lsx, lsy);
            
            unsigned int offset_y = 0;
            get_coordinate_of_iockgate(lsx, lsy);
            if (fsy > 26)    
            {
                offset_y = 320;
            }
            
            // Instantiate the device. 
            s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s0fl = device IOCKGATE ( symbol fpsym ) *strVar @[(fsx+1)*160+80*i, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
        }
        
        ///***CLKDIV***/
        foreach i (indexs0)
        {
            lsx = lsx0 + i;
            lsy = lsy0 + 17 * (1 - i);
            
            s0Ref  = <device CLKDIV  @[lsx,lsy]     of ARCHITECTURE>;
           
            // Instantiate the device. 
            sprintf(strVar, "CLKDIV_%d_%d", lsx, lsy);
            
            unsigned int offset_y = 0;
            get_coordinate_of_clkdiv(lsx, lsy);
            if (fsy > 26)    
            {
                offset_y = 320;
            }
            
            s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s0fl = device CLKDIV ( symbol fpsym ) *strVar @[(fsx+1)*160+80*i, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
        }
        
        ///***CLKDLY***/
        foreach i (indexs0)
        {
            lsx = lsx0 + 1;
            lsy = lsy0 + 1 + i;
            
            s0Ref  = <device CLKDLY  @[lsx,lsy]     of ARCHITECTURE>;
            
            // Instantiate the device. 
            sprintf(strVar, "CLKDLY_%d_%d", lsx, lsy);
            
            unsigned int offset_y = 0;
            get_coordinate_of_clkdly(lsx, lsy);
            if (fsy > 26)    
            {
                offset_y = 320;
            }
            
            s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s0fl = device CLKDLY ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
        }
    }; // end of function draw_iock_7k_tile_fp
    
    ///*****Place CLKDLY*****/
    function place_clkdlyb_tile_fp
    ( 
        unsigned int CLKDLY_TILE_X, 
        unsigned int CLKDLYB_TILE_Y
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        unsigned int offset_x[2:0] = {1, 0, 0};
        unsigned int offset_y[2:0] = {2, 4, 0};
        unsigned int indexs[] = {0, 1, 2};
        unsigned int i;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = CLKDLY_TILE_X * NUM_GRID_X;
        lsy0 = CLKDLYB_TILE_Y * NUM_GRID_Y;
        
        ///***CLKDLY***/
        foreach i (indexs)
        {
            lsx = lsx0 + offset_x[i];
            lsy = lsy0 + offset_y[i];
            
            s0Ref  = <device CLKDLY  @[lsx,lsy]     of ARCHITECTURE>;
            sprintf(strVar, "CLKDLY_%d_%d", lsx, lsy);
            
            get_coordinate_of_clkdly(lsx, lsy);
        
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device CLKDLY ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
    };
    
    ///*****draw CLKDLY*****/
    function draw_clkdlyb_tile_fp
    ( 
        unsigned int CLKDLY_TILE_X, 
        unsigned int CLKDLYB_TILE_Y
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        unsigned int offset_x[2:0] = {1, 0, 0};
        unsigned int offset_y[2:0] = {2, 4, 0};
        unsigned int indexs[] = {0, 1, 2};
        unsigned int i;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        ///***CLKDLY***/
        foreach i (indexs)
        {
            lsx0 = CLKDLY_TILE_X * NUM_GRID_X;
            lsy0 = CLKDLYB_TILE_Y * NUM_GRID_Y;
            
            lsx = lsx0 + offset_x[i];
            lsy = lsy0 + offset_y[i];
            
            // Instantiate the device. 
            sprintf(strVar, "CLKDLY_%d_%d", lsx, lsy);
            
            unsigned int offset_y = 0;
            get_coordinate_of_clkdly(lsx, lsy);
            if (fsy > 26)    
            {
                offset_y = 320;
            }
            
            s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s0fl = device CLKDLY ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
        }
    };
    
    function place_clkdlyt_tile_fp
    ( 
        unsigned int CLKDLY_TILE_X, 
        unsigned int CLKDLYT_TILE_Y
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = CLKDLY_TILE_X * NUM_GRID_X;
        lsy0 = CLKDLYT_TILE_Y * NUM_GRID_Y;
        
        ///***CLKDLY***/
        lsx = lsx0;
        lsy = lsy0;
        
        s0Ref  = <device CLKDLY  @[lsx,lsy]     of ARCHITECTURE>;
        sprintf(strVar, "CLKDLY_%d_%d", lsx, lsy);
    
        get_coordinate_of_clkdly(lsx, lsy);
        
        //printf("%s: %d, %d.", strVar, fsx, fsy);
        s0fl = device CLKDLY ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref);
    };
    
    function draw_clkdlyt_tile_fp
    ( 
        unsigned int CLKDLY_TILE_X, 
        unsigned int CLKDLYT_TILE_Y
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        ///***CLKDLY***/
        lsx0 = CLKDLY_TILE_X * NUM_GRID_X;
        lsy0 = CLKDLYT_TILE_Y * NUM_GRID_Y;
        
        lsx = lsx0;
        lsy = lsy0;
        
        // Instantiate the device. 
        sprintf(strVar, "CLKDLY_%d_%d", lsx, lsy);
        
        unsigned int offset_y = 0;
        get_coordinate_of_clkdly(lsx, lsy);
        if (fsy > 26)    
        {
            offset_y = 320;
        }
        
        s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s0fl = device CLKDLY ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
        map ( s0fl => s0Ref);
    };
    
    
    ///*****Place IOL*****/
    function place_iol_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty,
        unsigned int flag
    )
    {
        // device reference variables
        &device s0Ref, s1Ref, s2Ref, s3Ref, s0fl, s1fl, s2fl, s3fl;
        
        string strVar;
        if (flag == 2)
        {
            // Site index variable. The X index for logic and GUI are declared separately
            unsigned int gsx, gsy, lsx, lsy;
            unsigned int i;
            unsigned int indexs[] = {1, 2, 3, 4};
        
            unsigned int lsx1, lsy1;
            ///*****IOL*****/
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X + 3;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1 + 1;
                lsy = lsy1 + i;
                
                s0Ref  = <device IOL  @[lsx, lsy]     of ARCHITECTURE>;
                sprintf(strVar, "IOL_%d_%d", lsx, lsy);
                
                get_coordinate_of_iol(lsx, lsy);
                
                //printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOL ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            ///*****IOLDLYS*****///
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X + 3;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1;
                lsy = lsy1 + i;
                
                s0Ref  = <device IOLDLYS  @[lsx, lsy]     of ARCHITECTURE>;
                sprintf(strVar, "IOLDLYS_%d_%d", lsx, lsy);
            
                get_coordinate_of_ioldly(lsx, lsy);
                
                //printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOLDLYS ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            ///*****OSERDES*****///
            lsx1 = tx * NUM_GRID_X + 3;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1 + 1;
            lsy = lsy1 + 5;
            
            s0Ref  = <device OSERDES  @[lsx, lsy]     of ARCHITECTURE>;
            sprintf(strVar, "OSERDES_%d_%d", lsx, lsy);
            
            get_coordinate_of_oserdes(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device OSERDES ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        ///*****RIGHT*****///
        else if (flag == 3)
        {
            // Site index variable. The X index for logic and GUI are declared separately
            unsigned int gsx, gsy, lsx, lsy;
            unsigned int i;
            unsigned int indexs[] = {1, 2, 3, 4};
        
            unsigned int lsx1, lsy1;
            ///*****IOL*****/
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X + 3;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1 + 1;
                lsy = lsy1 + i;
                
                s0Ref  = <device IOL  @[lsx, lsy]     of ARCHITECTURE>;
                sprintf(strVar, "IOL_%d_%d", lsx, lsy);
                
                get_coordinate_of_iol(lsx, lsy);
                
                //printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOL ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            ///*****IOLDLY*****///
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X + 3;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1;
                lsy = lsy1 + i;
                
                s0Ref  = <device IOLDLY  @[lsx, lsy]     of ARCHITECTURE>;
                sprintf(strVar, "IOLDLY_%d_%d", lsx, lsy);
            
                get_coordinate_of_ioldly(lsx, lsy);
                
                //printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOLDLY ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            ///*****ISERDES*****///
            lsx1 = tx * NUM_GRID_X + 3;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1 + 1;
            lsy = lsy1 + 5;
            
            s0Ref  = <device ISERDES  @[lsx, lsy]     of ARCHITECTURE>;
            sprintf(strVar, "ISERDES_%d_%d", lsx, lsy);
            
            get_coordinate_of_iserdes(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device ISERDES ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        else if (flag == 0 || flag == 1 || flag == 4 || flag == 5)
        {
            // Site index variable. The X index for logic and GUI are declared separately
            unsigned int gsx, gsy, lsx, lsy;
            unsigned int i;
            unsigned int indexs[] = {1, 2, 3, 4};
        
            unsigned int lsx1, lsy1;
            
            ///*****IOL*****/
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X + 3;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1 + 1;
                lsy = lsy1 + i;
                
                s0Ref  = <device IOL  @[lsx, lsy]     of ARCHITECTURE>;
                sprintf(strVar, "IOL_%d_%d", lsx, lsy);

                get_coordinate_of_iol(lsx, lsy);
                
                //printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOL ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            ///*****IOLDLYS*****///
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X + 3;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1;
                lsy = lsy1 + i;
                
                s0Ref  = <device IOLDLYS  @[lsx, lsy]     of ARCHITECTURE>;
                sprintf(strVar, "IOLDLYS_%d_%d", lsx, lsy);
            
                get_coordinate_of_ioldly(lsx, lsy);
                
                //printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOLDLYS ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
        }
    }; // end of function place_iol_tile_fp
    
    
    function draw_iol_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty,
        unsigned int flag
    )
    {
        unsigned int lsx, lsy;
        
        // device reference variables
        &device s0Ref, s1Ref, s2Ref, s0fl, s1fl, s2fl;
        
        lsx = tx * NUM_GRID_X + 3;
        lsy = ty * NUM_GRID_Y;
        
        string strVar;
        
        // Instantiate the device.
        unsigned int i; 
        unsigned int indexs[] = {1, 2, 3, 4};
        unsigned int lsx1, lsy1;
        
        if (flag == 2)
        {
            foreach i (indexs)
            {
                lsx1 = lsx + 1;
                lsy1 = lsy + i;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iol(lsx1, lsy1);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }
                
                sprintf(strVar, "IOL_%d_%d", lsx1, lsy1);
                s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
                s0fl = device IOL ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                
                offset_y = 0;
                get_coordinate_of_ioldly(lsx, lsy1);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }
                
                sprintf(strVar, "IOLDLYS_%d_%d", lsx, lsy1);
                s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
                s1fl = device IOLDLYS ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref,
                      s1fl => s1Ref);
                      
                if (i == 1) 
                {
                    lsx1 = lsx + 1;
                    lsy1 = lsy + 5; 
                    
                    unsigned int offset_y = 0;
                    get_coordinate_of_oserdes(lsx1, lsy1);
                    if (fsy > 26)    
                    {
                        offset_y = 320;
                    }
                    
                    sprintf(strVar, "OSERDES_%d_%d", lsx1, lsy1);
                    s2Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
                    s2fl = device OSERDES ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                    map ( s2fl => s2Ref);
                }
            }
        }
        else if (flag == 3)
        {
            foreach i (indexs)
            {
                lsx1 = lsx + 1;
                lsy1 = lsy + i;
                
                unsigned int tmp_x = lsx1;
                unsigned int tmp_y = lsy1;
                
                
                unsigned int offset_y = 0;
                get_coordinate_of_iol(lsx1, lsy1);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }
                
                sprintf(strVar, "IOL_%d_%d", lsx1, lsy1);
                s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
                s0fl = device IOL ( schematic floorplan_view ) *strVar @[(fsx+1)*160+40, (fsy+1)*320+offset_y];
                
                offset_y = 0;
                get_coordinate_of_ioldly(lsx, lsy1);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }
                
                sprintf(strVar, "IOLDLY_%d_%d", lsx, lsy1);
                s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
                s1fl = device IOLDLY ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref,
                      s1fl => s1Ref);
                      
                if (i == 1) 
                {
                    lsx1 = lsx + 1;
                    lsy1 = lsy + 5; 
                    
                    unsigned int offset_y = 0;
                    get_coordinate_of_iserdes(lsx1, lsy1);
                    if (fsy > 26)    
                    {
                        offset_y = 320;
                    }
                    
                    sprintf(strVar, "ISERDES_%d_%d", lsx1, lsy1);
                    s2Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
                    s2fl = device ISERDES ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                    map ( s2fl => s2Ref);
                }
            }
        }
        else if (flag == 0 || flag == 1 || flag == 4 || flag == 5)
        {
            unsigned int offset_x = 0;
            foreach i (indexs)
            {
                lsx1 = lsx + 1;
                lsy1 = lsy + i;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iol(lsx1, lsy1);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }
                
                sprintf(strVar, "IOL_%d_%d", lsx1, lsy1);
                s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
                s0fl = device IOL ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                
                offset_y = 0;
                get_coordinate_of_ioldly(lsx, lsy1);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }    
                
                sprintf(strVar, "IOLDLYS_%d_%d", lsx, lsy1);
                s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
                s1fl = device IOLDLYS ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                
                map ( s0fl => s0Ref,
                      s1fl => s1Ref);
            }
        }  
    }; // end of function draw_iol_tile_fp
    
    
    ///*****IOBS *BSD_N**** */
    function place_iobs_bsd_n
    (
        unsigned int tx,
        unsigned int ty,
        unsigned int indexs[]
    )
    {
        unsigned int lsx1, lsy1;
        unsigned int lsx, lsy;
        unsigned int i;
        unsigned int offset_iobsdn[17:0] = {19, 25, 31, 43, 49, 55, 73, 79, 85, 91, 97, 139, 145, 151, 157, 163, 169, 181};
        
        // device reference variables
        &device s0Ref, s0fl;
        
        foreach i (indexs)
        {
            lsx1 = tx * NUM_GRID_X;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1;
            lsy = lsy1 + offset_iobsdn[i];
            
            s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
            string strVar;
            sprintf(strVar, "IOBS_%d_%d", lsx, lsy); 
            
            get_coordinate_of_iob(lsx, lsy);
                
            //printf("%s: %d, %d.", strVar, fsx, fsy);                 
            s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
    };
    
    ///***IOBD***///
    function place_iobs_bsd_p
    (
        unsigned int tx,
        unsigned int ty,
        unsigned int indexs[]
    )
    {
        unsigned int lsx1, lsy1;
        unsigned int lsx, lsy;
        unsigned int i;
        unsigned int offset_iobsdp[17:0] = {18, 24, 30, 42, 48, 54, 72, 78, 84, 90, 96, 138, 144, 150, 156, 162, 168, 180};
        
        // device reference variables
        &device s0Ref, s0fl;
        string strVar;
        
        foreach i (indexs)
        {
            lsx1 = tx * NUM_GRID_X;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1;
            lsy = lsy1 + offset_iobsdp[i];
            
            s0Ref  = <device IOBD  @[lsx, lsy]     of ARCHITECTURE>;
            sprintf(strVar, "IOBD_%d_%d", lsx, lsy);
               
            get_coordinate_of_iob(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device IOBD ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        
        
        lsx = tx * NUM_GRID_X;
        lsy = ty * NUM_GRID_Y;
        
        lsx = lsx + 1;
        lsy = lsy + 62;
            
        s0Ref  = <device BKCL  @[lsx, lsy]     of ARCHITECTURE>;
        sprintf(strVar, "BKCL_%d_%d", lsx, lsy);
        
        get_coordinate_of_bkcl(lsx, lsy);
        
        //printf("%s: %d, %d.", strVar, fsx, fsy);
        s0fl = device BKCL ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref);
    };
    
    ///*****IOBS *BSS_P*****/
    function place_iobs_bss_p
    (
        unsigned int tx,
        unsigned int ty,
        unsigned int indexs[]
    )
    {
        unsigned int lsx1, lsy1;
        unsigned int lsx, lsy;
        unsigned int i;
        unsigned int offset_iobssp[17:0] = {20, 26, 32, 44, 50, 56, 74, 80, 86, 92, 98, 140, 146, 152, 158, 164, 170, 182};
        
        // device reference variables
        &device s0Ref, s0fl;
        string strVar;
        
        foreach i (indexs)
        {
            lsx1 = tx * NUM_GRID_X;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1;
            lsy = lsy1 + offset_iobssp[i];
            
            s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
            sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
               
            get_coordinate_of_iob(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
    };
    
    ///*****IOBS *BSS_N*****/
    function place_iobs_bss_n
    (
        unsigned int tx,
        unsigned int ty,
        unsigned int indexs[]
    )
    {
        unsigned int lsx1, lsy1;
        unsigned int lsx, lsy;
        unsigned int i;
        unsigned int offset_iobssn[17:0] = {21, 27, 33, 45, 51, 57, 75, 81, 87, 93, 99, 141, 147, 153, 159, 165, 171, 183};
        
        // device reference variables
        &device s0Ref, s0fl;
        string strVar;
        foreach i (indexs)
        {
            lsx1 = tx * NUM_GRID_X;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1;
            lsy = lsy1 + offset_iobssn[i];
            
            s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
            sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
               
            get_coordinate_of_iob(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
    };
    
     ///*****IOB Left/
    function place_iobl_tile_fp
    (
        unsigned int tx,
        unsigned int ty
    )
    {
        unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};
        ///*****IOBS *BSD_N*****/
        place_iobs_bsd_n(tx, ty, indexs);
        
        ///*****IOBD *BSD_P*****/
        place_iobs_bsd_p(tx, ty, indexs);
        
        ///*****IOBS *BSS_P*****/
        place_iobs_bss_p(tx, ty, indexs);
        
        ///*****IOBS *BSS_N*****/
        place_iobs_bss_n(tx, ty, indexs);
    }
    
    ///*****IOBR *BSR_N*****/
    function place_iobr_bsr_n
    (
        unsigned int tx,
        unsigned int ty,
        unsigned int indexs[]
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx1, lsy1;
        unsigned int i;
        unsigned int offset_iobsrn[35:0] = {19, 21, 25, 27, 31, 33, 43, 45, 49, 51, 55, 57, 73, 75, 79, 81, 85, 87, 91, 93, 97, 99, 139, 141, 145, 147, 151, 153, 157, 159, 163, 165, 169, 171, 181, 183};
    
        // device reference variables
        &device s0Ref, s0fl;         
        string strVar;
        foreach i (indexs)
        {
            lsx1 = tx * NUM_GRID_X;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1;
            lsy = lsy1 + offset_iobsrn[i];
            
            s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
            string strVar;
            sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
            
            get_coordinate_of_iob(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
    };
    
    ///*****IOBR *BSR_P*****/
    function place_iobr_bsr_p
    (  
        unsigned int tx,
        unsigned int ty,
        unsigned int indexs[]
    )  
    {  
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx1, lsy1;
        unsigned int i;
        unsigned int offset_iobsrp[35:0] = {18, 20, 24, 26, 30, 32, 42, 44, 48, 50, 54, 56, 72, 74, 78, 80, 84, 86, 90, 92, 96, 98, 138, 140, 144, 146, 150, 152, 156, 158, 162, 164, 168, 170, 180, 182};
       
        // device reference variables
        &device s0Ref, s0fl;         
        string strVar;
        foreach i (indexs)
        {
            lsx1 = tx * NUM_GRID_X;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1;
            lsy = lsy1 + offset_iobsrp[i];
            
            s0Ref  = <device IOBR  @[lsx, lsy]     of ARCHITECTURE>;
            string strVar;
            sprintf(strVar, "IOBR_%d_%d", lsx, lsy);
               
            get_coordinate_of_iob(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device IOBR ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        
        lsx = tx * NUM_GRID_X;
        lsy = ty * NUM_GRID_Y;
        
        lsx = lsx + 1;
        lsy = lsy + 91;
            
        s0Ref  = <device BKCL  @[lsx, lsy]     of ARCHITECTURE>;
        sprintf(strVar, "BKCL_%d_%d", lsx, lsy);
        
        get_coordinate_of_bkcl(lsx, lsy);
        
        //printf("%s: %d, %d.", strVar, fsx, fsy);
        s0fl = device BKCL ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref);
    }; 
    
    ///*****IOB Right/
    function place_iobr_tile_fp
    (
        unsigned int tx,
        unsigned int ty
    )
    {
        unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35};
        
        ///*****IOBS *BSR_N*****/
        place_iobr_bsr_n(tx, ty, indexs);
        
        ///*****IOBR *BSR_P*****/
        place_iobr_bsr_p(tx, ty, indexs);
    };
    
    ///*****Place IOB*****/  
    function place_ioblr_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty,
        unsigned int flag
    )
    {
        if (flag == 0)
        {       
            place_iobl_tile_fp(tx, ty);
        }
        else if (flag == 1)
        {
            place_iobr_tile_fp(tx, ty);  
        }
    } // end of function place_ioblr_tile_fp
    
    
    ///*****Draw IOB*****/  
    ///*****Right*****/
    function draw_ioblr_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty,
        unsigned int flag
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx1, lsy1;
        string strVar;
        unsigned int i;
        
        // device reference variables
        &device s0Ref, s0fl;
        
        lsx = tx * NUM_GRID_X;
        lsy = ty * NUM_GRID_Y;
        if (flag == 0)
        {   
            unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};
            unsigned int offset_iobsdn[17:0] = {19, 25, 31, 43, 49, 55, 73, 79, 85, 91, 97, 139, 145, 151, 157, 163, 169, 181};
            unsigned int offset_iobsdp[17:0] = {18, 24, 30, 42, 48, 54, 72, 78, 84, 90, 96, 138, 144, 150, 156, 162, 168, 180};
            unsigned int offset_iobssp[17:0] = {20, 26, 32, 44, 50, 56, 74, 80, 86, 92, 98, 140, 146, 152, 158, 164, 170, 182};
            unsigned int offset_iobssn[17:0] = {21, 27, 33, 45, 51, 57, 75, 81, 87, 93, 99, 141, 147, 153, 159, 165, 171, 183};

            ///*****IOBS *BSS_N*****/
            foreach i (indexs)
            {
                lsx1 = lsx;
                lsy1 = lsy + offset_iobssn[i];                                                                                                                                                                                          
                   
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }
                                                                                                                                                          
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref);
            }
            
            ///*****IOBS *BSS_P*****/
            foreach i (indexs)
            {
                lsx1 = lsx;
                lsy1 = lsy + offset_iobssp[i];  
                
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }
                     
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref);
            }
            
            /////*****IOBS *BSD_N*****/
            foreach i (indexs)
            {
                lsx1 = lsx;
                lsy1 = lsy + offset_iobsdn[i];     
                
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }
                  
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref);
            }
            
            ///*****IOBS *BSD_P*****/
            foreach i (indexs)
            {
                lsx1 = lsx;
                lsy1 = lsy + offset_iobsdp[i];    
                
                // Instantiate the device.
                sprintf(strVar, "IOBD_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }
                   
                s0fl = device IOBD ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref);
            }
            
            lsx1 = lsx + 1;
            lsy1 = lsy + 62;
                
            // Instantiate the device.
            sprintf(strVar, "BKCL_%d_%d", lsx1, lsy1);
            s0Ref  = <instance  *strVar          of ARCHITECTURE (structure fp_struct)>;
            
            unsigned int offset_y = 0;
            get_coordinate_of_bkcl(lsx1, lsy1);
            if (fsy > 26)    
            {
                offset_y = 320;
            }
                
            s0fl = device BKCL ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];  
            map ( s0fl => s0Ref);  
        }
        else if (flag == 1)
        {
            unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35};
            unsigned int offset_iobsrn[35:0] = {19, 21, 25, 27, 31, 33, 43, 45, 49, 51, 55, 57, 73, 75, 79, 81, 85, 87, 91, 93, 97, 99, 139, 141, 145, 147, 151, 153, 157, 159, 163, 165, 169, 171, 181, 183};
            unsigned int offset_iobsrp[35:0] = {18, 20, 24, 26, 30, 32, 42, 44, 48, 50, 54, 56, 72, 74, 78, 80, 84, 86, 90, 92, 96, 98, 138, 140, 144, 146, 150, 152, 156, 158, 162, 164, 168, 170, 180, 182};

            ///*****IOBS *BSR_N*****/
            foreach i (indexs)
            {
                lsx1 = lsx;
                lsy1 = lsy + offset_iobsrn[i];                                                                                                                                                                                          
                                           
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar          of ARCHITECTURE (structure fp_struct)>;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }
                
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                
                map ( s0fl => s0Ref);
            }
            
            ///*****IOBR *BSR_P*****/
            foreach i (indexs)
            {
                lsx1 = lsx;
                lsy1 = lsy + offset_iobsrp[i];                                                                                                                                                                                          
                                           
                // Instantiate the device.
                sprintf(strVar, "IOBR_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar          of ARCHITECTURE (structure fp_struct)>;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }
                
                s0fl = device IOBR ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                
                map ( s0fl => s0Ref);
            }
            
            lsx1 = lsx + 1;
            lsy1 = lsy + 91;
                
            // Instantiate the device.
            sprintf(strVar, "BKCL_%d_%d", lsx1, lsy1);
            s0Ref  = <instance  *strVar          of ARCHITECTURE (structure fp_struct)>;
            
            unsigned int offset_y = 0;
            get_coordinate_of_bkcl(lsx1, lsy1);
            if (fsy > 26)    
            {
                offset_y = 320;
            }
            
            s0fl = device BKCL ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);  
        }
    }// end of function draw_ioblr_tile_fp
      
      
    ///*****iob1_2k_tile*****/ 
    function place_iobt_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx1, lsy1;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        ///*****IOBS *BSS_N*****/
        unsigned int i;
        unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33};
        unsigned int offset_iobssn[33:0] = {110, 108, 104, 102, 98, 96, 92, 90, 86, 84, 80, 78, 74, 72, 68, 66, 50, 48, 44, 42, 38, 36, 32, 30, 26, 24, 20, 18, 14, 12, 8, 6, 2, 0};
        unsigned int offset_iobssp[33:0] = {111, 109, 105, 103, 99, 97, 93, 91, 87, 85, 81, 79, 75, 73, 69, 67, 51, 49, 45, 43, 39, 37, 33, 31, 27, 25, 21, 19, 15, 13, 9, 7, 3, 1};
        foreach i (indexs)
        {
            lsx1 = tx * NUM_GRID_X;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1 + offset_iobssn[i];
            lsy = lsy1; 
            
            s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
            string strVar;
            sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
            
            get_coordinate_of_iob(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
    
        ///*****IOBS *BSS_P*****/
        foreach i (indexs)
        {
            lsx1 = tx * NUM_GRID_X;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1 + offset_iobssp[i];
            lsy = lsy1;
            
            s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
            string strVar;
            sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
               
            get_coordinate_of_iob(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        
        lsx = tx * NUM_GRID_X;
        lsy = ty * NUM_GRID_Y;
        
        lsx = lsx + 58;
        lsy = lsy + 1;
            
        s0Ref  = <device BKCL  @[lsx, lsy]     of ARCHITECTURE>;
        string strVar;
        sprintf(strVar, "BKCL_%d_%d", lsx, lsy);
        
        get_coordinate_of_bkcl(lsx, lsy);
        
        //printf("%s: %d, %d.", strVar, fsx, fsy);
        s0fl = device BKCL ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref);
    } // end of function place_iobt_tile_fp
    
    function draw_iobt_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx1, lsy1;
        string strVar;
        unsigned int i;
        unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33};
        unsigned int offset_iobssn[33:0] = {110, 108, 104, 102, 98, 96, 92, 90, 86, 84, 80, 78, 74, 72, 68, 66, 50, 48, 44, 42, 38, 36, 32, 30, 26, 24, 20, 18, 14, 12, 8, 6, 2, 0};
        unsigned int offset_iobssp[33:0] = {111, 109, 105, 103, 99, 97, 93, 91, 87, 85, 81, 79, 75, 73, 69, 67, 51, 49, 45, 43, 39, 37, 33, 31, 27, 25, 21, 19, 15, 13, 9, 7, 3, 1};
        
        // device reference variables
        &device s0Ref, s0fl;
        
        ///*****IOBS *BSS_N*****///
        ///*****For odd X_number*****///
        foreach i (indexs)
        {
            lsx = tx * NUM_GRID_X;
            lsy = ty * NUM_GRID_Y;
            lsx1 = lsx + offset_iobssn[i];
            lsy1 = lsy;
            
            // Instantiate the device.
            sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
            
            s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
            
            unsigned int offset_y = 0;
            get_coordinate_of_iob(lsx1, lsy1);
            if (fsy > 26)    
            {
                offset_y = 320;
            }
            
            s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
        }
        
        /*****IOBS *BSS_P*****/
        foreach i (indexs)
        {
            lsx = tx * NUM_GRID_X;
            lsy = ty * NUM_GRID_Y;
            lsx1 = lsx + offset_iobssp[i];
            lsy1 = lsy;
            
            // Instantiate the device.
            sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
            s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
            
            unsigned int offset_y = 0;
            get_coordinate_of_iob(lsx1, lsy1);
            if (fsy > 26)    
            {
                offset_y = 320;
            }
            
            s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
        }
                
        lsx1 = lsx + 58;
        lsy1 = lsy + 1;
            
        // Instantiate the device.
        sprintf(strVar, "BKCL_%d_%d", lsx1, lsy1);
        s0Ref  = <instance  *strVar          of ARCHITECTURE (structure fp_struct)>;
        
        unsigned int offset_y = 0;
        get_coordinate_of_bkcl(lsx1, lsy1);
        if (fsy > 29)
        {
            offset_y = 320;
        }
            
        s0fl = device BKCL ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
        map ( s0fl => s0Ref);  
    }// end of function draw_iobt_tile_fp
    
    
    function place_iobb_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty,
        unsigned int flag
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx1, lsy1;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        if (flag == 0)
        {
            ///*****IOBS *BSS_N*****/
            unsigned int i;
            unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
            unsigned int offset_iobssn[11:0] = {33, 31, 27, 25, 21, 19, 15, 13, 9, 7, 3, 1};
            unsigned int offset_iobssp[11:0] = {32, 30, 26, 24, 20, 18, 14, 12, 8, 6, 2, 0};
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1 + offset_iobssn[i];
                lsy = lsy1;
                
                s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
                string strVar;
                sprintf(strVar, "IOBS_%d_%d", lsx, lsy); 
               
                get_coordinate_of_iob(lsx, lsy);
                
                //printf("%s: %d, %d.", strVar, fsx, fsy);  
                s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            /*****IOBS *BSS_P*****/
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1 + offset_iobssp[i];
                lsy = lsy1;
                
                s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
                string strVar;
                sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
               
                get_coordinate_of_iob(lsx, lsy);
                
                //printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            lsx = tx * NUM_GRID_X;
            lsy = ty * NUM_GRID_Y;
            
            lsx = lsx + 22;
            lsy = lsy + 1;
                
            s0Ref  = <device BKCL  @[lsx, lsy]     of ARCHITECTURE>;
            string strVar;
            sprintf(strVar, "BKCL_%d_%d", lsx, lsy);
            
            get_coordinate_of_bkcl(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device BKCL ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        else if (flag == 1)
        {
            unsigned int i;
            unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7};
            unsigned int offset_iobssp[7:0] = {33, 31, 27, 25, 9, 7, 3, 1};
            unsigned int offset_iobssn[7:0] = {32, 30, 26, 24, 8, 6, 2, 0};
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1 + offset_iobssn[i];
                lsy = lsy1;
                
                s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
                string strVar;
                sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
               
                get_coordinate_of_iob(lsx, lsy);
                
                //printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            ///*****IOBS *BSS_P*****/
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1 + offset_iobssp[i];
                lsy = lsy1;
                
                s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
                string strVar;
                sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
               
                get_coordinate_of_iob(lsx, lsy);
                
                //printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            lsx = tx * NUM_GRID_X;
            lsy = ty * NUM_GRID_Y;
            
            lsx = lsx + 17;
            lsy = lsy + 1;
                
            s0Ref  = <device BKCL  @[lsx, lsy]     of ARCHITECTURE>;
            string strVar;
            sprintf(strVar, "BKCL_%d_%d", lsx, lsy);
            
            get_coordinate_of_bkcl(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device BKCL ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        else if (flag == 2)
        {
            unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};
            unsigned int offset_iobssn[13:0] = {39, 37, 33, 31, 27, 25, 21, 19, 15, 13, 9, 7, 3, 1};
            unsigned int offset_iobssp[13:0] = {38, 36, 32, 30, 26, 24, 20, 18, 14, 12, 8, 6, 2, 0};
            unsigned int i;
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1 + offset_iobssn[i];
                lsy = lsy1;
                
                s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
                string strVar;
                sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
               
                get_coordinate_of_iob(lsx, lsy);
                
                //printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            ///*****IOBS *BSS_P*****/
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X;
                lsy1 = ty * NUM_GRID_Y; 
                
                lsx = lsx1 + offset_iobssp[i];
                lsy = lsy1;
                
                s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
                string strVar;
                sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
               
                get_coordinate_of_iob(lsx, lsy);
                
                //printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            lsx = tx * NUM_GRID_X;
            lsy = ty * NUM_GRID_Y;
            
            lsx = lsx + 22;
            lsy = lsy + 1;
                
            s0Ref  = <device BKCL  @[lsx, lsy]     of ARCHITECTURE>;
            string strVar;
            sprintf(strVar, "BKCL_%d_%d", lsx, lsy);
            
            get_coordinate_of_bkcl(lsx, lsy);
            
            //printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device BKCL ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        
    }; // end of function place_iobb_tile_fp
    
    function draw_iobb_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty,
        unsigned int flag
    )
    {
        unsigned int lsx, lsy, gsx, gsy;
        unsigned int lsx1, lsy1;
        string strVar;
        unsigned int i;
        
        // device reference variables
        &device s0Ref, s0fl;
        
        if (flag == 0)
        {
            unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
            unsigned int offset_iobssn[11:0] = {33, 31, 27, 25, 21, 19, 15, 13, 9, 7, 3, 1};
            unsigned int offset_iobssp[11:0] = {32, 30, 26, 24, 20, 18, 14, 12, 8, 6, 2, 0};
            ///*****IOBS *BSS_N*****/
            foreach i (indexs)
            {
                lsx = tx * NUM_GRID_X;
                lsy = ty * NUM_GRID_Y;
                lsx1 = lsx + offset_iobssn[i];
                lsy1 = lsy;
                
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }
                
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref);
            }
            
            /*****IOBS *BSS_P*****/
            foreach i (indexs)
            {
                lsx = tx * NUM_GRID_X;
                lsy = ty * NUM_GRID_Y;
                lsx1 = lsx + offset_iobssp[i];
                lsy1 = lsy;
                
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }
                
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref);
            } 
                  
            lsx1 = lsx + 22;
            lsy1 = lsy + 1;
                
            // Instantiate the device.
            sprintf(strVar, "BKCL_%d_%d", lsx1, lsy1);
            s0Ref  = <instance  *strVar          of ARCHITECTURE (structure fp_struct)>;
            
            unsigned int offset_y = 0;
            get_coordinate_of_bkcl(lsx1, lsy1);
            if (fsy > 26)    
            {
                offset_y = 320;
            }
                
            s0fl = device BKCL ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);  
        }
        else if (flag == 1)
        {
            unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7};
            unsigned int offset_iobssp[7:0] = {33, 31, 27, 25, 9, 7, 3, 1};
            unsigned int offset_iobssn[7:0] = {32, 30, 26, 24, 8, 6, 2, 0};
             ///*****IOBS *BSS_N*****/
            foreach i (indexs)
            {
                lsx = tx * NUM_GRID_X;
                lsy = ty * NUM_GRID_Y;
                lsx1 = lsx + offset_iobssn[i];
                lsy1 = lsy;
                
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }
                
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                
                map ( s0fl => s0Ref);
            }
            
            ///*****IOBS *BSS_P*****/
            foreach i (indexs)
            {
                lsx = tx * NUM_GRID_X;
                lsy = ty * NUM_GRID_Y;
                lsx1 = lsx + offset_iobssp[i];
                lsy1 = lsy;
                
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }
                
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];

                map ( s0fl => s0Ref);
            }
                  
            lsx1 = lsx + 17;
            lsy1 = lsy + 1;
                
            // Instantiate the device.
            sprintf(strVar, "BKCL_%d_%d", lsx1, lsy1);
            s0Ref  = <instance  *strVar          of ARCHITECTURE (structure fp_struct)>;
            
            unsigned int offset_y = 0;
            get_coordinate_of_bkcl(lsx1, lsy1);
            if (fsy > 26)    
            {
                offset_y = 320;
            }
            s0fl = device BKCL ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref); 
        }
        else if (flag == 2)
        {
            unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};
            unsigned int offset_iobssn[13:0] = {39, 37, 33, 31, 27, 25, 21, 19, 15, 13, 9, 7, 3, 1};
            unsigned int offset_iobssp[13:0] = {38, 36, 32, 30, 26, 24, 20, 18, 14, 12, 8, 6, 2, 0};
            ///*****IOBS *BSS_N*****/
            foreach i (indexs)
            {
                lsx = tx * NUM_GRID_X;
                lsy = ty * NUM_GRID_Y;
                lsx1 = lsx + offset_iobssn[i];
                lsy1 = lsy;
                
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }
                
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                
                map ( s0fl => s0Ref);
            }
            
            ///*****IOBS *BSS_P*****/
            foreach i (indexs)
            {
                lsx = tx * NUM_GRID_X;
                lsy = ty * NUM_GRID_Y;
                lsx1 = lsx + offset_iobssn[i] - 1;
                lsy1 = lsy;
                
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 26)    
                {
                    offset_y = 320;
                }
                
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                
                map ( s0fl => s0Ref);
            }
                  
            lsx1 = lsx + 22;
            lsy1 = lsy + 1;
                
            // Instantiate the device.
            sprintf(strVar, "BKCL_%d_%d", lsx1, lsy1);
            s0Ref  = <instance  *strVar          of ARCHITECTURE (structure fp_struct)>;
            
            unsigned int offset_y = 0;
            get_coordinate_of_bkcl(lsx1, lsy1);
            if (fsy > 26)    
            {
                offset_y = 320;
            }
            s0fl = device BKCL ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref); 
        }
    };// end of function draw_iobb_tile_fp

}; // end of package pgc_schm_funcs
