tarted
grid
device IOL
{
    // grid_property_def_start
    // grid_property_def_end

    parameter
    (
        config string CP_IREG_SET = "SET",
        config string CP_OREG_SET = "SET",
        config string CP_TSREG_SET = "SET",
        config string CP_CLK_POL = "FALSE",
        config string CP_SR_POL = "FALSE",
        config string CP_REG_SYNC = "ASYNC",
        config string CP_ILATCH_EN = "DISABLE",
        config string CP_Y_SEL = "STA",
        config string CP_DDR_EN = "DISABLE",
        config string CP_DIN_POL = "FALSE",
        config string CP_IREG_SEL = "FALSE",
        config bit CP_DQMODE[1:0] = 2'b00,
        config string CP_D0_POL = "FALSE",
        config string CP_D1_POL = "FALSE",
        config string CP_TQMODE = "DD",
        config string CP_TD0_POL = "FALSE",
        config string CP_TD1_POL = "FALSE",
        config string CP_GRS_DIS = "FALSE",
        config string CP_ICLK_EN = "DISABLE",
        config string CP_OCLK_EN = "DISABLE",
        config string CP_SCLK_EN = "DISABLE",
        config string CP_ISR_EN = "DISABLE",
        config string CP_OSR_EN = "DISABLE",
        config string CP_TSR_EN = "DISABLE",
        config string CP_TEST_EN0 = "DISABLE",
        config string CP_TEST_EN1 = "DISABLE",
        config string CP_MIPI_EN = "DISABLE",
        config string CP_IN0_SEL = "FALSE",
        config string CP_PDIFF = "DISABLE",
        config string CP_OUTDLY_EN = "DISABLE"
    );
    port
    (
// configuration_body_def_on


    config input SC_IREG_SET = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_IREG_SET" */,

    config input SC_OREG_SET = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_OREG_SET" */,

    config input SC_TSREG_SET = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_TSREG_SET" */,

    config input SC_CLK_POL = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_CLK_POL" */,

    config input SC_SR_POL = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_SR_POL" */,

    config input SC_REG_SYNC = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_REG_SYNC" */,

    config input SC_ILATCH_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_ILATCH_EN" */,

    config input SC_DDR_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_DDR_EN" */,

    config input SC_D0_POL = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_D0_POL" */,

    config input SC_D1_POL = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_D1_POL" */,

    config input SC_TQMODE[1:0] = 2'h0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_TQMODE[1],SC_TQMODE[0]" */,

    config input SC_TD0_POL = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_TD0_POL" */,

    config input SC_TD1_POL = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_TD1_POL" */,

    config input SC_GRS_DIS = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_GRS_DIS" */,

    config input SC_ICLK_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_ICLK_EN" */,

    config input SC_OCLK_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_OCLK_EN" */,

    config input SC_SCLK_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_SCLK_EN" */,

    config input SC_Y_SEL[1:0] = 2'h0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_Y_SEL[1],SC_Y_SEL[0]" */,

    config input SC_DIN_POL = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_DIN_POL" */,

    config input SC_IREG_SEL = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_IREG_SEL" */,

    config input SC_ISR_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_ISR_EN" */,

    config input SC_OSR_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_OSR_EN" */,

    config input SC_TSR_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_TSR_EN" */,

    config input SC_TEST_EN0 = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_TEST_EN0" */,

    config input SC_TEST_EN1 = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_TEST_EN1" */,

    config input SC_MIPI_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_MIPI_EN" */,

    config input SC_IN0_SEL = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_IN0_SEL" */,

    config input SC_PDIFF = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_PDIFF" */,

    config input SC_OUTDLY_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_OUTDLY_EN" */,

    config input SC_DQMODE[1:0] = 2'h0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_DQMODE[1],SC_DQMODE[0]" */,

// configuration_body_def_end

        input CE_IREG = 1'b1,
        input CE_OREG = 1'b1,
        input CE_TSREG = 1'b1,
        input DIN = 1'b1,
        input DIN_MIPI = 1'b1,
        input D0 = 1'b1,
        input D1 = 1'b1,
        input DO_IN = 1'b1,
        input DQ_CAS_IN = 1'b1,
        input TD0 = 1'b1,
        input TD1 = 1'b1,
        input TQ_CAS_IN = 1'b1,
        input CLK = 1'b1,
        input SR = 1'b1,
        input MIPI_SW_DYN_I = 1'b1,
        input INBUF_DYN_DIS_N_I = 1'b1,
        input DQ_DLY_IN = 1'b1,
        output Y,
        output Q0,
        output Q1,
        output DQ,
        output DQ_CAS_OUT,
        output TQ,
        output TQ_CAS_OUT,
        output SR_O,
        output CLK_SYS_SERDES,
        output MIPI_SW_DYN_O,
        output INBUF_DYN_DIS_N_O,
        output DIN_ISERDES,
        output DQ_OUT
    );
};
//grid device end

//grid device structure netlist started
structure netlist of IOL
{
    // Internal wires
    wire ntCLK_O;
    wire ntDIN_O;
    wire ntDIN_MIPI;
    wire ntD0_O;
    wire ntD1_O;
    wire ntTD0_O;
    wire ntTD1_O;
    wire ntISR;
    wire ntOSR;
    wire ntTSR;
    wire ntICLK;
    wire ntOCLK;
    wire ntDYN_CTRL0;
    wire ntDYN_CTRL1;
    wire ntDYN_MUX0_O;
    wire ntDYN_MUX1_O;
    wire ntDQ_SDR;
    wire ntDQ_DDR;
    wire ntTQ_SDR;
    wire ntTQ_DDR;
    wire ntSTA_SEL[1:0];
    wire ntSEL[1:0];
    wire ntDQ_IN0;
    

    // Wires connecting to input ports
    wire ntSR;
    wire ntCLK;
    wire ntDIN;
    wire ntD0;
    wire ntD1;
    wire ntTD0;
    wire ntTD1;
    wire ntCE_IREG;
    wire ntCE_OREG;
    wire ntCE_TSREG;
    wire ntMIPI_SW_DYN_I;
    wire ntDO_IN;
    wire ntDQ_CAS_IN;
    wire ntTQ_CAS_IN;
    wire ntDIN_SEL;
    wire ntINBUF_DYN_DIS_N;
    wire ntDQ_DLY_IN;   

    
    ntSR <= SR;
    ntCLK <= CLK;
    ntDIN <= DIN;
    ntDIN_MIPI  <= DIN_MIPI;
    ntD0 <= D0;
    ntD1 <= D1;
    ntTD0 <= TD0;
    ntTD1 <= TD1;
    ntCE_IREG <= CE_IREG;
    ntCE_OREG <= CE_OREG;
    ntCE_TSREG <= CE_TSREG;
    ntMIPI_SW_DYN_I <= MIPI_SW_DYN_I;
    ntDO_IN <= DO_IN;
    
    ntINBUF_DYN_DIS_N <= INBUF_DYN_DIS_N_I;
    ntDQ_CAS_IN       <= DQ_CAS_IN;
    ntTQ_CAS_IN       <= TQ_CAS_IN;
    ntDQ_DLY_IN       <= DQ_DLY_IN;
    
    // Wires connecting to output ports
    wire ntSR_O;
    wire ntCLK_SYS_SERDES;
    wire ntTQ;
    wire ntDQ;
    wire ntDIN_ISERDES;
    wire ntQ0;
    wire ntQ1;
    wire ntY;
    wire ntTQ_CAS_OUT;
    wire ntDQ_CAS_OUT;
    wire ntDQ_OUT;
    
    SR_O <= ntSR_O;
    CLK_SYS_SERDES <= ntCLK_SYS_SERDES;
    TQ <= ntTQ;
    DQ <= ntDQ;
    DIN_ISERDES <= ntDIN_ISERDES;
    Q0 <= ntQ0;
    Q1 <= ntQ1;
    
    INBUF_DYN_DIS_N_O <= ntINBUF_DYN_DIS_N;
    Y <= ntY;
    TQ_CAS_OUT  <= ntTQ_CAS_OUT;
    DQ_CAS_OUT  <= ntDQ_CAS_OUT;
    
    MIPI_SW_DYN_O <= ntMIPI_SW_DYN_I;
    DQ_OUT <= ntDQ_OUT;
    
    
    device POLMUX SR_POL_MUX
        parameter map
        (
            CP_X_POL => CP_SR_POL
        )
        port map
        (
            X => ntSR,
            Y => ntSR_O
        );
    
    device POLMUX CLK_POL_MUX
        parameter map
        (
            CP_X_POL => CP_CLK_POL
        )
        port map
        (
            X => ntCLK,
            Y => ntCLK_O
        );
    
    device POLMUX DIN_POL_MUX
        parameter map
        (
            CP_X_POL => CP_DIN_POL
        )
        port map
        (
            X => ntDIN,
            Y => ntDIN_O
        );
    
    device POLMUX D0_POL_MUX
        parameter map
        (
            CP_X_POL => CP_D0_POL
        )
        port map
        (
            X => ntD0,
            Y => ntD0_O
        );
    
    device POLMUX D1_POL_MUX
        parameter map
        (
            CP_X_POL => CP_D1_POL
        )
        port map
        (
            X => ntD1,
            Y => ntD1_O
        );
    
    device POLMUX TD0_POL_MUX
        parameter map
        (
            CP_X_POL => CP_TD0_POL
        )
        port map
        (
            X => ntTD0,
            Y => ntTD0_O
        );
    
    device POLMUX TD1_POL_MUX
        parameter map
        (
            CP_X_POL => CP_TD1_POL
        )
        port map
        (
            X => ntTD1,
            Y => ntTD1_O
        );
    
    device X_EN ISR_EN_MUX
        parameter map
        (
            CP_A_EN => CP_ISR_EN
        )
        port map
        (
            A => ntSR_O,
            Y => ntISR
        );
    
    device X_EN OSR_EN_MUX
        parameter map
        (
            CP_A_EN => CP_OSR_EN
        )
        port map
        (
            A => ntSR_O,
            Y => ntOSR
        );
    
    device X_EN TSR_EN_MUX
        parameter map
        (
            CP_A_EN => CP_TSR_EN
        )
        port map
        (
            A => ntSR_O,
            Y => ntTSR
        );
    
    device X_EN ICLK_EN_MUX
        parameter map
        (
            CP_A_EN => CP_ICLK_EN
        )
        port map
        (
            A => ntCLK_O,
            Y => ntICLK
        );
    
    device X_EN OCLK_EN_MUX
        parameter map
        (
            CP_A_EN => CP_OCLK_EN
        )
        port map
        (
            A => ntCLK_O,
            Y => ntOCLK
        );
    
    device X_EN SCLK_EN_MUX
        parameter map
        (
            CP_A_EN => CP_SCLK_EN
        )
        port map
        (
            A => ntCLK_O,
            Y => ntCLK_SYS_SERDES
        );
    
    device ENMUX21 DYN_CTRL0_SEL
        parameter map
        (
            CP_SEL => CP_TEST_EN0
        )
        port map
        (
            X0 => 1'b0,
            X1 => ntTQ,
            Y => ntDYN_CTRL0
        );
    
    device ENMUX21 DYN_CTRL1_SEL
        parameter map
        (
            CP_SEL => CP_TEST_EN1
        )
        port map
        (
            X0 => 1'b0,
            X1 => ntTQ,
            Y  => ntDYN_CTRL1
        );
    
    device DYN_MUX21 DYN_CTRL0_MUX
        port map
        (
            X0  => ntDIN_O,
            X1  => ntDQ,
            SEL => ntDYN_CTRL0,
            Y   => ntDYN_MUX0_O
        );
    
    device DYN_MUX21 DYN_CTRL1_MUX
        port map
        (
            X0  => ntDIN_O,
            X1  => ntDQ,
            SEL => ntDYN_CTRL1,
            Y   => ntDYN_MUX1_O
        );
    
    device MUX21 IREG_IN_MUX
        parameter map
        (
            CP_SEL => CP_IREG_SEL
        )
        port map
        (
            X0  => ntDIN_O,
            X1  => ntDYN_MUX1_O,
            Y   => ntDIN_ISERDES
        );
    
    device IREG IREG
        parameter map
        (
            CP_GRS_DIS   => CP_GRS_DIS,
            CP_IREG_SET  => CP_IREG_SET,
            CP_REG_SYNC  => CP_REG_SYNC,
            CP_DDR_EN    => CP_DDR_EN,
            CP_ILATCH_EN => CP_ILATCH_EN
        )
        port map
        (
            D    => ntDIN_ISERDES,
            CLK  => ntICLK,
            CE   => ntCE_IREG,
            SR   => ntISR,
            Q0   => ntQ0,
            Q1   => ntQ1
        );
    
    device OREG OREG
        parameter map
        (
            CP_GRS_DIS   => CP_GRS_DIS,
            CP_OREG_SET  => CP_OREG_SET,
            CP_REG_SYNC  => CP_REG_SYNC
        )
        port map
        (
            D0    => ntD0_O,
            D1    => ntD1_O,
            CLK  => ntOCLK,
            CE   => ntCE_OREG,
            SR   => ntOSR,
            DQ_SDR   => ntDQ_SDR,
            DQ_DDR   => ntDQ_DDR
        );
    
    device TSREG TSREG
        parameter map
        (
            CP_GRS_DIS   => CP_GRS_DIS,
            CP_TSREG_SET  => CP_TSREG_SET,
            CP_REG_SYNC  => CP_REG_SYNC
        )
        port map
        (
            TD0    => ntTD0_O,
            TD1    => ntTD1_O,
            CLK  => ntOCLK,
            CE   => ntCE_TSREG,
            SR   => ntTSR,
            TQ_SDR   => ntTQ_SDR,
            TQ_DDR   => ntTQ_DDR
        );
        
    device ENMUX21 DIN_SEL_MUX
        parameter map
        (
            CP_SEL  => CP_MIPI_EN
        )
        port map
        (
            X0  => ntDIN_O,
            X1  => ntDIN_MIPI,
            Y   => ntDIN_SEL
        );
    
    device Y_MUX41 Y0_MUX
        parameter map
        (
            CP_SEL  => CP_Y_SEL
        )
        port map
        (
            X0    => ntDIN_SEL,
            X1    => ntDYN_MUX0_O,
            X2    => ntDQ,
            X3    => ntTQ,
            Y     => ntY
        );
    
    device TQ_MUX41 TQ_MUX
        parameter map
        (
            CP_SEL  => CP_TQMODE
        )
        port map
        (
            X0    => ntTD0_O,
            X1    => ntTQ_SDR,
            X2    => ntTQ_DDR,
            X3    => 1'b0,
            Y     => ntTQ_CAS_OUT
        );
    
    device ENMUX21 TQ_PDIFF_MUX
        parameter map
        (
            CP_SEL => CP_PDIFF
        )
        port map
        (
            X0 => ntTQ_CAS_OUT,
            X1 => ntTQ_CAS_IN,
            Y  => ntTQ
        );
        
    device MUX21 IN0_MUX0
        parameter map
        (
            CP_SEL  => CP_IN0_SEL
        )
        port map
        (
            X0    => ntD0_O,
            X1    => ntDQ_SDR,
            Y     => ntDQ_IN0
        );
    
    device MUX21_1 DQMODE_MUX0
        parameter map
        (
            CP_SEL  => CP_DQMODE[0]
        )
        port map
        (
            X0    => 1'b0,
            X1    => 1'b1,
            Y     => ntSTA_SEL[0]
        );
    
    device MUX21_1 DQMODE_MUX1
        parameter map
        (
            CP_SEL  => CP_DQMODE[1]
        )
        port map
        (
            X0    => 1'b0,
            X1    => 1'b1,
            Y     => ntSTA_SEL[1]
        );
    
    device ENMUX21 DQ_SEL_MUX0
        parameter map
        (
            CP_SEL  => CP_MIPI_EN
        )
        port map
        (
            X0    => ntSTA_SEL[0],
            X1    => ntMIPI_SW_DYN_I,
            Y     => ntSEL[0]
        );
    
    device ENMUX21 DQ_SEL_MUX1
        parameter map
        (
            CP_SEL  => CP_MIPI_EN
        )
        port map
        (
            X0    => ntSTA_SEL[1],
            X1    => ntMIPI_SW_DYN_I,
            Y     => ntSEL[1]
        );
    
    device DQ_MUX41 DQ_MUX
        port map
        (
            X0    => ntDQ_IN0,
            X1    => ntDQ_SDR,
            X2    => ntDQ_DDR,
            X3    => ntDO_IN,
            SEL   => ntSEL[1:0],
            Y     => ntDQ_OUT
        );
        
    device ENMUX21 DQ_ODLY_MUX
        parameter map
        (
            CP_SEL  => CP_OUTDLY_EN
        )
        port map
        (
            X0      => ntDQ_OUT,
            X1      => ntDQ_DLY_IN,
            Y       => ntDQ_CAS_OUT
        );
      
    device ENMUX21 DQ_PDIFF_MUX
        parameter map
        (
            CP_SEL => CP_PDIFF
        )
        port map
        (
            X0 => ntDQ_CAS_OUT,
            X1 => ntDQ_CAS_IN,
            Y  => ntDQ
        );
};
//grid device structure netlist end

//grid device configure body started

configuration cfg of IOL
{

 // assign config body begin
    SC_DQMODE  :=  CP_DQMODE;
// assign config body end

//initial config body0 begin
    if(CP_IREG_SET == "SET")
    {
        SC_IREG_SET  :=  1'b0;
    }
    else if(CP_IREG_SET =="RESET")
    {
        SC_IREG_SET  :=  1'b1;
    }
    else
    {
        SC_IREG_SET  :=  1'bx;
        error("illegal setting for CP_IREG_SET  :=  %s", CP_IREG_SET);
    }

//initial config body0 end


//initial config body1 begin
    if(CP_OREG_SET == "SET")
    {
        SC_OREG_SET  :=  1'b0;
    }
    else if(CP_OREG_SET =="RESET")
    {
        SC_OREG_SET  :=  1'b1;
    }
    else
    {
        SC_OREG_SET  :=  1'bx;
        error("illegal setting for CP_OREG_SET  :=  %s", CP_OREG_SET);
    }

//initial config body1 end


//initial config body2 begin
    if(CP_TSREG_SET == "SET")
    {
        SC_TSREG_SET  :=  1'b0;
    }
    else if(CP_TSREG_SET =="RESET")
    {
        SC_TSREG_SET  :=  1'b1;
    }
    else
    {
        SC_TSREG_SET  :=  1'bx;
        error("illegal setting for CP_TSREG_SET  :=  %s", CP_TSREG_SET);
    }

//initial config body2 end


//initial config body3 begin
    if(CP_CLK_POL == "FALSE")
    {
        SC_CLK_POL  :=  1'b0;
    }
    else if(CP_CLK_POL =="TRUE")
    {
        SC_CLK_POL  :=  1'b1;
    }
    else
    {
        SC_CLK_POL  :=  1'bx;
        error("illegal setting for CP_CLK_POL  :=  %s", CP_CLK_POL);
    }

//initial config body3 end


//initial config body4 begin
    if(CP_SR_POL == "FALSE")
    {
        SC_SR_POL  :=  1'b0;
    }
    else if(CP_SR_POL =="TRUE")
    {
        SC_SR_POL  :=  1'b1;
    }
    else
    {
        SC_SR_POL  :=  1'bx;
        error("illegal setting for CP_SR_POL  :=  %s", CP_SR_POL);
    }

//initial config body4 end


//initial config body5 begin
    if(CP_REG_SYNC == "ASYNC")
    {
        SC_REG_SYNC  :=  1'b0;
    }
    else if(CP_REG_SYNC =="SYNC")
    {
        SC_REG_SYNC  :=  1'b1;
    }
    else
    {
        SC_REG_SYNC  :=  1'bx;
        error("illegal setting for CP_REG_SYNC  :=  %s", CP_REG_SYNC);
    }

//initial config body5 end


//initial config body6 begin
    if(CP_ILATCH_EN == "DISABLE")
    {
        SC_ILATCH_EN  :=  1'b0;
    }
    else if(CP_ILATCH_EN =="ENABLE")
    {
        SC_ILATCH_EN  :=  1'b1;
    }
    else
    {
        SC_ILATCH_EN  :=  1'bx;
        error("illegal setting for CP_ILATCH_EN  :=  %s", CP_ILATCH_EN);
    }

//initial config body6 end


//initial config body7 begin
    if(CP_Y_SEL == "STA")
    {
        SC_Y_SEL  :=  2'b0;
    }
    else if(CP_Y_SEL =="DYN")
    {
        SC_Y_SEL  :=  2'b01;
    }
    else if(CP_Y_SEL == "DQ")
    {
        SC_Y_SEL  :=  2'b10;
    }
    else if(CP_Y_SEL == "TQ")
    {
        SC_Y_SEL  :=  2'b11;
    }
    else
    {
        SC_Y_SEL  :=  2'bx;
        error("illegal setting for CP_Y_SEL  :=  %s", CP_Y_SEL);
    }

//initial config body7 end


//initial config body8 begin
    if(CP_DDR_EN == "DISABLE")
    {
        SC_DDR_EN  :=  1'b0;
    }
    else if(CP_DDR_EN =="ENABLE")
    {
        SC_DDR_EN  :=  1'b1;
    }
    else
    {
        SC_DDR_EN  :=  1'bx;
        error("illegal setting for CP_DDR_EN  :=  %s", CP_DDR_EN);
    }

//initial config body8 end


//initial config body9 begin
    if(CP_DIN_POL == "FALSE")
    {
        SC_DIN_POL  :=  1'b0;
    }
    else if(CP_DIN_POL =="TRUE")
    {
        SC_DIN_POL  :=  1'b1;
    }
    else
    {
        SC_DIN_POL  :=  1'bx;
        error("illegal setting for CP_DIN_POL  :=  %s", CP_DIN_POL);
    }

//initial config body9 end


//initial config body10 begin
    if(CP_IREG_SEL == "FALSE")
    {
        SC_IREG_SEL  :=  1'b0;
    }
    else if(CP_IREG_SEL =="TRUE")
    {
        SC_IREG_SEL  :=  1'b1;
    }
    else
    {
        SC_IREG_SEL  :=  1'bx;
        error("illegal setting for CP_IREG_SEL  :=  %s", CP_IREG_SEL);
    }

//initial config body10 end


//initial config body11 begin
    if(CP_D0_POL == "FALSE")
    {
        SC_D0_POL  :=  1'b0;
    }
    else if(CP_D0_POL =="TRUE")
    {
        SC_D0_POL  :=  1'b1;
    }
    else
    {
        SC_D0_POL  :=  1'bx;
        error("illegal setting for CP_D0_POL  :=  %s", CP_D0_POL);
    }

//initial config body11 end


//initial config body12 begin
    if(CP_D1_POL == "FALSE")
    {
        SC_D1_POL  :=  1'b0;
    }
    else if(CP_D1_POL =="TRUE")
    {
        SC_D1_POL  :=  1'b1;
    }
    else
    {
        SC_D1_POL  :=  1'bx;
        error("illegal setting for CP_D1_POL  :=  %s", CP_D1_POL);
    }

//initial config body12 end


//initial config body13 begin
    if(CP_TQMODE == "DD")
    {
        SC_TQMODE  :=  2'b0;
    }
    else if(CP_TQMODE =="SDR")
    {
        SC_TQMODE  :=  2'b01;
    }
    else if(CP_TQMODE == "DDR")
    {
        SC_TQMODE  :=  2'b10;
    }
    else if(CP_TQMODE == "TIELO")
    {
        SC_TQMODE  :=  2'b11;
    }
    else
    {
        SC_TQMODE  :=  2'bx;
        error("illegal setting for CP_TQMODE  :=  %s", CP_TQMODE);
    }

//initial config body13 end


//initial config body14 begin
    if(CP_TD0_POL == "FALSE")
    {
        SC_TD0_POL  :=  1'b0;
    }
    else if(CP_TD0_POL =="TRUE")
    {
        SC_TD0_POL  :=  1'b1;
    }
    else
    {
        SC_TD0_POL  :=  1'bx;
        error("illegal setting for CP_TD0_POL  :=  %s", CP_TD0_POL);
    }

//initial config body14 end


//initial config body15 begin
    if(CP_TD1_POL == "FALSE")
    {
        SC_TD1_POL  :=  1'b0;
    }
    else if(CP_TD1_POL =="TRUE")
    {
        SC_TD1_POL  :=  1'b1;
    }
    else
    {
        SC_TD1_POL  :=  1'bx;
        error("illegal setting for CP_TD1_POL  :=  %s", CP_TD1_POL);
    }

//initial config body15 end


//initial config body16 begin
    if(CP_ICLK_EN == "DISABLE")
    {
        SC_ICLK_EN  :=  1'b0;
    }
    else if(CP_ICLK_EN =="ENABLE")
    {
        SC_ICLK_EN  :=  1'b1;
    }
    else
    {
        SC_ICLK_EN  :=  1'bx;
        error("illegal setting for CP_ICLK_EN  :=  %s", CP_ICLK_EN);
    }

//initial config body16 end


//initial config body17 begin
    if(CP_GRS_DIS == "FALSE")
    {
        SC_GRS_DIS  :=  1'b0;
    }
    else if(CP_GRS_DIS =="TRUE")
    {
        SC_GRS_DIS  :=  1'b1;
    }
    else
    {
        SC_GRS_DIS  :=  1'bx;
        error("illegal setting for CP_GRS_DIS  :=  %s", CP_GRS_DIS);
    }

//initial config body17 end


//initial config body18 begin
    if(CP_OCLK_EN == "DISABLE")
    {
        SC_OCLK_EN  :=  1'b0;
    }
    else if(CP_OCLK_EN =="ENABLE")
    {
        SC_OCLK_EN  :=  1'b1;
    }
    else
    {
        SC_OCLK_EN  :=  1'bx;
        error("illegal setting for CP_OCLK_EN  :=  %s", CP_OCLK_EN);
    }

//initial config body18 end


//initial config body19 begin
    if(CP_SCLK_EN == "DISABLE")
    {
        SC_SCLK_EN  :=  1'b0;
    }
    else if(CP_SCLK_EN =="ENABLE")
    {
        SC_SCLK_EN  :=  1'b1;
    }
    else
    {
        SC_SCLK_EN  :=  1'bx;
        error("illegal setting for CP_SCLK_EN  :=  %s", CP_SCLK_EN);
    }

//initial config body19 end


//initial config body20 begin
    if(CP_ISR_EN == "DISABLE")
    {
        SC_ISR_EN  :=  1'b0;
    }
    else if(CP_ISR_EN =="ENABLE")
    {
        SC_ISR_EN  :=  1'b1;
    }
    else
    {
        SC_ISR_EN  :=  1'bx;
        error("illegal setting for CP_ISR_EN  :=  %s", CP_ISR_EN);
    }

//initial config body20 end


//initial config body21 begin
    if(CP_OSR_EN == "DISABLE")
    {
        SC_OSR_EN  :=  1'b0;
    }
    else if(CP_OSR_EN =="ENABLE")
    {
        SC_OSR_EN  :=  1'b1;
    }
    else
    {
        SC_OSR_EN  :=  1'bx;
        error("illegal setting for CP_OSR_EN  :=  %s", CP_OSR_EN);
    }

//initial config body21 end


//initial config body22 begin
    if(CP_TSR_EN == "DISABLE")
    {
        SC_TSR_EN  :=  1'b0;
    }
    else if(CP_TSR_EN =="ENABLE")
    {
        SC_TSR_EN  :=  1'b1;
    }
    else
    {
        SC_TSR_EN  :=  1'bx;
        error("illegal setting for CP_TSR_EN  :=  %s", CP_TSR_EN);
    }

//initial config body22 end


//initial config body23 begin
    if(CP_TEST_EN0 == "DISABLE")
    {
        SC_TEST_EN0  :=  1'b0;
    }
    else if(CP_TEST_EN0 =="ENABLE")
    {
        SC_TEST_EN0  :=  1'b1;
    }
    else
    {
        SC_TEST_EN0  :=  1'bx;
        error("illegal setting for CP_TEST_EN0  :=  %s", CP_TEST_EN0);
    }

//initial config body23 end


//initial config body24 begin
    if(CP_TEST_EN1 == "DISABLE")
    {
        SC_TEST_EN1  :=  1'b0;
    }
    else if(CP_TEST_EN1 =="ENABLE")
    {
        SC_TEST_EN1  :=  1'b1;
    }
    else
    {
        SC_TEST_EN0  :=  1'bx;
        error("illegal setting for CP_TEST_EN1  :=  %s", CP_TEST_EN1);
    }

//initial config body24 end


//initial config body25 begin
    if(CP_MIPI_EN == "DISABLE")
    {
        SC_MIPI_EN  :=  1'b0;
    }
    else if(CP_MIPI_EN =="ENABLE")
    {
        SC_MIPI_EN  :=  1'b1;
    }
    else
    {
        SC_MIPI_EN  :=  1'bx;
        error("illegal setting for CP_MIPI_EN  :=  %s", CP_MIPI_EN);
    }

//initial config body25 end


//initial config body26 begin
    if(CP_IN0_SEL == "FALSE")
    {
        SC_IN0_SEL  :=  1'b0;
    }
    else if(CP_IN0_SEL =="TRUE")
    {
        SC_IN0_SEL  :=  1'b1;
    }
    else
    {
        SC_IN0_SEL  :=  1'bx;
        error("illegal setting for CP_IN0_SEL  :=  %s", CP_IN0_SEL);
    }

//initial config body26 end


//initial config body27 begin
    if(CP_PDIFF == "DISABLE")
    {
        SC_PDIFF  :=  1'b0;
    }
    else if(CP_PDIFF =="ENABLE")
    {
        SC_PDIFF  :=  1'b1;
    }
    else
    {
        SC_PDIFF  :=  1'bx;
        error("illegal setting for CP_PDIFF  :=  %s", CP_PDIFF);
    }

//initial config body27 end


//initial config body28 begin
    if(CP_OUTDLY_EN == "DISABLE")
    {
        SC_OUTDLY_EN  :=  1'b0;
    }
    else if(CP_OUTDLY_EN =="ENABLE")
    {
        SC_OUTDLY_EN  :=  1'b1;
    }
    else
    {
        SC_OUTDLY_EN  :=  1'bx;
        error("illegal setting for CP_OUTDLY_EN  :=  %s", CP_OUTDLY_EN);
    }

//initial config body28 end

};

//grid device configure body end

timing iol_tnl of IOL
{
    wire ntDYN_MUX0_O;
    wire ntDYN_MUX1_O;
    wire ntDQ_SDR;
    wire ntDQ_DDR;
    wire ntTQ_SDR;
    wire ntTQ_DDR;

    wire ntCLK;
    wire ntSR;
    wire ntDIN;
    wire ntD0;
    wire ntD1;
    wire ntTD0;
    wire ntTD1;

    wire ntDQ_MUX_MIPI_O;

    string GRS_EN = (CP_GRS_DIS == "FALSE") ? "TRUE" : 
                    (CP_GRS_DIS == "TRUE" ) ? "FALSE" : "";

// INPUTs
    if (CP_SR_POL == "TRUE")
    {
        operator V_INV SR_INV
            port map
            (
               I => SR,
               Z => ntSR
            );
    }
    else if (CP_SR_POL == "FALSE")
    {
        ntSR <= SR;
    }

    if (CP_CLK_POL == "TRUE")
    {
        operator V_INV CLK_INV
            port map
            (
               I => CLK,
               Z => ntCLK
            );
    }
    else if (CP_CLK_POL == "FALSE")
    {
        ntCLK <= CLK;
    }

    if (CP_DIN_POL == "TRUE")
    {
        operator V_INV DIN_INV
            port map
            (
               I => DIN,
               Z => ntDIN
            ); 
    }
    else if (CP_DIN_POL == "FALSE")
    { 
        ntDIN <= DIN;
    }

    if (CP_D0_POL == "TRUE")
    {
        operator V_INV D0_INV
            port map
            (
               I => D0,
               Z => ntD0
            ); 
    }
    else if (CP_D0_POL == "FALSE")
    {
        ntD0 <= D0;
    }

    if (CP_D1_POL == "TRUE")
    {
        operator V_INV D1_INV
            port map
            (
               I => D1,
               Z => ntD1
            ); 
    }
    else if (CP_D1_POL == "FALSE")
    {
        ntD1 <= D1;
    }

    if (CP_TD0_POL == "TRUE")
    {
        operator V_INV TD0_INV
            port map
            (
               I => TD0,
               Z => ntTD0
            ); 
    }
    else if (CP_TD0_POL == "FALSE")
    {  
        ntTD0 <= TD0;
    }
    if (CP_TD1_POL == "TRUE")
    {
        operator V_INV TD1_INV
            port map
            (
               I => TD1,
               Z => ntTD1
            );
    }
    else if (CP_TD1_POL == "FALSE")
    {
        ntTD1 <= TD1;
    }

    if (CP_Y_SEL == "DYN" && CP_TEST_EN0 == "DISABLE")
    {
        operator V_BUF DYN_CTRL0_BUF
            port map
            (
               I => ntDIN,
               Z => ntDYN_MUX0_O
            );
    }
    else if (CP_Y_SEL == "DYN" && CP_TEST_EN0 == "ENABLE")
    {
        operator V_MUX2 DYN_CTRL0_MUX
            port map
            (
                SEL =>  TQ,
                I0  =>  ntDIN,
                I1  =>  DQ,
                Z   =>  ntDYN_MUX0_O
            );
    }

    if (CP_IREG_SEL == "FALSE" || (CP_IREG_SEL == "TRUE" && CP_TEST_EN1 == "DISABLE"))
    {
        operator V_BUF DIN_ISERDES_BUF
            port map
            (
               I => ntDIN,
               Z => DIN_ISERDES
            );
    }
    else if (CP_IREG_SEL == "TRUE" && CP_TEST_EN1 == "ENABLE")
    {
        operator V_MUX2 DIN_ISERDES_MUX
            port map
            (
                SEL =>  TQ,
                I0  =>  ntDIN,
                I1  =>  DQ,
                Z   =>  DIN_ISERDES
            );
    }

//IREG IREG
    if (CP_DDR_EN == "ENABLE")
    {
        operator V_IDDR IDDR
            parameter map
            (
                GRS_EN  =>  GRS_EN,
                RS_TYPE => (CP_IREG_SET == "SET"   && CP_REG_SYNC == "ASYNC") ? "ASYNC_SET"   :
                           (CP_IREG_SET == "SET"   && CP_REG_SYNC == "SYNC" ) ? "SYNC_SET"    :
                           (CP_IREG_SET == "RESET" && CP_REG_SYNC == "ASYNC") ? "ASYNC_RESET" :
                           (CP_IREG_SET == "RESET" && CP_REG_SYNC == "SYNC" ) ? "SYNC_RESET"  : ""
            )
            port map
            (
                D   =>  DIN_ISERDES,
                RS  => (CP_ISR_EN   == "ENABLE" ) ? ntSR  : (CP_ISR_EN   == "DISABLE") ? 1'b0 : 1'bx,
                CLK => (CP_ICLK_EN  == "ENABLE" ) ? ntCLK : (CP_ICLK_EN  == "DISABLE") ? 1'b0 : 1'bx,
                CE  =>  CE_IREG,
                Q0  =>  Q0,
                Q1  =>  Q1
            );
    }
    else if (CP_ILATCH_EN == "ENABLE")
    {
        operator V_LAASYN LATCH
            parameter map
            (
                GRS_EN    =>  GRS_EN,
                SET_RESET =>  CP_IREG_SET,
                LRS_EN    =>  "TRUE"
            )
            port map
            (
                D   =>  DIN_ISERDES,
                SR  => (CP_ISR_EN   == "ENABLE" ) ? ntSR  : (CP_ISR_EN   == "DISABLE") ? 1'b0 : 1'bx,
                CK  => (CP_ICLK_EN  == "ENABLE" ) ? ntCLK : (CP_ICLK_EN  == "DISABLE") ? 1'b0 : 1'bx,
                CE  =>  CE_IREG,
                Q   =>  Q1
            );
    }
    else if (CP_REG_SYNC == "ASYNC")
    {
        operator V_FFASYN  IFF_FF
            parameter map
            (
                GRS_EN    =>  GRS_EN,
                SET_RESET =>  CP_IREG_SET,
                LRS_EN    =>  "TRUE"
            )
            port map
            (
                D   =>  DIN_ISERDES,
                SR  => (CP_ISR_EN   == "ENABLE" ) ? ntSR  : (CP_ISR_EN   == "DISABLE") ? 1'b0 : 1'bx,
                CK  => (CP_ICLK_EN  == "ENABLE" ) ? ntCLK : (CP_ICLK_EN  == "DISABLE") ? 1'b0 : 1'bx,
                CE  =>  CE_IREG,
                Q   =>  Q1
            );
    }
    else
    {
        operator V_FFSYN  IFF_FF
            parameter map
            (
                GRS_EN    =>  GRS_EN,
                SET_RESET =>  CP_IREG_SET,
                LRS_EN    =>  "TRUE"
            )
            port map
            (
                D   =>  DIN_ISERDES,
                SR  => (CP_ISR_EN   == "ENABLE" ) ? ntSR  : (CP_ISR_EN   == "DISABLE") ? 1'b0 : 1'bx,
                CK  => (CP_ICLK_EN  == "ENABLE" ) ? ntCLK : (CP_ICLK_EN  == "DISABLE") ? 1'b0 : 1'bx,
                CE  =>  CE_IREG,
                Q   =>  Q1
            );
    }

//OREG OREG
    if (CP_MIPI_EN == "DISABLE" && CP_DQMODE[0] == 1'b0 && CP_DQMODE[1] == 1'b1)
    {
        operator V_ODDR ODDR
            parameter map
            (
                GRS_EN  =>  GRS_EN,
                RS_TYPE => (CP_OREG_SET == "SET"   && CP_REG_SYNC == "ASYNC") ? "ASYNC_SET"   :
                           (CP_OREG_SET == "SET"   && CP_REG_SYNC == "SYNC" ) ? "SYNC_SET"    :
                           (CP_OREG_SET == "RESET" && CP_REG_SYNC == "ASYNC") ? "ASYNC_RESET" :
                           (CP_OREG_SET == "RESET" && CP_REG_SYNC == "SYNC" ) ? "SYNC_RESET"  : ""
            )
            port map
            (
                D0   => ntD0,
                D1   => ntD1,
                RS   => (CP_OSR_EN  == "ENABLE") ? ntSR  : (CP_OSR_EN  == "DISABLE") ? 1'b0 : 1'bx,
                CLK  => (CP_OCLK_EN == "ENABLE") ? ntCLK : (CP_OCLK_EN == "DISABLE") ? 1'b0 : 1'bx,
                CE   =>  CE_OREG,
                Q    =>  ntDQ_DDR
            );
    }

    if ((CP_MIPI_EN == "ENABLE"  && CP_IN0_SEL   == "TRUE") || 
        (CP_MIPI_EN == "DISABLE" && CP_DQMODE[0] == 1'b0 && CP_DQMODE[1] == 1'b0 && CP_IN0_SEL == "TRUE") || 
        (CP_MIPI_EN == "DISABLE" && CP_DQMODE[0] == 1'b1 && CP_DQMODE[1] == 1'b0))
    {
        if (CP_REG_SYNC == "ASYNC")
        {
            operator V_FFASYN  OFF_FF
                parameter map
                (
                    GRS_EN    =>  GRS_EN,
                    SET_RESET =>  CP_OREG_SET,
                    LRS_EN    =>  "TRUE"
                )
                port map
                (
                    D  =>  ntD0, 
                    SR => (CP_OSR_EN  == "ENABLE") ? ntSR  : (CP_OSR_EN  == "DISABLE") ? 1'b0 : 1'bx,
                    CK => (CP_OCLK_EN == "ENABLE") ? ntCLK : (CP_OCLK_EN == "DISABLE") ? 1'b0 : 1'bx,
                    CE =>  CE_OREG,
                    Q  =>  ntDQ_SDR
                );
        }
        else
        {
            operator V_FFSYN  OFF_FF
                parameter map
                (
                    GRS_EN    =>  GRS_EN,
                    SET_RESET =>  CP_OREG_SET,
                    LRS_EN    =>  "TRUE"
                )
                port map
                (
                    D  =>  ntD0, 
                    SR => (CP_OSR_EN  == "ENABLE") ? ntSR  : (CP_OSR_EN  == "DISABLE") ? 1'b0 : 1'bx,
                    CK => (CP_OCLK_EN == "ENABLE") ? ntCLK : (CP_OCLK_EN == "DISABLE") ? 1'b0 : 1'bx,
                    CE =>  CE_OREG,
                    Q  =>  ntDQ_SDR
                );
        }
    }

//TSREG TSREG
    if (CP_TQMODE == "DDR")
    {
        operator V_ODDR TSDDR
            parameter map
            (
                GRS_EN  =>  GRS_EN,
                RS_TYPE => (CP_TSREG_SET == "SET"   && CP_REG_SYNC == "ASYNC") ? "ASYNC_SET"   :
                           (CP_TSREG_SET == "SET"   && CP_REG_SYNC == "SYNC" ) ? "SYNC_SET"    :
                           (CP_TSREG_SET == "RESET" && CP_REG_SYNC == "ASYNC") ? "ASYNC_RESET" :
                           (CP_TSREG_SET == "RESET" && CP_REG_SYNC == "SYNC" ) ? "SYNC_RESET"  : ""
            )
            port map
            (
                D0   =>  ntTD0,
                D1   =>  ntTD1,
                RS   => (CP_TSR_EN  == "ENABLE") ? ntSR  : (CP_TSR_EN  == "DISABLE") ? 1'b0 : 1'bx,
                CLK  => (CP_OCLK_EN == "ENABLE") ? ntCLK : (CP_OCLK_EN == "DISABLE") ? 1'b0 : 1'bx,
                CE   =>  CE_TSREG,
                Q    =>  ntTQ_DDR
            );
    }

    if (CP_TQMODE == "SDR")
    {
        if (CP_REG_SYNC == "ASYNC")
        {
            operator V_FFASYN  TSFF_FF
                parameter map
                (
                    GRS_EN    =>  GRS_EN,
                    SET_RESET =>  CP_TSREG_SET,
                    LRS_EN    =>  "TRUE"
                )
                port map
                (
                    D  =>  ntTD0, 
                    SR => (CP_TSR_EN  == "ENABLE") ? ntSR  : (CP_TSR_EN  == "DISABLE") ? 1'b0 : 1'bx,
                    CK => (CP_OCLK_EN == "ENABLE") ? ntCLK : (CP_OCLK_EN == "DISABLE") ? 1'b0 : 1'bx,
                    CE =>  CE_TSREG,
                    Q  =>  ntTQ_SDR
                );
        }
        else
        {
            operator V_FFSYN  TSFF_FF
                parameter map
                (
                    GRS_EN    =>  GRS_EN,
                    SET_RESET =>  CP_TSREG_SET,
                    LRS_EN    =>  "TRUE"
                )
                port map
                (
                    D  =>  ntTD0, 
                    SR => (CP_TSR_EN  == "ENABLE") ? ntSR  : (CP_TSR_EN  == "DISABLE") ? 1'b0 : 1'bx,
                    CK => (CP_OCLK_EN == "ENABLE") ? ntCLK : (CP_OCLK_EN == "DISABLE") ? 1'b0 : 1'bx,
                    CE =>  CE_TSREG,
                    Q  =>  ntTQ_SDR
                );
        }
    }

// OUTPUTS
    // DQ AND DQ_CAS_OUT AND TQ AND TQ_CAS_OUT
    if (CP_PDIFF == "ENABLE" || CP_PDIFF == "DISABLE")
    {
        if (CP_MIPI_EN == "ENABLE")
        {
            operator V_MUX2 DQ_MUX_MIPI
                port map
                (
                    I0  => (CP_IN0_SEL == "FALSE") ? ntD0 : 
                           (CP_IN0_SEL == "TRUE" ) ? ntDQ_SDR : 1'bx,
                    I1  =>  DO_IN,
                    SEL =>  MIPI_SW_DYN_I,
                    Z   =>  DQ_OUT
                );
        }
        else if (CP_MIPI_EN == "DISABLE")
        {
            operator V_BUF DQ_OUT_BUF
                port map
                (
                    I   => (CP_DQMODE[0] == 1'b0 && CP_DQMODE[1] == 1'b0 && CP_IN0_SEL == "TRUE" ) ? ntDQ_SDR :
                           (CP_DQMODE[0] == 1'b0 && CP_DQMODE[1] == 1'b0 && CP_IN0_SEL == "FALSE") ? ntD0     :
                           (CP_DQMODE[0] == 1'b1 && CP_DQMODE[1] == 1'b0) ? ntDQ_SDR:
                           (CP_DQMODE[0] == 1'b0 && CP_DQMODE[1] == 1'b1) ? ntDQ_DDR:
                           (CP_DQMODE[0] == 1'b1 && CP_DQMODE[1] == 1'b1) ? DO_IN : 1'bx,
                    Z   =>  DQ_OUT
                );
        }

        operator V_BUF DQ_CAS_BUF
            port map
            (
                I   =>  (CP_OUTDLY_EN == "DISABLE") ? DQ_OUT :
                        (CP_OUTDLY_EN == "ENABLE") ? DQ_DLY_IN : 1'bx,
                Z   =>   DQ_CAS_OUT
            );

        operator V_BUF TQ_CAS_BUF
            port map
            (
                I   =>  (CP_TQMODE == "DD" ) ? ntTD0    :
                        (CP_TQMODE == "SDR") ? ntTQ_SDR :
                        (CP_TQMODE == "DDR") ? ntTQ_DDR :
                        (CP_TQMODE == "TIELO") ? 1'b0 : 1'bx,
                Z   =>   TQ_CAS_OUT
            );

        if (CP_PDIFF == "ENABLE")
        {
            operator V_INV DQ_BUF
                port map
                (
                    I   => DQ_CAS_IN,
                    Z   => DQ
                );
            operator V_BUF TQ_BUF
                port map
                (
                    I   =>  TQ_CAS_IN,
                    Z   =>  TQ
                );
        }
        else
        {
            DQ <= DQ_CAS_OUT;
            TQ <= TQ_CAS_OUT;
        }
    }

    // Y
    if (CP_Y_SEL == "STA" || CP_Y_SEL == "DQ" || CP_Y_SEL == "TQ")
    {
        operator V_BUF Y_BUF
            port map
            (
                I   => (CP_Y_SEL == "STA" && CP_MIPI_EN == "DISABLE") ? ntDIN :
                       (CP_Y_SEL == "STA" && CP_MIPI_EN == "ENABLE" ) ? DIN_MIPI :
                       (CP_Y_SEL == "DQ" ) ? DQ  : TQ,
                //I   => (CP_Y_SEL == "STA") ? ntDIN :
                //       (CP_Y_SEL == "DQ" ) ? DQ  : TQ,
                Z   =>  Y
            );
    }
    else
    {
        Y <= (CP_Y_SEL == "DYN") ? ntDYN_MUX0_O : 1'bx;
    }

    // CLK_SYS_SERDES
    if (CP_SCLK_EN == "ENABLE" && CP_CLK_POL == "FALSE")
    {
        operator V_BUF CLK_SYS_BUF
            port map
            (
                I   => ntCLK,
                Z   => CLK_SYS_SERDES
            );
    }
    else
    {
        CLK_SYS_SERDES <= (CP_SCLK_EN == "ENABLE" && CP_CLK_POL == "TRUE") ? ntCLK :
                          (CP_SCLK_EN  == "DISABLE") ? 1'b0 : 1'bx;
    }

    // SR_O
    if (CP_SR_POL == "FALSE")
    {
        operator V_BUF SR_O_BUF
            port map
            (
                I   => ntSR,
                Z   => SR_O
            );
    }
    else
    {
        SR_O <= ntSR;
    }

    // MIPI_SW_DYN AND INBUF_DYN_DIS_N
    operator V_BUF MIPI_SW_DYN_BUF
        port map
        (
            I   => MIPI_SW_DYN_I,
            Z   => MIPI_SW_DYN_O
        );
    operator V_BUF INBUF_DYN_DIS_N_BUF
        port map
        (
            I   => INBUF_DYN_DIS_N_I,
            Z   => INBUF_DYN_DIS_N_O
        );
};
