*******************************************************************

  Package   [pango_floorplan_funcs]

  Author    [jiang tao]

  Abstract  [Floorplan description common to pango architecture]

  Revision History:

********************************************************************************/
library work;
USE pgc_defs, pgc2k_defs, pango_defs;

package pgc_floorplan_funcs
{
    unsigned int fsx = 0;
    unsigned int fsy = 0;
    
    function get_coordinate_of_iol
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int col_gap = 7;
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        //adjust floorplan gap
        if(lsx > 54)//blank column
        {
            tmp_x = lsx-NUM_GRID_X;
        }
        
        if(lsy > 84)//blank column
        {
            tmp_y = lsy-NUM_GRID_Y;
        }
        
        if (lsy <= 10)
        {
            int tem = tmp_x/6-1;
            if (lsx > 46)
            {
                tem = tem + 1;
            }
            
            if (lsx == 10)
            {
                fsx = 16;
                if (tmp_y % 2 == 1)
                {
                    fsy = tmp_y-3+1;
                }
                else
                {
                    fsy = tmp_y-3-1;
                }
            }
            else if (lsx == 94)
            {
                fsx = 44;
                if (tmp_y % 2 == 1)
                {
                    fsy = tmp_y-3+1;
                }
                else
                {
                    fsy = tmp_y-3-1;
                }
            }
            else if (tem%2 == 1)
            {
                fsx = 20+((tem-1)/2)*4;
                if (tmp_y % 2 == 1)
                {
                    fsy = tmp_y-7+1;
                }
                else
                {
                    fsy = tmp_y-7-1;
                }
            }
            else
            {
                fsx = 20+((tem-1)/2)*4;
                if (tmp_y % 2 == 1)
                {
                    fsy = tmp_y-3+1;
                }
                else
                {
                    fsy = tmp_y-3-1;
                }
            }
            
            if (lsx > 48 && lsx < 90)
            {
                fsx = fsx - 4;
            }
        }
        else if (lsy > 156)
        {
            int tem = tmp_x/6-1;
            if (lsx > 46)
            {
                tem = tem + 1;
            }
            
            if (lsx == 10)
            {
                fsx = 16;
                if (tmp_y % 2 == 1)
                {
                    fsy = tmp_y-120+1;
                }
                else
                {
                    fsy = tmp_y-120-1;
                }
            }
            else if (lsx == 94)
            {
                fsx = 44;
                if (tmp_y % 2 == 1)
                {
                    fsy = tmp_y-120+1;
                }
                else
                {
                    fsy = tmp_y-120-1;
                }
            }
            else if (tem%2 == 1)
            {
                fsx = 20+((tem-1)/2)*4;
                if (tmp_y % 2 == 1)
                {
                    fsy = tmp_y-120+1;
                }
                else
                {
                    fsy = tmp_y-120-1;
                }
            }
            else
            {
                fsx = 20+((tem-1)/2)*4;
                if (tmp_y % 2 == 1)
                {
                    fsy = tmp_y-116+1;
                }
                else
                {
                    fsy = tmp_y-116-1;
                }
            }
            fsy = fsy + 3;
            
            if (lsx > 48 && lsx < 90)
            {
                fsx = fsx - 4;
            }
        }
        else if (lsx < 11)
        {
            if (lsy/6 >= 21)
            {
                fsx = ((lsy/6-1)%4)*4;
            }
            else
            {
                fsx = ((lsy/6)%4)*4;
            }
            
            int idx = lsy / 6 / 4;
            if (lsy/6 == 24)
            {
                idx = idx - 1;
            }
            fsy = 9 + (idx-1)*4+lsy%6;
        }
        else if (lsx > 90)
        {
            if (lsy/6 >= 21)
            {
                fsx = ((lsy/6-1)%4)*4+44;
            }
            else
            {
                fsx = ((lsy/6)%4)*4+44;
            }
            
            int idx = lsy / 6 / 4;
            if (lsy/6 == 24)
            {
                idx = idx - 1;
            }
            fsy = 9 + (idx-1)*4+lsy%6;
        }
    };
    
    function get_coordinate_of_ioldly
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        //adjust floorplan gap
        if(lsx > 54)//blank column
        {
            tmp_x = lsx-NUM_GRID_X;
        }
        
        if(lsy > 84)//blank column
        {
            tmp_y = lsy-NUM_GRID_Y;
        }
        
        if (lsy <= 10)
        {
            int tem = tmp_x/6-1;
            if (lsx > 45)
            {
                tem = tem + 1;
            }
            
            if (lsx == 9)
            {
                fsx = 18;
                if (tmp_y % 2 == 1)
                {
                    fsy = tmp_y-3+1;
                }
                else
                {
                    fsy = tmp_y-3-1;
                }
            }
            else if (lsx == 93)
            {
                fsx = 46;
                if (tmp_y % 2 == 1)
                {
                    fsy = tmp_y-3+1;
                }
                else
                {
                    fsy = tmp_y-3-1;
                }
            }
            else if (tem%2 == 1)
            {
                fsx = 22+((tem-1)/2)*4;
                if (tmp_y % 2 == 1)
                {
                    fsy = tmp_y-7+1;
                }
                else
                {
                    fsy = tmp_y-7-1;
                }
            }
            else
            {
                fsx = 22+((tem-1)/2)*4;
                if (tmp_y % 2 == 1)
                {
                    fsy = tmp_y-3+1;
                }
                else
                {
                    fsy = tmp_y-3-1;
                }
            }
            
            if (lsx > 48 && lsx < 90)
            {
                fsx = fsx - 4;
            }
        }
        else if (lsy >= 156)
        {
            int tem = tmp_x/6-1;
            if (lsx > 45)
            {
                tem = tem + 1;
            }
            
            if (lsx == 9)
            {
                fsx = 18;
                if (tmp_y % 2 == 1)
                {
                    fsy = tmp_y-121+1;
                }
                else
                {
                    fsy = tmp_y-121-1;
                }
            }
            else if (lsx == 93)
            {
                fsx = 46;
                if (tmp_y % 2 == 1)
                {
                    fsy = tmp_y-121+1;
                }
                else
                {
                    fsy = tmp_y-121-1;
                }
            }
            else if (tem%2 == 1)
            {
                fsx = 22+((tem-1)/2)*4;
                if (tmp_y % 2 == 1)
                {
                    fsy = tmp_y-121+1;
                }
                else
                {
                    fsy = tmp_y-121-1;
                }
            }
            else
            {
                fsx = 22+((tem-1)/2)*4;
                if (tmp_y % 2 == 1)
                {
                    fsy = tmp_y-117+1;
                }
                else
                {
                    fsy = tmp_y-117-1;
                }
            }
            fsy = fsy + 4;
            
            if (lsx > 48 && lsx < 90)
            {
                fsx = fsx - 4;
            }
        }
        else if (lsx < 11)
        {
            if (lsy/6 >= 21)
            {
                fsx = ((lsy/6-1)%4)*4+2;
            }
            else
            {
                fsx = ((lsy/6)%4)*4+2;
            }
            
            int idx = lsy / 6 / 4;
            if (lsy/6 == 24)
            {
                idx = idx - 1;
            }
            fsy = 9 + (idx-1)*4+lsy%6;
        }
        else if (lsx > 90)
        {
            if (lsy/6 >= 21)
            {
                fsx = ((lsy/6-1)%4)*4+46;
            }
            else
            {
                fsx = ((lsy/6)%4)*4+46;
            }
            
            int idx = lsy / 6 / 4;
            if (lsy/6 == 24)
            {
                idx = idx - 1;
            }
            fsy = 9 + (idx-1)*4+lsy%6;
        }
    };
    
    
    function get_coordinate_of_oserdes
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        tmp_y = lsy - 4;
        if (tmp_y/6 >= 21)
        {
            fsx = ((tmp_y/6-1)%4)*4+3;
        }
        else
        {
            fsx = ((tmp_y/6)%4)*4+3;
        }
        
        int idx = tmp_y / 6 / 4;
        if (tmp_y/6 == 24)
        {
            idx = idx - 1;
        }
        fsy = 9 + (idx-1)*4+tmp_y%6;
    };
    
    function get_coordinate_of_iserdes
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        tmp_y = lsy - 4;
        if (tmp_y/6 >= 21)
        {
            fsx = ((tmp_y/6-1)%4)*4+47;
        }
        else
        {
            fsx = ((tmp_y/6)%4)*4+47;
        }
        
        int idx = tmp_y / 6 / 4;
        if (tmp_y/6 == 24)
        {
            idx = idx - 1;
        }
        fsy = 9 + (idx-1)*4+tmp_y%6;
    };
    
    function get_coordinate_of_bkcl
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        
        if (lsy < 5)
        {
            fsx = 29;
            if (lsx<48)
            {
                fsx = 18;
            }
            else if (lsx>48)
            {
                fsx = 38;
            }
            fsy = 9;
        }
        else if (lsy > 160)
        {
            fsx = 29;
            fsy = 33;
        }
        else
        {
            fsx = 31+(lsx/6-7)*2;
            fsy = 18;
        }
    };
        
    function get_coordinate_of_iob
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int col_gap = 7;
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        //adjust floorplan gap
        if(lsx > 54)//blank column
        {
            tmp_x = lsx-NUM_GRID_X;
        }
        
        if(lsy > 84)//blank column
        {
            tmp_y = lsy-NUM_GRID_Y;
        }
        
        if (lsy < 5)
        {
            int tem = tmp_x/6-1;
            if (lsx > 45)
            {
                tem = tem+1;
            }
            
            if (lsx < 10)
            {
                fsx = 17;
                if (tmp_x % 2 == 1)
                {
                    fsy = 7-tmp_x%6+1;
                }
                else
                {
                    fsy = 7-tmp_x%6-1;
                }
            }
            else if (lsx >= 90)
            {
                fsx = 45;
                if (tmp_x % 2 == 1)
                {
                    fsy = 7-tmp_x%6+1;
                }
                else
                {
                    fsy = 7-tmp_x%6-1;
                }
            }
            else if (tem%2 == 1)
            {
                fsx = 21+((tem-1)/2)*4;
                if (tmp_x % 2 == 1)
                {
                    fsy = 3-tmp_x%6+1;
                }
                else
                {
                    fsy = 3-tmp_x%6-1;
                }
            }
            else
            {
                fsx = 21+((tem-1)/2)*4;
                if (tmp_x % 2 == 1)
                {
                    fsy = 7-tmp_x%6+1;
                }
                else
                {
                    fsy = 7-tmp_x%6-1;
                }
            }
            
            if (lsx > 48 && lsx < 90)
            {
                fsx = fsx - 4;
            }
        }
        else if (lsy >= 162)
        {
            int tem = tmp_x/6-1;
            if (lsx > 45)
            {
                tem = tem + 1;
            }
            
            if (lsx < 10)
            {
                fsx = 17;
                if (tmp_x % 2 == 1)
                {
                    fsy = 33-tmp_x%6+1;
                }
                else
                {
                    fsy = 33-tmp_x%6-1;
                }
            }
            else if (lsx >= 90)
            {
                fsx = 45;
                if (tmp_x % 2 == 1)
                {
                    fsy = 33-tmp_x%6+1;
                }
                else
                {
                    fsy = 33-tmp_x%6-1;
                }
            }
            else if (tem%2 == 1)
            {
                fsx = 21+((tem-1)/2)*4;
                if (tmp_x % 2 == 1)
                {
                    fsy = 33-tmp_x%6+1;
                }
                else
                {
                    fsy = 33-tmp_x%6-1;
                }
            }
            else
            {
                fsx = 21+((tem-1)/2)*4;
                if (tmp_x % 2 == 1)
                {
                    fsy = 37-tmp_x%6+1;
                }
                else
                {
                    fsy = 37-tmp_x%6-1;
                }
            }
            fsy = fsy + 4;
            
            if (lsx > 48 && lsx < 90)
            {
                fsx = fsx - 4;
            }
        }
        else if (lsx < 5)
        {
            tmp_y = lsy + 1;
            if (tmp_y/6 >= 21)
            {
                fsx = ((tmp_y/6-1)%4)*4+1;
            }
            else
            {
                fsx = ((tmp_y/6)%4)*4+1;
            }
            
            int idx = tmp_y / 6 / 4;
            if (tmp_y/6 == 24)
            {
                idx = idx - 1;
            }
            fsy = 9 + (idx-1)*4+tmp_y%6;
        }
        else if (lsx > 95)
        {
            tmp_y = lsy + 1;
            if (tmp_y/6 >= 21)
            {
                fsx = ((tmp_y/6-1)%4)*4+45;
            }
            else
            {
                fsx = ((tmp_y/6)%4)*4+45;
            }
            
            int idx = tmp_y / 6 / 4;
            if (lsy/6 == 24)
            {
                idx = idx - 1;
            }
            fsy = 9 + (idx-1)*4+tmp_y%6;
        }
    };        
    
    function get_coordinate_of_clm
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int col_gap = 7;
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        //adjust floorplan gap
        if(lsx > 53)//blank column
        {
            tmp_x = lsx-NUM_GRID_X;
        }
        
        if(lsy > 83)//blank column
        {
            tmp_y = lsy-NUM_GRID_Y;
        }
        
        fsx = 2*(tmp_x/NUM_GRID_X)+14+tmp_y%2;
        fsy = tmp_y/NUM_GRID_Y+6;
        
        if (tmp_x >= 57)//blank column
        {
            fsx = fsx+2;
        }
        
        fsy = fsy + 2;
    };
    
    function get_coordinate_of_drm
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        //adjust floorplan gap
        if(lsx > 53)//blank column
        {
            tmp_x = lsx-NUM_GRID_X;
        }
        
        if(lsy > 83)//blank column
        {
            tmp_y = lsy-NUM_GRID_Y;
        }
        
        fsx = 2*(tmp_x/6)+14+tmp_y%2+1;
        fsy = tmp_y/6+8;
    };
    
    function get_coordinate_of_uscmdc
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        fsx = 32;
        fsy = lsy/6+lsy%6+((lsx-1)%2)*8-4;
    };
    
    function get_coordinate_of_uscmd
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        fsx = 32;
        fsy = lsy%3+23;
    };
    
    function get_coordinate_of_iockbrg
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        fsx = 33;
        fsy = lsy/6-3;
    };
    
    function get_coordinate_of_iockgate
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        if (lsx<56)
        {
            fsx = 13;
            fsy = 21;
        }
        else
        {
            fsx = 49;
            fsy = 21;
        }
    };
    
    function get_coordinate_of_clkdiv
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        if (lsx<56)
        {
            fsx = 14;
        }
        else
        {
            fsx = 50;
        }
        fsy = 21;
    };
    
    function get_coordinate_of_clkdly
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        if (lsx<54)
        {
            fsx = 12;
            fsy = 20-(lsy%2);
        }
        else if ((lsx == 55 || lsx == 54) && lsy < 12)
        {
            fsx = 32+(lsy%3);
            fsy = 9;
        }
        else if (lsx == 54 && lsy == 156)
        {
            fsx = 31;
            fsy = 35;
        }
        else
        {
            fsx = 48;
            fsy = 20-(lsy%2);
        }
    };
    
    function get_coordinate_of_dll
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        if (lsx == 9)
        {
            fsx = 17;
            fsy = 30;
        }
        else
        {
            fsx = 44;
            fsy = 9;
        }
    };
    
    function get_coordinate_of_mfgtest
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        fsx = 17;
        fsy = 27;
    };
    
    function get_coordinate_of_ldo
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        fsx = 17;
        fsy = 28;
    };
    
    function get_coordinate_of_osc
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        fsx = 17;
        fsy = lsy/6+6;
    };
    
    
    ///*****Place CLM*****/
    function place_clm_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        unsigned int lsx1, lsy1;
    
        // device reference variables
        &device s0Ref, s0fl;
        &device s1Ref, s1fl;
        
        string strVar;
        
        lsx = tx * NUM_GRID_X + 3;
        lsy = ty * NUM_GRID_Y;
        
        lsx0 = lsx;
        lsy0 = lsy + 1;
        
        s0Ref  = <device CLMS  @[lsx0, lsy0]     of ARCHITECTURE>;
        sprintf(strVar, "CLMS_%d_%d", lsx0, lsy0);
        
        get_coordinate_of_clm(lsx0, lsy0);
        
        s0fl = device CLMS ( structure fp_struct ) *strVar @[fsx, fsy];
        printf("%s: %d, %d.", strVar, fsx, fsy);
        
        lsx1 = lsx;
        lsy1 = lsy;
        
        s1Ref  = <device CLMA  @[lsx1, lsy1]     of ARCHITECTURE>;
        sprintf(strVar, "CLMA_%d_%d", lsx1, lsy1);
        
        get_coordinate_of_clm(lsx1, lsy1);
        
        printf("%s: %d, %d.", strVar, fsx, fsy);
        s1fl = device CLMA ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref,
              s1fl => s1Ref );
        
    }; // end of function place_clm_tile_fp
    
    
    function draw_clm_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0, lsx1, lsy1;
        unsigned int offset_y = 0;
    
        // device reference variables
        &device s0Ref, s0fl;
        &device s1Ref, s1fl;
        
        string strVar;
        
        lsx = tx * NUM_GRID_X + 3;
        lsy = ty * NUM_GRID_Y;
        
        lsx0 = lsx;
        lsy0 = lsy + 1;
        get_coordinate_of_clm(lsx0, lsy0);
        if (fsy > 21)
        {
            offset_y = 320;
        }
        
        // Instantiate the device. 
        sprintf(strVar, "CLMS_%d_%d", lsx0, lsy0);
        s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s0fl = device CLMS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
        map ( s0fl => s0Ref );
        
        lsx1 = lsx;
        lsy1 = lsy;
        offset_y = 0;
        get_coordinate_of_clm(lsx1, lsy1);
        if (fsy > 21)
        {
            offset_y = 320;
        }
       
        // Instantiate the device. 
        sprintf(strVar, "CLMA_%d_%d", lsx1, lsy1);
        s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        
        s1fl = device CLMA ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
         
        map ( s1fl => s1Ref );
              
    }; // end of function draw_clm_tile_fp
    
    
    ///*****Place IOL*****/
    function place_iol_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty,
        unsigned int flag
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int i;
        unsigned int indexs[] = {1, 2, 3, 4};
        unsigned int lsx1, lsy1;
        
        // device reference variables
        &device s0Ref, s1Ref, s2Ref, s3Ref, s0fl, s1fl, s2fl, s3fl;
        
        string strVar;
        if (flag == 2)
        {
            ///*****IOL*****/
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X + 3;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1 + 1;
                lsy = lsy1 + i;
                
                s0Ref  = <device IOL  @[lsx, lsy]     of ARCHITECTURE>;
                sprintf(strVar, "IOL_%d_%d", lsx, lsy);
                
                get_coordinate_of_iol(lsx, lsy);
                
                printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOL ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
                
                lsx = lsx1;
                lsy = lsy1 + i;
                
                s0Ref  = <device IOLDLYS  @[lsx, lsy]     of ARCHITECTURE>;
                sprintf(strVar, "IOLDLYS_%d_%d", lsx, lsy);
        
                get_coordinate_of_ioldly(lsx, lsy);
                
                printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOLDLYS ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            ///*****OSERDES*****///
            lsx1 = tx * NUM_GRID_X + 3;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1 + 1;
            lsy = lsy1 + 5;
            
            s0Ref  = <device OSERDES  @[lsx, lsy]     of ARCHITECTURE>;
            sprintf(strVar, "OSERDES_%d_%d", lsx, lsy);
            
            get_coordinate_of_oserdes(lsx, lsy);
            
            printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device OSERDES ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        ///*****RIGHT*****///
        else if (flag == 3)
        {
            ///*****IOL*****/
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X + 3;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1 + 1;
                lsy = lsy1 + i;
                
                s0Ref  = <device IOL  @[lsx, lsy]     of ARCHITECTURE>;
                sprintf(strVar, "IOL_%d_%d", lsx, lsy);

                get_coordinate_of_iol(lsx, lsy);
                
                printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOL ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            ///*****IOLDLY*****///
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X + 3;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1;
                lsy = lsy1 + i;
                
                s0Ref  = <device IOLDLY  @[lsx, lsy]     of ARCHITECTURE>;
                sprintf(strVar, "IOLDLY_%d_%d", lsx, lsy);
        
                get_coordinate_of_ioldly(lsx, lsy);
                
                printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOLDLY ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            ///*****ISERDES*****///
            lsx1 = tx * NUM_GRID_X + 3;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1 + 1;
            lsy = lsy1 + 5;
            
            s0Ref  = <device ISERDES  @[lsx, lsy]     of ARCHITECTURE>;
            sprintf(strVar, "ISERDES_%d_%d", lsx, lsy);
            
            get_coordinate_of_iserdes(lsx, lsy);
            
            printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device ISERDES ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        else if (flag == 0 || flag == 1 || flag == 4 || flag == 5)
        {
            ///*****IOL*****/
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X + 3;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1 + 1;
                lsy = lsy1 + i;
                
                s0Ref  = <device IOL  @[lsx, lsy]     of ARCHITECTURE>;
                sprintf(strVar, "IOL_%d_%d", lsx, lsy);

                get_coordinate_of_iol(lsx, lsy);
                
                printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOL ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            ///*****IOLDLYS*****///
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X + 3;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1;
                lsy = lsy1 + i;
                
                s0Ref  = <device IOLDLYS  @[lsx, lsy]     of ARCHITECTURE>;
                sprintf(strVar, "IOLDLYS_%d_%d", lsx, lsy);
        
                get_coordinate_of_ioldly(lsx, lsy);
                
                printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOLDLYS ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
        }
    }; // end of function place_iol_tile_fp
    
    
    function draw_iol_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty,
        unsigned int flag
    )
    {
        unsigned int lsx, lsy;
        
        // device reference variables
        &device s0Ref, s1Ref, s2Ref, s0fl, s1fl, s2fl;
        
        lsx = tx * NUM_GRID_X + 3;
        lsy = ty * NUM_GRID_Y;
        
        string strVar;
        
        // Instantiate the device.
        unsigned int i; 
        unsigned int indexs[] = {1, 2, 3, 4};
        unsigned int lsx1, lsy1;
        
        if (flag == 2)
        {
            foreach i (indexs)
            {
                unsigned int offset_y = 0;
                lsx1 = lsx + 1;
                lsy1 = lsy + i;
                
                get_coordinate_of_iol(lsx1, lsy1);
                
                if (fsy > 21)
                {
                    offset_y = 320;
                }
                sprintf(strVar, "IOL_%d_%d", lsx1, lsy1); 
                s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
                s0fl = device IOL ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                
                offset_y = 0;
                get_coordinate_of_ioldly(lsx, lsy1);
                if (fsy > 21)
                {
                    offset_y = 320;
                }
                sprintf(strVar, "IOLDLYS_%d_%d", lsx, lsy1);
                s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
                s1fl = device IOLDLYS ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref,
                      s1fl => s1Ref);
                
                if (i == 1) 
                {
                    lsx1 = lsx + 1;
                    lsy1 = lsy + 5;
            
                    offset_y = 0;
                    get_coordinate_of_oserdes(lsx1, lsy1);
                    if (fsy > 21)
                    {
                        offset_y = 320;
                    }
                
                    sprintf(strVar, "OSERDES_%d_%d", lsx1, lsy1);
                    s2Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
                    s2fl = device OSERDES ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                    map ( s2fl => s2Ref);
                }
            }
        }
        else if (flag == 3)
        {
            foreach i (indexs)
            {
                unsigned int offset_y = 0;
                lsx1 = lsx + 1;
                lsy1 = lsy + i;
                
                get_coordinate_of_iol(lsx1, lsy1);
                if (fsy > 21)
                {
                    offset_y = 320;
                }
                
                ///***Draw IOL***/
                sprintf(strVar, "IOL_%d_%d", lsx1, lsy1);
                s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
                s0fl = device IOL ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref );
                
                offset_y = 0;
                get_coordinate_of_ioldly(lsx, lsy1);
                if (fsy > 21)
                {
                    offset_y = 320;
                }
                sprintf(strVar, "IOLDLY_%d_%d", lsx, lsy1);
                s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
                s1fl = device IOLDLY ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                
                map ( s1fl => s1Ref);
                
                if (i == 1)
                {
                    lsx1 = lsx + 1;
                    lsy1 = lsy + 5;
                    
                    offset_y = 0;
                    get_coordinate_of_iserdes(lsx1, lsy1);
                    if (fsy > 21)
                    {
                        offset_y = 320;
                    }
            
                    sprintf(strVar, "ISERDES_%d_%d", lsx1, lsy1);
                    s2Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
                    s2fl = device ISERDES ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                    map ( s2fl => s2Ref);
                } 
            }
        }
        else if (flag == 0 || flag == 1 || flag == 4 || flag == 5)
        {
            unsigned int offset_x;
            foreach i (indexs)
            {
                unsigned int offset_y = 0;
                lsx1 = lsx + 1;
                lsy1 = lsy + i;
                
                sprintf(strVar, "IOL_%d_%d", lsx1, lsy1);
                
                get_coordinate_of_iol(lsx1, lsy1);
                if (fsy > 21)
                {
                    offset_y = 320;
                }
                
                s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
                s0fl = device IOL ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref );   
                 
                sprintf(strVar, "IOLDLYS_%d_%d", lsx, lsy1);
                offset_y = 0;
                get_coordinate_of_ioldly(lsx, lsy1);
                if (fsy > 21)
                {
                    offset_y = 320;
                }
                s1Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
                s1fl = device IOLDLYS ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s1fl => s1Ref);
            }
        }  
    }; // end of function draw_iol_tile_fp
    
    
    ///*****IOBS *BSD_N*****/
    function place_iobs_bsd_n
    (
        unsigned int tx,
        unsigned int ty,
        unsigned int indexs[]
    )
    {
        unsigned int lsx1, lsy1;
        unsigned int lsx, lsy;
        unsigned int i;
        unsigned int offset_iobsdn[13:0] = {19, 25, 31, 43, 49, 55, 61, 67, 91, 97, 121, 127, 133, 139};
        
        // device reference variables
        &device s0Ref, s0fl;
        
        foreach i (indexs)
        {
            lsx1 = tx * NUM_GRID_X;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1;
            lsy = lsy1 + offset_iobsdn[i];
            
            s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
            string strVar;
            sprintf(strVar, "IOBS_%d_%d", lsx, lsy); 
            
            get_coordinate_of_iob(lsx, lsy);
            
            printf("%s: %d, %d.", strVar, fsx, fsy);                 
            s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
    };
    
    function place_iobs_bsd_p
    (
        unsigned int tx,
        unsigned int ty,
        unsigned int indexs[]
    )
    {
        unsigned int lsx1, lsy1;
        unsigned int lsx, lsy;
        unsigned int i;
        unsigned int offset_iobsdn[13:0] = {19, 25, 31, 43, 49, 55, 61, 67, 91, 97, 121, 127, 133, 139};
        
        // device reference variables
        &device s0Ref, s0fl;
        
        foreach i (indexs)
        {
            lsx1 = tx * NUM_GRID_X;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1;
            lsy = lsy1 + offset_iobsdn[i]-1;
            
            string strVar;
            s0Ref  = <device IOBD  @[lsx, lsy]     of ARCHITECTURE>;
            sprintf(strVar, "IOBD_%d_%d", lsx, lsy);
               
            get_coordinate_of_iob(lsx, lsy);
            
            printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device IOBD ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        
        
        lsx = tx * NUM_GRID_X;
        lsy = ty * NUM_GRID_Y;
        
        lsx = lsx + 2;
        lsy = lsy + 64;
            
        s0Ref  = <device BKCL  @[lsx, lsy]     of ARCHITECTURE>;
        string strVar;
        sprintf(strVar, "BKCL_%d_%d", lsx, lsy);
        
        get_coordinate_of_bkcl(lsx, lsy);
        
        printf("%s: %d, %d.", strVar, fsx, fsy);
        s0fl = device BKCL ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref);
    };
    
    ///*****IOBS *BSS_P*****/
    function place_iobs_bss_p
    (
        unsigned int tx,
        unsigned int ty,
        unsigned int indexs[]
    )
    {
        unsigned int lsx1, lsy1;
        unsigned int lsx, lsy;
        unsigned int i;
        unsigned int offset_iobsdn[13:0] = {19, 25, 31, 43, 49, 55, 61, 67, 91, 97, 121, 127, 133, 139};
        
        // device reference variables
        &device s0Ref, s0fl;
        
        foreach i (indexs)
        {
            lsx1 = tx * NUM_GRID_X;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1;
            lsy = lsy1 + offset_iobsdn[i]+1;
            
            s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
            string strVar;
            sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
               
            get_coordinate_of_iob(lsx, lsy);
            
            printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
    };
    
    ///*****IOBS *BSS_N*****/
    function place_iobs_bss_n
    (
        unsigned int tx,
        unsigned int ty,
        unsigned int indexs[]
    )
    {
        unsigned int lsx1, lsy1;
        unsigned int lsx, lsy;
        unsigned int i;
        unsigned int offset_iobsdn[13:0] = {19, 25, 31, 43, 49, 55, 61, 67, 91, 97, 121, 127, 133, 139};
        
        // device reference variables
        &device s0Ref, s0fl;
        
        foreach i (indexs)
        {
            lsx1 = tx * NUM_GRID_X;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1;
            lsy = lsy1 + offset_iobsdn[i]+2;
            
            s0Ref  = <device IOBS  @[lsx,lsy]     of ARCHITECTURE>;
            string strVar;
            sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
               
            get_coordinate_of_iob(lsx, lsy);
            
            printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
    };
    
     ///*****IOB Left/
    function place_iobl_tile_fp
    (
        unsigned int tx,
        unsigned int ty
    )
    {
        unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};
        
        ///*****IOBS *BSD_N*****/
        place_iobs_bsd_n(tx, ty, indexs);
        
        ///*****IOBD *BSD_P*****/
        place_iobs_bsd_p(tx, ty, indexs);
        
        ///*****IOBS *BSS_P*****/
        place_iobs_bss_p(tx, ty, indexs);
        
        ///*****IOBS *BSS_N*****/
        place_iobs_bss_n(tx, ty, indexs);
    }
    
    ///*****IOBR *BSR_N*****/
    function place_iobr_bsr_n
    (
        unsigned int tx,
        unsigned int ty,
        unsigned int indexs[]
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx1, lsy1;
        unsigned int i;
        unsigned int offset_iobsrn[27:0] = {19, 21, 25, 27, 31, 33, 43, 45, 49, 51, 55, 57, 61, 63, 67, 69, 91, 93, 97, 99, 121, 123, 127, 129, 133, 135, 139, 141};
        
        // device reference variables
        &device s0Ref, s0fl;         
        
        foreach i (indexs)
        {
            lsx1 = tx * NUM_GRID_X;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1;
            lsy = lsy1 + offset_iobsrn[i];
            
            s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
            string strVar;
            sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
            
            get_coordinate_of_iob(lsx, lsy);
            
            printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
    };
    
    ///*****IOBR *BSR_P*****/
    function place_iobr_bsr_p
    (  
        unsigned int tx,
        unsigned int ty,
        unsigned int indexs[]
    )  
    {  
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx1, lsy1;
        unsigned int i;
        unsigned int offset_iobsrn[27:0] = {19, 21, 25, 27, 31, 33, 43, 45, 49, 51, 55, 57, 61, 63, 67, 69, 91, 93, 97, 99, 121, 123, 127, 129, 133, 135, 139, 141};
        
        // device reference variables
        &device s0Ref, s0fl;         
        
        foreach i (indexs)
        {
            lsx1 = tx * NUM_GRID_X;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1;
            lsy = lsy1 + offset_iobsrn[i] - 1;
            
            s0Ref  = <device IOBR  @[lsx, lsy]     of ARCHITECTURE>;
            string strVar;
            sprintf(strVar, "IOBR_%d_%d", lsx, lsy);
            
            get_coordinate_of_iob(lsx, lsy);
            
            printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device IOBR ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        
        lsx = tx * NUM_GRID_X;
        lsy = ty * NUM_GRID_Y;
        
        lsx = lsx + 2;
        lsy = lsy + 64;
            
        s0Ref  = <device BKCL  @[lsx, lsy]     of ARCHITECTURE>;
        string strVar;
        sprintf(strVar, "BKCL_%d_%d", lsx, lsy);
        
        get_coordinate_of_bkcl(lsx, lsy);
        
        printf("%s: %d, %d.", strVar, fsx, fsy);
        s0fl = device BKCL ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref);
    }; 
    
    ///*****IOB Right/
    function place_iobr_tile_fp
    (
        unsigned int tx,
        unsigned int ty
    )
    {
        unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27};
        
        ///*****IOBS *BSR_N*****/
        place_iobr_bsr_n(tx, ty, indexs);
        
        ///*****IOBR *BSR_P*****/
        place_iobr_bsr_p(tx, ty, indexs);
    };
    
    ///*****Place IOB*****/  
    function place_ioblr_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty,
        unsigned int flag
    )
    {
        if (flag == 0)
        {       
            place_iobl_tile_fp(tx, ty);
        }
        else if (flag == 1)
        {
            place_iobr_tile_fp(tx, ty);  
        }
    } // end of function place_ioblr_tile_fp
    
    ///*****Draw IOB*****/  
    ///*****Right*****/
    function draw_ioblr_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty,
        unsigned int flag
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx1, lsy1;
        string strVar;
        unsigned int i;
        unsigned int offset_iobsdn[13:0] = {19, 25, 31, 43, 49, 55, 61, 67, 91, 97, 121, 127, 133, 139};
        
        
        // device reference variables
        &device s0Ref, s0fl;
        
        lsx = tx * NUM_GRID_X;
        lsy = ty * NUM_GRID_Y;
        if (flag == 0)
        {   
            unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};
            
            ///*****IOBS *BSS_N*****/
            foreach i (indexs)
            {
                lsx1 = lsx;
                lsy1 = lsy + offset_iobsdn[i] + 2;
                
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 21)
                {
                    offset_y = 320;
                }
                
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                
                map ( s0fl => s0Ref);
            }
            
            ///*****IOBS *BSS_P*****/
            foreach i (indexs)
            {
                lsx1 = lsx;
                lsy1 = lsy + offset_iobsdn[i] + 1;
                
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar          of ARCHITECTURE (structure fp_struct)>;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 21)
                {
                    offset_y = 320;
                }
                
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref);
            }
            
            /////*****IOBS *BSD_N*****/
            foreach i (indexs)
            {
                lsx1 = lsx;
                lsy1 = lsy + offset_iobsdn[i];
                
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar          of ARCHITECTURE (structure fp_struct)>;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 21)
                {
                    offset_y = 320;
                }
                
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref);
            }
            
            ///*****IOBS *BSD_P*****/
            foreach i (indexs)
            {
                lsx1 = lsx;
                lsy1 = lsy + offset_iobsdn[i] - 1;
                
                // Instantiate the device.
                sprintf(strVar, "IOBD_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar          of ARCHITECTURE (structure fp_struct)>;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 21)
                {
                    offset_y = 320;
                }
                
                s0fl = device IOBD ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref);
            }
            
            lsx1 = lsx + 2;
            lsy1 = lsy + 64;
                
            // Instantiate the device.
            sprintf(strVar, "BKCL_%d_%d", lsx1, lsy1);
            s0Ref  = <instance  *strVar          of ARCHITECTURE (structure fp_struct)>;
            
            unsigned int offset_y = 0;
            get_coordinate_of_bkcl(lsx1, lsy1);
            if (fsy > 21)
            {
                offset_y = 320;
            }
            
            s0fl = device BKCL ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);  
        }
        else if (flag == 1)
        {
            unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27};
            unsigned int offset[27:0] = {19, 21, 25, 27, 31, 33, 43, 45, 49, 51, 55, 57, 61, 63, 67, 69, 91, 93, 97, 99, 121, 123, 127, 129, 133, 135, 139, 141};
            
            
            ///*****IOBS *BSR_N*****/
            foreach i (indexs)
            {
                lsx1 = lsx;
                lsy1 = lsy + offset[i];
                
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar          of ARCHITECTURE (structure fp_struct)>;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 21)
                {
                    offset_y = 320;
                }
                
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref);
            }
            
            ///*****IOBR *BSR_P*****/
            foreach i (indexs)
            {
                lsx1 = lsx;
                lsy1 = lsy + offset[i] - 1;
                
                // Instantiate the device.
                sprintf(strVar, "IOBR_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar          of ARCHITECTURE (structure fp_struct)>;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 21)
                {
                    offset_y = 320;
                }
                
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref);
            }
            
            lsx1 = lsx + 2;
            lsy1 = lsy + 64;
                
            // Instantiate the device.
            sprintf(strVar, "BKCL_%d_%d", lsx1, lsy1);
            s0Ref  = <instance  *strVar          of ARCHITECTURE (structure fp_struct)>;
            
            unsigned int offset_y = 0;
            get_coordinate_of_bkcl(lsx1, lsy1);
            if (fsy > 21)
            {
                offset_y = 320;
            }
            
            s0fl = device BKCL ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);  
        }
    }// end of function draw_ioblr_tile_fp
      
      
    ///*****iob1_2k_tile*****/ 
    function place_iobt_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx1, lsy1;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        ///*****IOBS *BSS_N*****/
        unsigned int i;
        unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25};
        unsigned int offset[25:0] = {0, 2, 6, 8, 12, 14, 18, 20, 24, 26, 30, 32, 36, 38, 54, 56, 60, 62, 66, 68, 72, 74, 78, 80, 84, 86};
        foreach i (indexs)
        {
            lsx1 = tx * NUM_GRID_X;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1 + offset[25 - i] + 1;
            lsy = lsy1; 
            
            s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
            string strVar;
            sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
               
            get_coordinate_of_iob(lsx, lsy);
            
            printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
    
        ///*****IOBS *BSS_P*****/
        foreach i (indexs)
        {
            lsx1 = tx * NUM_GRID_X;
            lsy1 = ty * NUM_GRID_Y;
            
            lsx = lsx1 + offset[25 - i];
            lsy = lsy1;
            
            s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
            string strVar;
            sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
               
            get_coordinate_of_iob(lsx, lsy);
            
            printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        
        lsx = tx * NUM_GRID_X;
        lsy = ty * NUM_GRID_Y;
        
        lsx = lsx + 42;
        lsy = lsy + 0;
            
        s0Ref  = <device BKCL  @[lsx, lsy]     of ARCHITECTURE>;
        string strVar;
        sprintf(strVar, "BKCL_%d_%d", lsx, lsy);
        
        get_coordinate_of_bkcl(lsx, lsy);
        
        printf("%s: %d, %d.", strVar, fsx, fsy);
        s0fl = device BKCL ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref);
    } // end of function place_iobt_tile_fp
    
    function draw_iobt_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx1, lsy1;
        string strVar;
        unsigned int i;
        unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25};
        unsigned int offset[25:0] = {0, 2, 6, 8, 12, 14, 18, 20, 24, 26, 30, 32, 36, 38, 54, 56, 60, 62, 66, 68, 72, 74, 78, 80, 84, 86};
        
        // device reference variables
        &device s0Ref, s0fl;
        
        ///*****IOBS *BSS_N*****///
        ///*****For odd X_number*****///
        foreach i (indexs)
        {
            unsigned int offset_y = 0;
            lsx = tx * NUM_GRID_X;
            lsy = ty * NUM_GRID_Y;
            lsx1 = lsx + offset[25 - i] + 1;
            lsy1 = lsy;
            
            // Instantiate the device.
            sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
            
            s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
            
            get_coordinate_of_iob(lsx1, lsy1);
            if (fsy > 21)
            {
                offset_y = 320;
            }
            
            s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
        }
        
        /*****IOBS *BSS_P*****/
        foreach i (indexs)
        {
            unsigned int offset_y = 0;
            lsx = tx * NUM_GRID_X;
            lsy = ty * NUM_GRID_Y;
            lsx1 = lsx + offset[25 - i];
            lsy1 = lsy;
            
            // Instantiate the device.
            sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
            s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
            
            get_coordinate_of_iob(lsx1, lsy1);
            if (fsy > 21)
            {
                offset_y = 320;
            }
            s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
        }
                
        lsx1 = lsx + 42;
        lsy1 = lsy + 0;
            
        // Instantiate the device.
        sprintf(strVar, "BKCL_%d_%d", lsx1, lsy1);
        s0Ref  = <instance  *strVar          of ARCHITECTURE (structure fp_struct)>;
        
        unsigned int offset_y = 0;
        get_coordinate_of_bkcl(lsx1, lsy1);
        if (fsy > 21)
        {
            offset_y = 320;
        }
        
        s0fl = device BKCL ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
        map ( s0fl => s0Ref);  
    }// end of function draw_iobt_tile_fp
    
    
    function place_iobb_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty,
        unsigned int flag
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx1, lsy1;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        if (flag == 0)
        {
            ///*****IOBS *BSS_N*****/
            unsigned int i;
            unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7};
            unsigned int offset[7:0] = {21, 19, 15, 13, 9, 7, 3, 1};
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1 + offset[i];
                lsy = lsy1;
                
                s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
                string strVar;
                sprintf(strVar, "IOBS_%d_%d", lsx, lsy); 
               
                get_coordinate_of_iob(lsx, lsy);
                
                printf("%s: %d, %d.", strVar, fsx, fsy);  
                s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            /*****IOBS *BSS_P*****/
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1 + offset[i] - 1;
                lsy = lsy1;
                
                s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
                string strVar;
                sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
               
                get_coordinate_of_iob(lsx, lsy);
                
                printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            lsx = tx * NUM_GRID_X;
            lsy = ty * NUM_GRID_Y;
            
            lsx = lsx + 11;
            lsy = lsy + 0;
                
            s0Ref  = <device BKCL  @[lsx, lsy]     of ARCHITECTURE>;
            string strVar;
            sprintf(strVar, "BKCL_%d_%d", lsx, lsy);
            
            get_coordinate_of_bkcl(lsx, lsy);
            
            printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device BKCL ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        else if (flag == 1)
        {
            unsigned int i;
            unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7};
            unsigned int offset[7:0] = {33, 31, 27, 25, 9, 7, 3, 1};
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1 + offset[i];
                lsy = lsy1;
                
                s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
                string strVar;
                sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
               
                get_coordinate_of_iob(lsx, lsy);
                
                printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            ///*****IOBS *BSS_P*****/
            foreach i (indexs)
            {
                lsx1 = tx * NUM_GRID_X;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1 + offset[i] - 1;
                lsy = lsy1;
                
                s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
                string strVar;
                sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
               
                get_coordinate_of_iob(lsx, lsy);
                
                printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            lsx = tx * NUM_GRID_X;
            lsy = ty * NUM_GRID_Y;
            
            lsx = lsx + 12;
            lsy = lsy + 0;
                
            s0Ref  = <device BKCL  @[lsx, lsy]     of ARCHITECTURE>;
            string strVar;
            sprintf(strVar, "BKCL_%d_%d", lsx, lsy);
            
            get_coordinate_of_bkcl(lsx, lsy);
            
            printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device BKCL ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        else if (flag == 2)
        {
            unsigned int indexs1[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
            unsigned int offset[9:0] = {27, 25, 21, 19, 15, 13, 9, 7, 3, 1};
            unsigned int i;
            foreach i (indexs1)
            {
                lsx1 = tx * NUM_GRID_X;
                lsy1 = ty * NUM_GRID_Y;
                
                lsx = lsx1 + offset[i];
                lsy = lsy1;
                
                s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
                string strVar;
                sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
               
                get_coordinate_of_iob(lsx, lsy);
                
                printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            ///*****IOBS *BSS_P*****/
            foreach i (indexs1)
            {
                lsx1 = tx * NUM_GRID_X;
                lsy1 = ty * NUM_GRID_Y; 
                
                lsx = lsx1 + offset[i] - 1;
                lsy = lsy1;
                
                s0Ref  = <device IOBS  @[lsx, lsy]     of ARCHITECTURE>;
                string strVar;
                sprintf(strVar, "IOBS_%d_%d", lsx, lsy);
               
                get_coordinate_of_iob(lsx, lsy);
                
                printf("%s: %d, %d.", strVar, fsx, fsy);
                s0fl = device IOBS ( structure fp_struct ) *strVar @[fsx, fsy];
                map ( s0fl => s0Ref);
            }
            
            lsx = tx * NUM_GRID_X;
            lsy = ty * NUM_GRID_Y;
            
            lsx = lsx + 17;
            lsy = lsy + 0;
                
            s0Ref  = <device BKCL  @[lsx, lsy]     of ARCHITECTURE>;
            string strVar;
            sprintf(strVar, "BKCL_%d_%d", lsx, lsy);
            
            get_coordinate_of_bkcl(lsx, lsy);
            
            printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device BKCL ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        
    }; // end of function place_iobb_tile_fp
    
    function draw_iobb_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty,
        unsigned int flag
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx1, lsy1;
        string strVar;
        unsigned int i;
        unsigned int indexs[] = {0, 1, 2, 3, 4, 5, 6, 7};
        
        // device reference variables
        &device s0Ref, s0fl;
        
        if (flag == 0)
        {
            unsigned int offset[7:0] = {21, 19, 15, 13, 9, 7, 3, 1};
            ///*****IOBS *BSS_N*****/
            foreach i (indexs)
            {
                unsigned int offset_y = 0;
                lsx = tx * NUM_GRID_X;
                lsy = ty * NUM_GRID_Y;
                lsx1 = lsx + offset[i];
                lsy1 = lsy;
                
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
                
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 21)
                {
                    offset_y = 320;
                }
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                
                map ( s0fl => s0Ref);
            }
            
            /*****IOBS *BSS_P*****/
            foreach i (indexs)
            {
                unsigned int offset_y = 0;
                lsx = tx * NUM_GRID_X;
                lsy = ty * NUM_GRID_Y;
                lsx1 = lsx + offset[i] - 1;
                lsy1 = lsy;
                
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
                
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 21)
                {
                    offset_y = 320;
                }
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref);
            } 
                  
            lsx1 = lsx + 11;
            lsy1 = lsy + 0;
                
            // Instantiate the device.
            sprintf(strVar, "BKCL_%d_%d", lsx1, lsy1);
            s0Ref  = <instance  *strVar          of ARCHITECTURE (structure fp_struct)>;
            
            unsigned int offset_y = 0;
            get_coordinate_of_bkcl(lsx1, lsy1);
            if (fsy > 21)
            {
                offset_y = 320;
            }
           
            s0fl = device BKCL ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);  
        }
        else if (flag == 1)
        {
            unsigned int offset[7:0] = {33, 31, 27, 25, 9, 7, 3, 1};
            ///*****IOBS *BSS_N*****/
            foreach i (indexs)
            {
                unsigned int offset_y = 0;
                lsx = tx * NUM_GRID_X;
                lsy = ty * NUM_GRID_Y;
                lsx1 = lsx + offset[i];
                lsy1 = lsy;
                
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
                
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 21)
                {
                    offset_y = 320;
                }
                
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                
                map ( s0fl => s0Ref);
            }
            
            ///*****IOBS *BSS_P*****/
            foreach i (indexs)
            {
                unsigned int offset_y = 0;
                lsx = tx * NUM_GRID_X;
                lsy = ty * NUM_GRID_Y;
                lsx1 = lsx + offset[i] - 1;
                lsy1 = lsy;
                
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
                
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 21)
                {
                    offset_y = 320;
                }
                
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];

                map ( s0fl => s0Ref);
            }
                  
            lsx1 = lsx + 12;
            lsy1 = lsy + 0;
                
            // Instantiate the device.
            sprintf(strVar, "BKCL_%d_%d", lsx1, lsy1);
            s0Ref  = <instance  *strVar          of ARCHITECTURE (structure fp_struct)>;
            
            unsigned int offset_y = 0;
            get_coordinate_of_bkcl(lsx1, lsy1);
            if (fsy > 21)
            {
                offset_y = 320;
            }
            
            s0fl = device BKCL ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref); 
        }
        else if (flag == 2)
        {
            unsigned int indexs1[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
            unsigned int offset[9:0] = {27, 25, 21, 19, 15, 13, 9, 7, 3, 1};
            ///*****IOBS *BSS_N*****/
            foreach i (indexs1)
            {
                lsx = tx * NUM_GRID_X;
                lsy = ty * NUM_GRID_Y;
                lsx1 = lsx + offset[i];
                lsy1 = lsy;
                
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 21)
                {
                    offset_y = 320;
                }
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref);
            }
            
            ///*****IOBS *BSS_P*****/
            foreach i (indexs1)
            {
                lsx = tx * NUM_GRID_X;
                lsy = ty * NUM_GRID_Y;
                lsx1 = lsx + offset[i] - 1;
                lsy1 = lsy;
                
                // Instantiate the device.
                sprintf(strVar, "IOBS_%d_%d", lsx1, lsy1);
                s0Ref  = <instance  *strVar     of ARCHITECTURE (structure fp_struct)>;
                
                
                unsigned int offset_y = 0;
                get_coordinate_of_iob(lsx1, lsy1);
                if (fsy > 21)
                {
                    offset_y = 320;
                }
                s0fl = device IOBS ( schematic floorplan_view ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
                map ( s0fl => s0Ref);
            }
                  
            lsx1 = lsx + 17;
            lsy1 = lsy + 0;
                
            // Instantiate the device.
            sprintf(strVar, "BKCL_%d_%d", lsx1, lsy1);
            s0Ref  = <instance  *strVar          of ARCHITECTURE (structure fp_struct)>;
            
            unsigned int offset_y = 0;
            get_coordinate_of_bkcl(lsx1, lsy1);
            if (fsy > 21)
            {
                offset_y = 320;
            }
            
            s0fl = device BKCL ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref); 
        }
    };// end of function draw_iobb_tile_fp
    
    
    ///*****Place DRM*****/
    function place_drm_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = tx * NUM_GRID_X + 3;
        lsy0 = ty * NUM_GRID_Y;
        
        lsx = lsx0 + 2;
        lsy = lsy0;
        
        s0Ref  = <device DRM  @[lsx,lsy]     of ARCHITECTURE>;
        
        sprintf(strVar, "DRM_%d_%d", lsx, lsy);
    
        get_coordinate_of_drm(lsx, lsy);
        
        printf("%s: %d, %d.", strVar, fsx, fsy);
        s0fl = device DRM ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref);
    } // end of function place_drm_tile_fp
    
    ///*****Draw DRM*****/
    function draw_drm_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = tx * NUM_GRID_X + 3;
        lsy0 = ty * NUM_GRID_Y;
        
        lsx = lsx0 + 2;
        lsy = lsy0;
        
        get_coordinate_of_drm(lsx, lsy);
        unsigned int offset_y = 0;
        if (fsy > 21)
        {
            offset_y = 320;
        }
        
        // Instantiate the device. 
        sprintf(strVar, "DRM_%d_%d", lsx, lsy);
        s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s0fl = device DRM ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
        map ( s0fl => s0Ref);
    }; // end of function draw_drm_tile_fp
    
    
    function get_coordinate_of_ccs
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        fsx = 17;
        fsy = 25;
    };
    
    ///*****Place CCS*****/
    function place_ccs_tile_fp
    ( 
        unsigned int CCS_TILE_X,
        unsigned int CCS_TILE_Y,
        unsigned int PLL_TILE_X,
        unsigned int PLL_TILE_Y,
        unsigned int flag1,
        unsigned int flag2
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = CCS_TILE_X * NUM_GRID_X + 3;
        lsy0 = CCS_TILE_Y * NUM_GRID_Y;
        
        lsx = lsx0 + 1;
        lsy = lsy0;
        
        s0Ref  = <device CCS  @[lsx,lsy]     of ARCHITECTURE>;
        
        sprintf(strVar, "CCS_%d_%d", lsx, lsy);
    
        get_coordinate_of_ccs(lsx, lsy);
        
        printf("%s: %d, %d.", strVar, fsx, fsy);
        s0fl = device CCS ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref);
    }; // end of function place_ccs_tile_fp
    
    ///*****Draw CCS*****/
    function draw_ccs_tile_fp
    ( 
        unsigned int CCS_TILE_X,
        unsigned int CCS_TILE_Y,
        unsigned int PLL_TILE_X,
        unsigned int PLL_TILE_Y,
        unsigned int flag1,
        unsigned int flag2
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = CCS_TILE_X * NUM_GRID_X + 3;
        lsy0 = CCS_TILE_Y * NUM_GRID_Y;
        
        lsx = lsx0 + 1;
        lsy = lsy0;
        
        unsigned int offset_y = 0;
        get_coordinate_of_ccs(lsx, lsy);
        if (fsy > 21)
        {
            offset_y = 320;
        }
        
        // Instantiate the device. 
        sprintf(strVar, "CCS_%d_%d", lsx, lsy);
        s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s0fl = device CCS ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
        map ( s0fl => s0Ref);
    }; // end of function draw_ccs_tile_fp
    
    
    function get_coordinate_of_pll
    (
        unsigned int lsx,
        unsigned int lsy
    )
    {
        unsigned int tmp_x, tmp_y;
        tmp_x = lsx;
        tmp_y = lsy;
        
        fsx = 17;
        fsy = 10;
    };
    
    ///*****Place PLL*****/
    function place_pll_tile_fp
    ( 
        unsigned int PLL_TILE_X,
        unsigned int PLL_TILE_Y
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = PLL_TILE_X * NUM_GRID_X + 3;
        lsy0 = PLL_TILE_Y * NUM_GRID_Y;
        
        lsx = lsx0 + 2;
        lsy = lsy0 + 8;
        
        s0Ref  = <device PLL  @[lsx,lsy]     of ARCHITECTURE>;
        
        sprintf(strVar, "PLL_%d_%d", lsx, lsy);
    
        get_coordinate_of_pll(lsx, lsy);
        
        printf("%s: %d, %d.", strVar, fsx, fsy);
        s0fl = device PLL ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref);
    }; // end of function place_drm_tile_fp
    
    ///*****Draw PLL*****/
    function draw_pll_tile_fp
    ( 
        unsigned int PLL_TILE_X,
        unsigned int PLL_TILE_Y
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = PLL_TILE_X * NUM_GRID_X + 3;
        lsy0 = PLL_TILE_Y * NUM_GRID_Y;
        
        lsx = lsx0 + 2;
        lsy = lsy0 + 8;
        
        unsigned int offset_y = 0;
        get_coordinate_of_pll(lsx, lsy);
        if (fsy > 21)
        {
            offset_y = 320;
        }
        
        // Instantiate the device. 
        sprintf(strVar, "PLL_%d_%d", lsx, lsy);
        s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s0fl = device PLL ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
        map ( s0fl => s0Ref);
    }; // end of function draw_pll_tile_fp
    
    
    ///*****Place DLL*****/
    function place_dll_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = tx * NUM_GRID_X + 3;
        lsy0 = ty * NUM_GRID_Y;
        
        lsx = lsx0;
        lsy = lsy0;
        
        s0Ref  = <device DLL  @[lsx,lsy]     of ARCHITECTURE>;
        
        sprintf(strVar, "DLL_%d_%d", lsx, lsy);
    
        get_coordinate_of_dll(lsx, lsy);
        
        printf("%s: %d, %d.", strVar, fsx, fsy);
        s0fl = device DLL ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref);
    }; // end of function place_dll_tile_fp
    
    ///*****Draw DLL*****/
    function draw_dll_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = tx * NUM_GRID_X + 3;
        lsy0 = ty * NUM_GRID_Y;
        
        lsx = lsx0;
        lsy = lsy0;
        
        
        unsigned int offset_y = 0;
        get_coordinate_of_dll(lsx, lsy);
        if (fsy > 21)
        {
            offset_y = 320;
        }
        
        // Instantiate the device. 
        sprintf(strVar, "DLL_%d_%d", lsx, lsy);
        s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s0fl = device DLL ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
        map ( s0fl => s0Ref);
   }; // end of function draw_dll_tile_fp
   
   
   ///*****Place CLKDLY*****/
    function place_clkdlyb_tile_fp
    ( 
        unsigned int CLKDLY_TILE_X, 
        unsigned int CLKDLYB_TILE_Y
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        unsigned int offset_x[2:0] = {1, 0, 0};
        unsigned int offset_y[2:0] = {2, 4, 0};
        unsigned int indexs[] = {0, 1, 2};
        unsigned int i;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = CLKDLY_TILE_X * NUM_GRID_X;
        lsy0 = CLKDLYB_TILE_Y * NUM_GRID_Y;
        
        ///***CLKDLY***/
        foreach i (indexs)
        {
            lsx = lsx0 + offset_x[i];
            lsy = lsy0 + offset_y[i];
            
            s0Ref  = <device CLKDLY  @[lsx,lsy]     of ARCHITECTURE>;
            sprintf(strVar, "CLKDLY_%d_%d", lsx, lsy);
            
            get_coordinate_of_clkdly(lsx, lsy);
        
            printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device CLKDLY ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
    };
    
    function place_clkdlyt_tile_fp
    ( 
        unsigned int CLKDLY_TILE_X, 
        unsigned int CLKDLYT_TILE_Y
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = CLKDLY_TILE_X * NUM_GRID_X;
        lsy0 = CLKDLYT_TILE_Y * NUM_GRID_Y;
        
        ///***CLKDLY***/
        lsx = lsx0;
        lsy = lsy0;
        
        s0Ref  = <device CLKDLY  @[lsx,lsy]     of ARCHITECTURE>;
        sprintf(strVar, "CLKDLY_%d_%d", lsx, lsy);
    
        get_coordinate_of_clkdly(lsx, lsy);
        
        printf("%s: %d, %d.", strVar, fsx, fsy);
        s0fl = device CLKDLY ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref);
    };
    
    ///*****draw CLKDLY*****/
    function draw_clkdlyb_tile_fp
    ( 
        unsigned int CLKDLY_TILE_X, 
        unsigned int CLKDLYB_TILE_Y
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        unsigned int offset_clkdly_x[2:0] = {1, 0, 0};
        unsigned int offset_clkdly_y[2:0] = {2, 4, 0};
        unsigned int indexs[] = {0, 1, 2};
        unsigned int i;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        ///***CLKDLY***/
        foreach i (indexs)
        {
            unsigned int offset_y = 0;
            lsx0 = CLKDLY_TILE_X * NUM_GRID_X;
            lsy0 = CLKDLYB_TILE_Y * NUM_GRID_Y;
            
            lsx = lsx0 + offset_clkdly_x[i];
            lsy = lsy0 + offset_clkdly_y[i];
            
            get_coordinate_of_clkdly(lsx, lsy);
            if (fsy > 21)
            {
                offset_y = 320;
            }
            
            // Instantiate the device. 
            sprintf(strVar, "CLKDLY_%d_%d", lsx, lsy);
            s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s0fl = device CLKDLY ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
        }
    };
    
    function draw_clkdlyt_tile_fp
    ( 
        unsigned int CLKDLY_TILE_X, 
        unsigned int CLKDLYT_TILE_Y
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        ///***CLKDLY***/
        lsx0 = CLKDLY_TILE_X * NUM_GRID_X;
        lsy0 = CLKDLYT_TILE_Y * NUM_GRID_Y;
        
        lsx = lsx0;
        lsy = lsy0;
        
        unsigned int offset_y = 0;
        get_coordinate_of_clkdly(lsx, lsy);
        if (fsy > 21)
        {
            offset_y = 320;
        }
        
        // Instantiate the device. 
        sprintf(strVar, "CLKDLY_%d_%d", lsx, lsy);
        s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        s0fl = device CLKDLY ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
        map ( s0fl => s0Ref);
    };
    
    
    ///*****place USCM*****/
    unsigned int L_USCM_TILES_X[] = {USCM_TILE_X};
    unsigned int L_USCM_TILES_Y[] = {USCM_TILE_Y};
    int tx_srb = USCM_TILE_X - 1;
    int ty_srb = USCM_TILE_Y - 2;
    
    function place_uscm_tile_fp
    ( 
        unsigned int tx, 
        unsigned int ty, 
        unsigned int tx_srb, 
        unsigned int ty_srb
    )     
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        unsigned int indexs1[] = {0, 1};
        unsigned int indexs2[] = {0, 1, 2, 3, 4, 5, 6, 7};
        unsigned int indexs3[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        unsigned int indexs4[] = {0, 1, 2, 3};
        unsigned int i;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = tx * NUM_GRID_X;
        lsy0 = ty * NUM_GRID_Y;
        
        ///***USCMD***/
        foreach i (indexs1)
        {
            lsx = lsx0 + 1;
            lsy = lsy0 + 12 + i;
            
            s0Ref  = <device USCMD  @[lsx, lsy]     of ARCHITECTURE>;
            
            sprintf(strVar, "USCMD_%d_%d", lsx, lsy);
            
            get_coordinate_of_uscmd(lsx, lsy);
            
            printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device USCMD ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        
        ///***USCMDC***/
        foreach i (indexs2)
        {
            
            if (i < 4)
            {
                lsx = lsx0 + 1;
                lsy = lsy0 + 14 + i;
            }
            else
            {
                lsx = lsx0 + 2;
                lsy = lsy0 + (i - 4);
            }
            
            s0Ref  = <device USCMDC  @[lsx,lsy]     of ARCHITECTURE>;
            
            sprintf(strVar, "USCMDC_%d_%d", lsx, lsy);
            
            get_coordinate_of_uscmdc(lsx, lsy);
            
            printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device USCMDC ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        
        ///***IOCKBRG***/
        foreach i (indexs1)
        {
            lsx = lsx0 + 4;
            lsy = lsy0 + 5 + i;
            
            s0Ref  = <device IOCKBRG  @[lsx,lsy]     of ARCHITECTURE>;
            
            sprintf(strVar, "IOCKBRG_%d_%d", lsx, lsy);
            
            get_coordinate_of_iockbrg(lsx, lsy);
            
            printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device IOCKBRG ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
    };
    
    ///*****draw USCM*****/
    function draw_uscm_tile_fp
    ( 
        unsigned int tx, 
        unsigned int ty, 
        unsigned int tx_srb, 
        unsigned int ty_srb
    )     
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        unsigned int indexs1[] = {0, 1};
        unsigned int indexs2[] = {0, 1, 2, 3, 4, 5, 6, 7};
        unsigned int indexs3[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        unsigned int indexs4[] = {0, 1, 2, 3};
        unsigned int i;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = tx * NUM_GRID_X;
        lsy0 = ty * NUM_GRID_Y;
        
        ///***USCMD***/
        foreach i (indexs1)
        {
            lsx = lsx0 + 1;
            lsy = lsy0 + 12 + i;
            
            unsigned int offset_y = 0;
            get_coordinate_of_uscmd(lsx, lsy);
            if (fsy > 21)
            {
                offset_y = 320;
            }
            
            // Instantiate the device. 
            sprintf(strVar, "USCMD_%d_%d", lsx, lsy);
            s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s0fl = device USCMD ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
        }
        
        ///***USCMDC***/
        foreach i (indexs2)
        {
            if (i < 4)
            {
                lsx = lsx0 + 1;
                lsy = lsy0 + 14 + i;
            }
            else
            {
                lsx = lsx0 + 2;
                lsy = lsy0 + (i - 4);
            }
            
            unsigned int offset_y = 0;
            get_coordinate_of_uscmdc(lsx, lsy);
            if (fsy > 21)
            {
                offset_y = 320;
            }
            
            // Instantiate the device. 
            sprintf(strVar, "USCMDC_%d_%d", lsx, lsy);
            s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s0fl = device USCMDC ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
        }
        
        ///***IOCKBRG***/
        foreach i (indexs1)
        {
            lsx = lsx0 + 4;
            lsy = lsy0 + 5 + i;
            
            s0Ref  = <device IOCKBRG  @[lsx,lsy]     of ARCHITECTURE>;
            
            sprintf(strVar, "IOCKBRG_%d_%d", lsx, lsy);
            
            unsigned int offset_y = 0;
            get_coordinate_of_iockbrg(lsx, lsy);
            if (fsy > 21)
            {
                offset_y = 320;
            }
            
            // Instantiate the device. 
            s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s0fl = device IOCKBRG ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
            
        }
    }
    
    
    ///*****Place IOCK*****/
    function place_iock_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        // Site index variable. The X index for logic and GUI are declared separately
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
        unsigned int tmp, tmp_x, tmp_y;
        unsigned int indexs0[] = {0, 1};
        unsigned int i;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = tx * NUM_GRID_X + 3;
        lsy0 = ty * NUM_GRID_Y;
        
        /***IOCKGATE***/
        foreach i (indexs0)
        {
            lsx = lsx0;
            lsy = lsy0 + 15 + i;
            
            s0Ref  = <device IOCKGATE  @[lsx,lsy]     of ARCHITECTURE>;
            
            sprintf(strVar, "IOCKGATE_%d_%d", lsx, lsy);
            
            get_coordinate_of_iockgate(lsx, lsy);
            
            printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device IOCKGATE ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        
        ///***CLKDIV***/
        foreach i (indexs0)
        {
            lsx = lsx0 + i;
            lsy = lsy0 + 17 * (1 - i);
            
            s0Ref  = <device CLKDIV  @[lsx,lsy]     of ARCHITECTURE>;
            
            sprintf(strVar, "CLKDIV_%d_%d", lsx, lsy);
            
            get_coordinate_of_clkdiv(lsx, lsy);
            
            printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device CLKDIV ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
        
        ///***CLKDLY***/
        foreach i (indexs0)
        {
            lsx = lsx0 + 1;
            lsy = lsy0 + 1 + i;
            
            s0Ref  = <device CLKDLY  @[lsx,lsy]     of ARCHITECTURE>;
            
            sprintf(strVar, "CLKDLY_%d_%d", lsx, lsy);
            
            get_coordinate_of_clkdly(lsx, lsy);
            
            printf("%s: %d, %d.", strVar, fsx, fsy);
            s0fl = device CLKDLY ( structure fp_struct ) *strVar @[fsx, fsy];
            map ( s0fl => s0Ref);
        }
    }; // end of function place_ckeb_tile_fp
    
    ///*****Draw IOCK*****/
    function draw_iock_tile_fp
    ( 
        unsigned int tx,
        unsigned int ty
    )
    {
        unsigned int lsx, lsy, gsx, gsy;
        unsigned int lsx0, lsy0;
        unsigned int indexs0[] = {0, 1};
        unsigned int i;
        int offset_x;
        
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = tx * NUM_GRID_X + 3;
        lsy0 = ty * NUM_GRID_Y;
        
        ///***IOCKGATE***/
        foreach i (indexs0)
        {
            lsx = lsx0;
            lsy = lsy0 + 15 + i;
            
            s0Ref  = <device IOCKGATE  @[lsx,lsy]     of ARCHITECTURE>;
            
            unsigned int offset_y = 0;
            get_coordinate_of_iockgate(lsx, lsy);
            if (fsy > 21)
            {
                offset_y = 320;
            }
            
            sprintf(strVar, "IOCKGATE_%d_%d", lsx, lsy);
            
            gsx = (lsx/NUM_GRID_X) * TILE_NUM_FLOORPLAN_GUI_GRID_X;
            gsy = (lsy/NUM_GRID_Y) * TILE_NUM_FLOORPLAN_GUI_GRID_Y;
        
            // Instantiate the device. 
            
            s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s0fl = device IOCKGATE ( symbol fpsym ) *strVar @[(fsx+1)*160+80*i, (fsy+1)*320+offset_y];
            
            map ( s0fl => s0Ref);
        }
        
        ///***CLKDIV***/
        foreach i (indexs0)
        {
            lsx = lsx0 + i;
            lsy = lsy0 + 17 * (1 - i);
            
            s0Ref  = <device CLKDIV  @[lsx,lsy]     of ARCHITECTURE>;
            sprintf(strVar, "CLKDIV_%d_%d", lsx, lsy);
            
            unsigned int offset_y = 0;
            get_coordinate_of_clkdiv(lsx, lsy);
            if (fsy > 21)
            {
                offset_y = 320;
            }
            
            s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s0fl = device CLKDIV ( symbol fpsym ) *strVar @[(fsx+1)*160+80*i, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
        }
        
        ///***CLKDLY***/
        foreach i (indexs0)
        {
            lsx = lsx0 + 1;
            lsy = lsy0 + 1 + i;
            
            // Instantiate the device. 
            s0Ref  = <device CLKDLY  @[lsx,lsy]     of ARCHITECTURE>;
            sprintf(strVar, "CLKDLY_%d_%d", lsx, lsy);
            unsigned int offset_y = 0;
            get_coordinate_of_clkdly(lsx, lsy);
            if (fsy > 21)
            {
                offset_y = 320;
            }
            
            s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
            s0fl = device CLKDLY ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
            map ( s0fl => s0Ref);
        }
    }; // end of function draw_iock_tile_fp
    
    // place OSC and MFG_TEST
    function place_analog_tile_fp 
    ( 
        unsigned int ANALOG_2K_TILE_X, 
        unsigned int ANALOG_2K_TILE_Y, 
        unsigned int CCS_TILE_Y, 
        unsigned int PLL_TILE_Y
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = ANALOG_2K_TILE_X * NUM_GRID_X + 3;
        lsy0 = ANALOG_2K_TILE_Y * NUM_GRID_Y;
        
        lsx = lsx0 + 2;
        lsy = lsy0;
        
        s0Ref  = <device OSC  @[lsx,lsy]     of ARCHITECTURE>;
        sprintf(strVar, "OSC_%d_%d", lsx, lsy);
        
        get_coordinate_of_osc(lsx, lsy);
        
        printf("%s: %d, %d.", strVar, fsx, fsy);
        s0fl = device OSC ( structure fp_struct ) *strVar @[fsx, fsy];
        map ( s0fl => s0Ref);
    };
    
    // draw OSC and MFG_TEST
    function draw_analog_tile_fp 
    ( 
        unsigned int ANALOG_2K_TILE_X, 
        unsigned int ANALOG_2K_TILE_Y, 
        unsigned int CCS_TILE_Y, 
        unsigned int PLL_TILE_Y
    )
    {
        unsigned int lsx, lsy;
        unsigned int lsx0, lsy0;
    
        // device reference variables
        &device s0Ref, s0fl;
        
        string strVar;
        
        lsx0 = ANALOG_2K_TILE_X * NUM_GRID_X + 3;
        lsy0 = ANALOG_2K_TILE_Y * NUM_GRID_Y;
        
        lsx = lsx0 + 2;
        lsy = lsy0;
        
        sprintf(strVar, "OSC_%d_%d", lsx, lsy);
        s0Ref = <instance *strVar   of ARCHITECTURE (structure fp_struct)>;
        
        unsigned int offset_y = 0;
        get_coordinate_of_osc(lsx, lsy);
        if (fsy > 21)
        {
            offset_y = 320;
        }
        
        // Instantiate the device. 
        s0fl = device OSC ( symbol fpsym ) *strVar @[(fsx+1)*160, (fsy+1)*320+offset_y];
        map ( s0fl => s0Ref);
    };

}; // end of package pgc_schm_funcs
