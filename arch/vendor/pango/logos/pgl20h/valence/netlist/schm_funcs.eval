*******************************************************************

  Package   [pango_schm_funcs]

  Author    [jblu, zpfeng]

  Abstract  [Schematic description common to pango architecture]

  Revision History:

********************************************************************************/
library work;
USE pgl_defs, pgl20h_defs, pango_defs;

package pgl_schm_funcs
{

function draw_srb_tile(unsigned int tx, ty)
{
    // Site index variable. The X index for logic and GUI are declared separately
    //printf("%d, %d", tx, ty);
    unsigned int lsx, lsy, gsx, gsy;

    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
      lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef, rRef;
    string strVar, strVar1;

    // Pull out the device instances from logic structure
    xRef = <device SRB @[lsx,lsy] of ARCHITECTURE>;
    sprintf(strVar, "SRB_%d_%d", lsx, lsy);
    device SRB ( symbol logsym ) *strVar @[gsx+201,gsy+200];
    map 
    (
        <instance *strVar> => xRef
    );
    
    // Pull out the device instances from logic structure
    rRef = <device HARD0N1 @[lsx,lsy+1] of ARCHITECTURE>;
    sprintf(strVar1, "HARD0N1_%d_%d", lsx, lsy+1);
    device HARD0N1 ( symbol logsym ) *strVar1 @[gsx+620,gsy+780];
    map
    (
        <instance *strVar1> => rRef
    );   
}   // end of function draw_srb_tile

function draw_clma_tile(unsigned int tx, ty)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X + 2;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef, rRef;
    
  
    xRef = <device CLMA @[lsx,lsy]   of ARCHITECTURE>;
    rRef = <device CLMA @[lsx,lsy+1] of ARCHITECTURE>;
    
    // Instantiate the schematic. 
    device LOGIC_CLMA_TILE ( schematic logic_clma_tile_schm ) 
    instance map
    (
        <symbol CLMA @[740,280]> => xRef,
        <symbol CLMA @[870,540]> => rRef
    )
    @[gsx,gsy];
}   // end of function draw_clm_tile

function draw_clms_tile(unsigned int tx, ty)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X+2;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef, rRef;
    
    xRef = <device CLMA @[lsx,lsy]   of ARCHITECTURE>;
    rRef = <device CLMS @[lsx,lsy+1] of ARCHITECTURE>;
    
    // Instantiate the schematic. 
    device LOGIC_CLMS_TILE ( schematic logic_clms_tile_schm )
    instance map
    (
        <symbol CLMA @[740,280]> => xRef,
        <symbol CLMS @[870,540]> => rRef
    )
    @[gsx,gsy];
}   // end of function draw_clms_tile

function draw_ccs_tile_pgl20h( unsigned int tx, ty)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;

    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;

    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;

    // device reference variables
    &device xRef;
    string strVar;

    xRef = <device FUSECODE @[lsx,lsy+1] of ARCHITECTURE>;
    sprintf(strVar, "FUSECODE_%d_%d", lsx, lsy+1);
    //printf("FUSECODE: %d %d", gsx+1200+400,gsy+400);
    device FUSECODE ( symbol logsym ) *strVar @[gsx+1200+400,gsy+400];
    map
    (
        <instance *strVar> => xRef
    );

    xRef = <device START @[lsx,lsy+2] of ARCHITECTURE>;
    sprintf(strVar, "START_%d_%d", lsx, lsy+2);
    //printf("START: %d %d", gsx+1200+400,gsy+200);
    device START ( symbol logsym ) *strVar @[gsx+1200+400,gsy+200];
    map
    (
        <instance *strVar> => xRef
    );

    xRef = <device IPAL @[lsx,lsy+3] of ARCHITECTURE>;
    sprintf(strVar, "IPAL_%d_%d", lsx, lsy+3);
    //printf("IPAL: %d %d", gsx+1200+400,gsy+1100);
    device IPAL ( symbol logsym ) *strVar @[gsx+1200+400,gsy+1100];
    map
    (
        <instance *strVar> => xRef
    );

    unsigned int dt, dx, dy;
    dx = 1;
    for ( dt = 0; dt < 2; dt += 1 )
    {
        dy = dt;
        
        xRef = <device SCANCHAIN @[lsx+dx,lsy+dy] of ARCHITECTURE>;
        sprintf(strVar, "SCANCHAIN_%d_%d", lsx+dx, lsy+dy);
        //printf("%s: %d %d", strVar, gsx+1200+400,gsy+1200+80+280*dt);
        device SCANCHAIN ( symbol logsym_0 ) *strVar @[gsx+1200+400,gsy+1500+80+280*dt];
        map 
        ( 
            <instance *strVar> => xRef
        );
    }

    xRef = <device UDID @[lsx+1,lsy+2] of ARCHITECTURE>;
    sprintf(strVar, "UDID_%d_%d", lsx+1, lsy+2);
    //printf("UDID: %d %d", gsx+1200+400,gsy+200);
    device UDID ( symbol logsym ) *strVar @[gsx+1200+400,gsy+100];
    map 
    ( 
        <instance *strVar> => xRef
    );

    xRef = <device OSC @[lsx+1,lsy+3] of ARCHITECTURE>;
    sprintf(strVar, "OSC_%d_%d", lsx+1, lsy+3);
    //printf("OSC: %d %d", gsx+1200+400,gsy+100);
    device OSC ( symbol logsym ) *strVar @[gsx+1200+400,gsy];
    map 
    ( 
        <instance *strVar> => xRef
    );
}   // end of function draw_ccs_tile_pgl20h

function draw_analog_tile(unsigned int tx,ty)
{
    unsigned int lsx, lsy, gsx, gsy;
    lsx = tx*NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int tmp_ty;
    for(tmp_ty=ty;tmp_ty > MID_TILE_REGION;tmp_ty = tmp_ty - NUM_TILES_REGION)
    {
      lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx=(lsx/NUM_GRID_X)*TILE_NUM_GUI_GRID_X;
    gsy=(lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    &device xRef,rRef;
    string strVar,strVar1;
    gsx += 1200;

    //xRef = <device LDOCLK @[lsx,lsy+2] of ARCHITECTURE>;
    //sprintf(strVar, "LDOCLK_%d_%d", lsx, lsy+2);
    //device LDOCLK ( symbol logsym ) *strVar @[gsx+1000,gsy+400];
    //map 
    //( 
    //    <instance *strVar> => xRef
    //);
    
    gsx-=2400;
    rRef = <device MFG_TEST @[lsx+1,lsy] of ARCHITECTURE>;
    sprintf(strVar1, "MFG_TEST_%d_%d", lsx+1, lsy);
    device MFG_TEST ( symbol logsym ) *strVar1 @[gsx+1000+400,gsy+4800+200+1000];
    map 
    ( 
        <instance *strVar1> => rRef
    );
}

function draw_drm_tile(unsigned int tx, ty)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X + 2;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef;
    string strVar;
    
    xRef = <device DRM @[lsx,lsy]  of ARCHITECTURE>;
    sprintf(strVar, "DRM_%d_%d", lsx, lsy);
    device DRM  ( symbol logsym_0 )  *strVar  @[gsx+800,gsy+200];
    map 
    ( 
        <instance *strVar> => xRef
     ); 
        
}// end of function draw_drm_tile

function draw_apm_tile(unsigned int tx, ty)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X + 2;
    lsy = ty * NUM_GRID_Y;
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef, rRef;
    string strVar, strVar1;
    
    xRef = <device APM @[lsx,lsy] of ARCHITECTURE>;
    sprintf(strVar, "APM_%d_%d", lsx, lsy);
    device APM ( symbol logsym ) *strVar @[gsx+800,gsy+200];
    map 
    ( 
        <instance *strVar> => xRef
    );
    
    rRef = <device APMMUX @[lsx,lsy+4] of ARCHITECTURE>;
    sprintf(strVar1, "APMMUX_%d_%d", lsx, lsy+4);
    device APMMUX ( symbol logsym_w ) *strVar1 @[gsx+750,gsy+1670];
    map 
    ( 
        <instance *strVar1> => rRef
    );
}   // end of function draw_apm_tile

function draw_pll_tile(unsigned int tx, ty, pll_flag)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X + 2;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
      lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef;
    string strVar;
    
    if (pll_flag == 1)
    {
        xRef = <device PLL @[lsx,lsy+7] of ARCHITECTURE>;
        sprintf(strVar, "PLL_%d_%d", lsx, lsy+7);
        device PLL ( symbol logsym_1 ) *strVar @[gsx+800,gsy+200];
        map 
        ( 
            <instance *strVar> => xRef
        );
        
        xRef = <device PLLMUX @[lsx,lsy+11] of ARCHITECTURE>;
        sprintf(strVar, "PLLMUX_%d_%d", lsx, lsy+11);
        device PLLMUX ( symbol logsym ) *strVar @[gsx+700,gsy+500-32];
        map 
        ( 
            <instance *strVar> => xRef
        );
    }
    else
    {
        xRef = <device PLL @[lsx,lsy+7] of ARCHITECTURE>;
        sprintf(strVar, "PLL_%d_%d", lsx, lsy+7);
        device PLL ( symbol logsym ) *strVar @[gsx+800,gsy+200];
        map 
        ( 
            <instance *strVar> => xRef
        );
        
        xRef = <device PLLMUX @[lsx,lsy+11] of ARCHITECTURE>;
        sprintf(strVar, "PLLMUX_%d_%d", lsx, lsy+11);
        device PLLMUX ( symbol logsym ) *strVar @[gsx+700,gsy+500-32+3600];
        map 
        ( 
            <instance *strVar> => xRef
        );
    }
    
    xRef = <device PREGMUX @[lsx,lsy+5] of ARCHITECTURE>;
    sprintf(strVar, "PREGMUX_%d_%d", lsx, lsy+5);
    device PREGMUX ( symbol logsym ) *strVar @[gsx+1080,gsy+2610];
    map 
    ( 
        <instance *strVar> => xRef
    );
    
    xRef = <device PREGMUX_TEST @[lsx,lsy+4] of ARCHITECTURE>;
    sprintf(strVar, "PREGMUX_TEST_%d_%d", lsx, lsy+4);
    device PREGMUX_TEST ( symbol logsym ) *strVar @[gsx+1080,gsy+1400];
    map 
    ( 
        <instance *strVar> => xRef
    );
    
    xRef = <device PREGMUX_OUT @[lsx,lsy+3] of ARCHITECTURE>;
    sprintf(strVar, "PREGMUX_OUT_%d_%d", lsx, lsy+3);
    device PREGMUX_OUT ( symbol logsym ) *strVar @[gsx+1160,gsy+2710];
    map 
    ( 
        <instance *strVar> => xRef
    );
     
    if(pll_flag == 1)
    {
        xRef = <device G2RCKMUX @[lsx,lsy+2] of ARCHITECTURE>;
        sprintf(strVar, "G2RCKMUX_%d_%d", lsx, lsy+2);
        device G2RCKMUX ( symbol logsym ) *strVar @[gsx+1100,gsy-1200+1000];
        map 
        ( 
            <instance *strVar> => xRef
        );
        
        xRef = <device G2RCKMUX @[lsx,lsy+1] of ARCHITECTURE>;
        sprintf(strVar, "G2RCKMUX_%d_%d", lsx, lsy+1);
        device G2RCKMUX ( symbol logsym ) *strVar @[gsx+1100,gsy-1200+1100];
        map 
        ( 
            <instance *strVar> => xRef
        );
    }
    else
    {
        xRef = <device G2RCKMUX @[lsx,lsy+2] of ARCHITECTURE>;
        sprintf(strVar, "G2RCKMUX_%d_%d", lsx, lsy+2);
        device G2RCKMUX ( symbol logsym ) *strVar @[gsx+1100,gsy+4800+800];
        map 
        ( 
            <instance *strVar> => xRef
        );
        
        xRef = <device G2RCKMUX @[lsx,lsy+1] of ARCHITECTURE>;
        sprintf(strVar, "G2RCKMUX_%d_%d", lsx, lsy+1);
        device G2RCKMUX ( symbol logsym ) *strVar @[gsx+1100,gsy+4800+700];
        map 
        ( 
            <instance *strVar> => xRef
        );
    }
}   // end of function draw_pll_tile

function draw_uscm_tile(unsigned int tx, ty)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    if (ty == 28)
    {
        gsy = gsy + 3 * TILE_NUM_GUI_GRID_Y;
    }
    
    gsy += 4; // adjust for drawing pattern
    
    // device reference variables
    &device xRef;
    string strVar;
    
    unsigned int nx, ny, dx, dy;

    for(ny = 0;ny < 8;ny = ny + 1)
    {
        dx = 0;
        dy = ny;
        
        xRef = <device USCM @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "USCM_%d_%d", lsx+dx, lsy+dy);
        device USCM  ( symbol logsym )  *strVar  @[gsx+500,gsy+204+ny*70];
        map 
        ( 
            <instance *strVar>   => xRef
        );  
        
        xRef = <device USCMMUX @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "USCMMUX_%d_%d", lsx+dx, lsy+dy);
        device USCMMUX  ( symbol logsym )  *strVar  @[gsx+150,gsy+200+ny*70];
        map 
        ( 
            <instance *strVar>   => xRef
        );
        
        xRef = <device USCMMUX_OUT @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "USCMMUX_OUT_%d_%d", lsx+dx, lsy+dy);
        device USCMMUX_OUT  ( symbol logsym )  *strVar  @[gsx+400,gsy+200+ny*70];
        map 
        ( 
            <instance *strVar>   => xRef
        ); 
    }
    
    for(ny = 0;ny < 5;ny = ny + 1)
    {
        dx = 0;
        dy = 15 + ny;
        
        xRef = <device USCMMUX_TEST @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "USCMMUX_TEST_%d_%d", lsx+dx, lsy+dy);
        device USCMMUX_TEST  ( symbol logsym )  *strVar  @[gsx+300,gsy+200+ny*70];
        map 
        ( 
            <instance *strVar>   => xRef
        );
    }
    for(ny = 5;ny < 8;ny = ny + 1)
    {
        dx = 1;
        dy = ny - 5;
        
        xRef = <device USCMMUX_TEST @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "USCMMUX_TEST_%d_%d", lsx+dx, lsy+dy);
        device USCMMUX_TEST  ( symbol logsym )  *strVar  @[gsx+300,gsy+200+ny*70];
        map 
        ( 
            <instance *strVar>   => xRef
        );
    }
    
    // 2nd part
    gsy = gsy + TILE_NUM_GUI_GRID_Y;
    
    for(ny = 0;ny < 7;ny = ny + 1)
    {
        dx = 0;
        dy = 8 + ny;
        
        xRef = <device USCM @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "USCM_%d_%d", lsx+dx, lsy+dy);
        device USCM  ( symbol logsym )  *strVar  @[gsx+500,gsy+204+ny*70];
        map 
        ( 
            <instance *strVar>   => xRef
        );  
        
        xRef = <device USCMMUX @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "USCMMUX_%d_%d", lsx+dx, lsy+dy);
        device USCMMUX  ( symbol logsym )  *strVar  @[gsx+150,gsy+200+ny*70];
        map 
        ( 
            <instance *strVar>   => xRef
        );
        
        xRef = <device USCMMUX_OUT @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "USCMMUX_OUT_%d_%d", lsx+dx, lsy+dy);
        device USCMMUX_OUT  ( symbol logsym )  *strVar  @[gsx+400,gsy+200+ny*70];
        map 
        ( 
            <instance *strVar>   => xRef
        ); 
    }
    
    for(ny = 0;ny < 7;ny = ny + 1)
    {
        dx = 1;
        dy = 3 + ny;
        
        xRef = <device USCMMUX_TEST @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "USCMMUX_TEST_%d_%d", lsx+dx, lsy+dy);
        device USCMMUX_TEST  ( symbol logsym )  *strVar  @[gsx+300,gsy+200+ny*70];
        map 
        ( 
            <instance *strVar>   => xRef
        );
    }
}// end of function draw_uscm_tile

function draw_iol_tile_ud(unsigned int tx, ty, ud)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X + 2;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef, rRef, mRef, nRef;
    
    xRef = <device IOLMUX @[lsx,lsy+1]   of ARCHITECTURE>;
    rRef = <device IOLMUX @[lsx,lsy+2]   of ARCHITECTURE>;
    mRef = <device IOL    @[lsx+1,lsy+1] of ARCHITECTURE>;
    nRef = <device IOL    @[lsx+1,lsy+2] of ARCHITECTURE>;
    // Instantiate the schematic. 
    device LOGIC_IOL_TILE ( schematic logic_iol_tile_schm )
    instance map
    (
        <symbol IOLMUX  @[1100,425]> => xRef,
        <symbol IOLMUX  @[1100,585]> => rRef,
        <symbol IOL     @[960,280] > => mRef,
        <symbol IOL     @[960,540] > => nRef
    )
    @[gsx,gsy];
}   // end of function draw_iol_ud_tile

function draw_iol_tile(unsigned int tx,ty)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X + 2;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef, rRef, mRef, nRef;
    
    xRef = <device IOLMUX @[lsx,lsy+1]   of ARCHITECTURE>;
    rRef = <device IOLMUX @[lsx,lsy+2]   of ARCHITECTURE>;
    mRef = <device IOL    @[lsx+1,lsy+1] of ARCHITECTURE>;
    nRef = <device IOL    @[lsx+1,lsy+2] of ARCHITECTURE>;
    // Instantiate the schematic. 
    device LOGIC_IOL_TILE ( schematic logic_iol_tile_schm )
    instance map
    (
        <symbol IOLMUX  @[1100,425]> => xRef,
        <symbol IOLMUX  @[1100,585]> => rRef,
        <symbol IOL     @[960,280] > => mRef,
        <symbol IOL     @[960,540] > => nRef
    )
    @[gsx,gsy];
}   // end of function draw_iol_tile

function draw_dqsl_tile(unsigned int tx, ty, flag)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;

    lsx = tx * NUM_GRID_X+2;
    lsy = ty * NUM_GRID_Y;

    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }

    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;

    // device reference variables
    &device xRef;
    string strVar;

    xRef = <device DQSL @[lsx,lsy] of ARCHITECTURE>;
    sprintf(strVar, "DQSL_%d_%d", lsx, lsy);
    device DQSL ( symbol logsym ) *strVar @[gsx+800,gsy+280];
    map
    (
        <instance *strVar>   => xRef
    );

    xRef = <device DQSLMUX @[lsx,lsy+1] of ARCHITECTURE>;
    sprintf(strVar, "DQSLMUX_%d_%d", lsx, lsy+1);
    device DQSLMUX ( symbol logsym ) *strVar @[gsx+950,gsy+430];
    map
    (
        <instance *strVar>   => xRef
    );
}   // end of function draw_dqsl_tile

function draw_iockgatedll_tile(unsigned int tx, ty)
{
    unsigned int lsx, lsy, gsx, gsy;

    lsx = tx * NUM_GRID_X + 2;
    lsy = ty * NUM_GRID_Y;

    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
      lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }

    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;

    gsy = gsy + 1200;

    if(tx*2 < NUM_TILE_X)
    {
        gsx = gsx - 1200;   // (dx,dy) = (-1200,1200)

        &device wRef;
        wRef = <device IOCKDLY @[lsx,lsy+4]  of ARCHITECTURE>;
        string strVar0;
        sprintf(strVar0, "IOCKDLY_%d_%d", lsx, lsy+4);
        device IOCKDLY  ( symbol logsym_w )  *strVar0  @[gsx+100,gsy+630];
        map 
        ( 
             <instance *strVar0>   => wRef
         );

        wRef = <device IOCKDLYMUX @[lsx,lsy]  of ARCHITECTURE>;
        string strVar1;
        sprintf(strVar1, "IOCKDLYMUX_%d_%d", lsx, lsy);
        device IOCKDLYMUX  ( symbol logsym_w )  *strVar1  @[gsx+200,gsy+600];
        map 
        ( 
             <instance *strVar1>   => wRef
         );
         
        wRef = <device IOCKDLY @[lsx,lsy+5]  of ARCHITECTURE>;
        string strVar2;
        sprintf(strVar2, "IOCKDLY_%d_%d", lsx, lsy+5);
        device IOCKDLY  ( symbol logsym_w )  *strVar2  @[gsx+100,gsy+830];
        map 
        ( 
             <instance *strVar2>   => wRef
         );

        wRef = <device IOCKDLYMUX @[lsx,lsy+1]  of ARCHITECTURE>;
        string strVar3;
        sprintf(strVar3, "IOCKDLYMUX_%d_%d", lsx, lsy+1);
        device IOCKDLYMUX  ( symbol logsym_w )  *strVar3  @[gsx+200,gsy+800];
        map 
        ( 
             <instance *strVar3>   => wRef
         );
         
        wRef = <device IOCKGMUX @[lsx,lsy+1]  of ARCHITECTURE>;
        string strVar4;
        sprintf(strVar4, "IOCKGMUX_%d_%d", lsx, lsy+1);
        device IOCKGMUX  ( symbol logsym_w )  *strVar4  @[gsx+300,gsy+450+70];
        map 
        ( 
             <instance *strVar4>   => wRef
         );
         
        wRef = <device IOCKGMUX_OUT @[lsx,lsy+1]  of ARCHITECTURE>;
        string strVar5;
        sprintf(strVar5, "IOCKGMUX_OUT_%d_%d", lsx, lsy+1);
        device IOCKGMUX_OUT  ( symbol logsym )  *strVar5  @[gsx+400,gsy+450+35];
        map 
        ( 
             <instance *strVar5>   => wRef
         );
         
        wRef = <device IOCKGMUX_TEST @[lsx,lsy+3]  of ARCHITECTURE>;
        string strVar6;
        sprintf(strVar6, "IOCKGMUX_TEST_%d_%d", lsx, lsy+3);
        device IOCKGMUX_TEST  ( symbol logsym )  *strVar6  @[gsx+300,gsy+450];
        map 
        ( 
             <instance *strVar6>   => wRef
         ); 
         
        wRef = <device IOCKGATE @[lsx,lsy+1]  of ARCHITECTURE>;
        string strVar7;
        sprintf(strVar7, "IOCKGATE_%d_%d", lsx, lsy+1);
        device IOCKGATE  ( symbol logsym_w )  *strVar7  @[gsx+500,gsy+505];
        map 
        ( 
             <instance *strVar7>   => wRef
         ); 
         
        wRef = <device IOCKDIV @[lsx,lsy+9]  of ARCHITECTURE>;
        string strVar8;
        sprintf(strVar8, "IOCKDIV_%d_%d", lsx, lsy+9);
        device IOCKDIV  ( symbol logsym_w )  *strVar8  @[gsx+600,gsy+470];
        map 
        ( 
             <instance *strVar8>   => wRef
         ); 
         
        wRef = <device RCKBMUX @[lsx,lsy+1]  of ARCHITECTURE>;
        string strVar9;
        sprintf(strVar9, "RCKBMUX_%d_%d", lsx, lsy+1);
        device RCKBMUX ( symbol logsym )  *strVar9  @[gsx+700,gsy+450+70*3];
        map 
        ( 
             <instance *strVar9>   => wRef
         );

        wRef = <device RCKBMUX_OUT @[lsx+1,lsy+8]  of ARCHITECTURE>;
        string strVar10;
        sprintf(strVar10, "RCKBMUX_OUT_%d_%d", lsx+1, lsy+8);
        device RCKBMUX_OUT ( symbol logsym )  *strVar10  @[gsx+800,gsy+450+70*2+35];
        map 
        ( 
             <instance *strVar10>   => wRef
         );
         
        wRef = <device RCKBMUX_TEST @[lsx,lsy+11]  of ARCHITECTURE>;
        string strVar11;
        sprintf(strVar11, "RCKBMUX_TEST_%d_%d", lsx, lsy+11);
        device RCKBMUX_TEST ( symbol logsym )  *strVar11  @[gsx+700,gsy+450+70*2];
        map 
        ( 
             <instance *strVar11>   => wRef
         );
         
        wRef = <device VCKBMUX @[lsx,lsy+1]  of ARCHITECTURE>;
        string strVar12;
        sprintf(strVar12, "VCKBMUX_%d_%d", lsx, lsy+1);
        device VCKBMUX ( symbol logsym )  *strVar12  @[gsx+900,gsy+450+70*5];
        map 
        ( 
             <instance *strVar12>   => wRef
         );
         
        wRef = <device VCKBMUX_OUT @[lsx+1,lsy+9]  of ARCHITECTURE>;
        string strVar13;
        sprintf(strVar13, "VCKBMUX_OUT_%d_%d", lsx+1, lsy+9);
        device VCKBMUX_OUT ( symbol logsym )  *strVar13  @[gsx+1000,gsy+450+70*4+35];
        map 
        ( 
             <instance *strVar13>   => wRef
         );
         
        wRef = <device VCKBMUX_TEST @[lsx+1,lsy+1]  of ARCHITECTURE>;
        string strVar14;
        sprintf(strVar14, "VCKBMUX_TEST_%d_%d", lsx+1, lsy+1);
        device VCKBMUX_TEST ( symbol logsym )  *strVar14  @[gsx+900,gsy+450+70*4];
        map 
        ( 
             <instance *strVar14>   => wRef
         );

        // (dx,dy) = (-1200,1200)
        wRef = <device IOCKDLY @[lsx,lsy+6]  of ARCHITECTURE>;
        string strVar15;
        sprintf(strVar15, "IOCKDLY_%d_%d", lsx, lsy+6);
        device IOCKDLY  ( symbol logsym_w )  *strVar15  @[gsx+100,gsy+30];
        map 
        ( 
             <instance *strVar15>   => wRef
         );

        wRef = <device IOCKDLYMUX @[lsx,lsy+2]  of ARCHITECTURE>;
        string strVar16;
        sprintf(strVar16, "IOCKDLYMUX_%d_%d", lsx, lsy+2);
        device IOCKDLYMUX  ( symbol logsym_w )  *strVar16  @[gsx+200,gsy+0];
        map 
        ( 
             <instance *strVar16>   => wRef
         );
         
        wRef = <device IOCKDLY @[lsx,lsy+7]  of ARCHITECTURE>;
        string strVar17;
        sprintf(strVar17, "IOCKDLY_%d_%d", lsx, lsy+7);
        device IOCKDLY  ( symbol logsym_w )  *strVar17  @[gsx+100,gsy+230];
        map 
        ( 
             <instance *strVar17>   => wRef
         );

        wRef = <device IOCKDLYMUX @[lsx,lsy+3]  of ARCHITECTURE>;
        string strVar18;
        sprintf(strVar18, "IOCKDLYMUX_%d_%d", lsx, lsy+3);
        device IOCKDLYMUX  ( symbol logsym_w )  *strVar18  @[gsx+200,gsy+200];
        map 
        ( 
             <instance *strVar18>   => wRef
         );

        wRef = <device IOCKGMUX @[lsx,lsy]  of ARCHITECTURE>;
        string strVar19;
        sprintf(strVar19, "IOCKGMUX_%d_%d", lsx, lsy);
        device IOCKGMUX  ( symbol logsym_w )  *strVar19  @[gsx+300,gsy+350];
        map 
        ( 
             <instance *strVar19>   => wRef
         );
         
        wRef = <device IOCKGMUX_OUT @[lsx+1,lsy+10]  of ARCHITECTURE>;
        string strVar20;
        sprintf(strVar20, "IOCKGMUX_OUT_%d_%d", lsx+1, lsy+10);
        device IOCKGMUX_OUT  ( symbol logsym )  *strVar20  @[gsx+400,gsy+350-70+35];
        map 
        ( 
             <instance *strVar20>   => wRef
         );
         
        wRef = <device IOCKGMUX_TEST @[lsx,lsy+2]  of ARCHITECTURE>;
        string strVar21;
        sprintf(strVar21, "IOCKGMUX_TEST_%d_%d", lsx, lsy+2);
        device IOCKGMUX_TEST  ( symbol logsym )  *strVar21  @[gsx+300,gsy+350-70];
        map 
        ( 
             <instance *strVar21>   => wRef
         );
         
        wRef = <device IOCKGATE @[lsx,lsy]  of ARCHITECTURE>;
        string strVar22;
        sprintf(strVar22, "IOCKGATE_%d_%d", lsx, lsy);
        device IOCKGATE  ( symbol logsym_w )  *strVar22  @[gsx+500,gsy+335];
        map 
        ( 
             <instance *strVar22>   => wRef
         ); 
         
        wRef = <device IOCKDIV @[lsx,lsy+8]  of ARCHITECTURE>;
        string strVar23;
        sprintf(strVar23, "IOCKDIV_%d_%d", lsx, lsy+8);
        device IOCKDIV  ( symbol logsym_w )  *strVar23  @[gsx+600,gsy+370];
        map 
        ( 
             <instance *strVar23>   => wRef
         ); 
         
        wRef = <device RCKBMUX @[lsx,lsy]  of ARCHITECTURE>;
        string strVar24;
        sprintf(strVar24, "RCKBMUX_%d_%d", lsx, lsy);
        device RCKBMUX ( symbol logsym )  *strVar24  @[gsx+700,gsy+350-70*2];
        map 
        ( 
             <instance *strVar24>   => wRef
         );

        wRef = <device RCKBMUX_OUT @[lsx+1,lsy+11]  of ARCHITECTURE>;
        string strVar25;
        sprintf(strVar25, "RCKBMUX_OUT_%d_%d", lsx+1, lsy+11);
        device RCKBMUX_OUT ( symbol logsym )  *strVar25  @[gsx+800,gsy+350-70*3+35];
        map 
        ( 
             <instance *strVar25>   => wRef
         );
         
        wRef = <device RCKBMUX_TEST @[lsx,lsy+10]  of ARCHITECTURE>;
        string strVar26;
        sprintf(strVar26, "RCKBMUX_TEST_%d_%d", lsx, lsy+10);
        device RCKBMUX_TEST ( symbol logsym )  *strVar26  @[gsx+700,gsy+350-70*3];
        map 
        ( 
             <instance *strVar26>   => wRef
         );
         
        wRef = <device VCKBMUX @[lsx,lsy]  of ARCHITECTURE>;
        string strVar27;
        sprintf(strVar27, "VCKBMUX_%d_%d", lsx, lsy);
        device VCKBMUX ( symbol logsym )  *strVar27  @[gsx+900,gsy+350-70*4];
        map 
        ( 
             <instance *strVar27>   => wRef
         );
         
        wRef = <device VCKBMUX_OUT @[lsx,lsy]  of ARCHITECTURE>;
        string strVar28;
        sprintf(strVar28, "VCKBMUX_OUT_%d_%d", lsx, lsy);
        device VCKBMUX_OUT ( symbol logsym )  *strVar28  @[gsx+1000,gsy+350-70*5+35];
        map 
        ( 
             <instance *strVar28>   => wRef
         );
         
        wRef = <device VCKBMUX_TEST @[lsx+1,lsy]  of ARCHITECTURE>;
        string strVar29;
        sprintf(strVar29, "VCKBMUX_TEST_%d_%d", lsx+1, lsy);
        device VCKBMUX_TEST ( symbol logsym )  *strVar29  @[gsx+900,gsy+350-70*5];
        map 
        ( 
             <instance *strVar29>   => wRef
         );
         
        gsx = gsx + 1200;   // (dx,dy) = (0,1200)

        &device sRef;
        sRef  = <device CKEB  @[lsx,lsy]     of ARCHITECTURE>;
        string strVar32;
        sprintf(strVar32, "CKEB_%d_%d", lsx, lsy);
        device CKEB   ( symbol logsym )  *strVar32  @[gsx+1000,gsy+920];
        map 
        ( 
            <instance *strVar32>   => sRef
         );    

        sRef = <device CKEBMUX @[lsx+0,lsy+0]  of ARCHITECTURE>;
        sprintf(strVar32, "CKEBMUX_%d_%d", lsx+0, lsy+0);
        device CKEBMUX  ( symbol logsym )  *strVar32  @[gsx+600,gsy+900];
        map 
        ( 
             <instance *strVar32>   => sRef
         );
         
        gsx = gsx + 1200;   // (dx,dy) = (1200,1200)

        &device xRef;     
        xRef  = <device DLLMUX  @[lsx,lsy]     of ARCHITECTURE>;
        string strVar30;
        sprintf(strVar30, "DLLMUX_%d_%d", lsx, lsy);
        device DLLMUX   ( symbol logsym_w )  *strVar30  @[gsx+600,gsy+430];
        map 
        ( 
            <instance *strVar30>   => xRef
         );   
         
         // Pull out the device instances from logic structure  
        &device mRef;
        mRef  = <device DLL  @[lsx+1,lsy+3]     of ARCHITECTURE>;
        string strVar31;
        sprintf(strVar31, "DLL_%d_%d", lsx+1, lsy+3);
        device DLL   ( symbol logsym )  *strVar31  @[gsx+700,gsy+320];
        map 
        ( 
            <instance *strVar31>   => mRef
         );
         
        // Pull out the device instances from logic structure  
        sRef  = <device RCKB  @[lsx+1,lsy+4]     of ARCHITECTURE>;
        string strVar33;
        sprintf(strVar33, "RCKB_%d_%d", lsx+1, lsy+4);
        device RCKB   ( symbol logsym )  *strVar33  @[gsx+500,gsy+250];
        map 
        ( 
            <instance *strVar33>   => sRef
         );
         
        sRef  = <device RCKB  @[lsx+1,lsy+5]     of ARCHITECTURE>;
        string strVar34;
        sprintf(strVar34, "RCKB_%d_%d", lsx+1, lsy+5);
        device RCKB   ( symbol logsym )  *strVar34  @[gsx+500,gsy+550];
        map 
        ( 
            <instance *strVar34>   => sRef
         );
         
        sRef  = <device RCKB  @[lsx+1,lsy+6]     of ARCHITECTURE>;
        string strVar35;
        sprintf(strVar35, "RCKB_%d_%d", lsx+1, lsy+6);
        device RCKB   ( symbol logsym )  *strVar35  @[gsx+500,gsy+350];
        map 
        ( 
            <instance *strVar35>   => sRef
         );
         
        sRef  = <device RCKB  @[lsx+1,lsy+7]     of ARCHITECTURE>;
        string strVar36;
        sprintf(strVar36, "RCKB_%d_%d", lsx+1, lsy+7);
        device RCKB   ( symbol logsym )  *strVar36  @[gsx+500,gsy+450];
        map 
        ( 
            <instance *strVar36>   => sRef
         );
    }
    else
    {
        gsx = gsx + 1200;   // (dx,dy) = (1200,1200)

        &device wRef;
        wRef = <device IOCKDLY @[lsx,lsy+4]  of ARCHITECTURE>;
        string strVar0;
        sprintf(strVar0, "IOCKDLY_%d_%d", lsx, lsy+4);
        device IOCKDLY  ( symbol logsym_e )  *strVar0  @[gsx+1100,gsy+630];
        map
        (
             <instance *strVar0>   => wRef
        );

        wRef = <device IOCKDLYMUX @[lsx,lsy]  of ARCHITECTURE>;
        string strVar1;
        sprintf(strVar1, "IOCKDLYMUX_%d_%d", lsx, lsy);
        device IOCKDLYMUX  ( symbol logsym_e )  *strVar1  @[gsx+1000,gsy+600];
        map
        (
             <instance *strVar1>   => wRef
        );

        wRef = <device IOCKDLY @[lsx,lsy+5]  of ARCHITECTURE>;
        string strVar2;
        sprintf(strVar2, "IOCKDLY_%d_%d", lsx, lsy+5);
        device IOCKDLY  ( symbol logsym_e )  *strVar2  @[gsx+1100,gsy+830];
        map
        (
            <instance *strVar2>   => wRef
        );

        wRef = <device IOCKDLYMUX @[lsx,lsy+1]  of ARCHITECTURE>;
        string strVar3;
        sprintf(strVar3, "IOCKDLYMUX_%d_%d", lsx, lsy+1);
        device IOCKDLYMUX  ( symbol logsym_e )  *strVar3  @[gsx+1000,gsy+800];
        map
        (
            <instance *strVar3>   => wRef
        );

        wRef = <device IOCKGMUX @[lsx,lsy+1]  of ARCHITECTURE>;
        string strVar4;
        sprintf(strVar4, "IOCKGMUX_%d_%d", lsx, lsy+1);
        device IOCKGMUX  ( symbol logsym_e )  *strVar4  @[gsx+900,gsy+450+70];
        map
        (
            <instance *strVar4>   => wRef
        );

        wRef = <device IOCKGMUX_OUT @[lsx,lsy+1]  of ARCHITECTURE>;
        string strVar5;
        sprintf(strVar5, "IOCKGMUX_OUT_%d_%d", lsx, lsy+1);
        device IOCKGMUX_OUT  ( symbol logsym_e )  *strVar5  @[gsx+800,gsy+450+35];
        map
        (
            <instance *strVar5>   => wRef
        );

        wRef = <device IOCKGMUX_TEST @[lsx,lsy+3]  of ARCHITECTURE>;
        string strVar6;
        sprintf(strVar6, "IOCKGMUX_TEST_%d_%d", lsx, lsy+3);
        device IOCKGMUX_TEST  ( symbol logsym_e )  *strVar6  @[gsx+900,gsy+450];
        map
        (
            <instance *strVar6>   => wRef
        );

        wRef = <device IOCKGATE @[lsx,lsy+1]  of ARCHITECTURE>;
        string strVar7;
        sprintf(strVar7, "IOCKGATE_%d_%d", lsx, lsy+1);
        device IOCKGATE  ( symbol logsym_e )  *strVar7  @[gsx+700,gsy+505];
        map
        (
            <instance *strVar7>   => wRef
        );

        wRef = <device IOCKDIV @[lsx,lsy+9]  of ARCHITECTURE>;
        string strVar8;
        sprintf(strVar8, "IOCKDIV_%d_%d", lsx, lsy+9);
        device IOCKDIV  ( symbol logsym_e )  *strVar8  @[gsx+600,gsy+470];
        map
        (
             <instance *strVar8>   => wRef
        );

        wRef = <device RCKBMUX @[lsx,lsy+1]  of ARCHITECTURE>;
        string strVar9;
        sprintf(strVar9, "RCKBMUX_%d_%d", lsx, lsy+1);
        device RCKBMUX ( symbol logsym_e )  *strVar9  @[gsx+500,gsy+450+70*3];
        map
        (
             <instance *strVar9>   => wRef
        );

        wRef = <device RCKBMUX_OUT @[lsx+1,lsy+8]  of ARCHITECTURE>;
        string strVar10;
        sprintf(strVar10, "RCKBMUX_OUT_%d_%d", lsx+1, lsy+8);
        device RCKBMUX_OUT ( symbol logsym_e )  *strVar10  @[gsx+400,gsy+450+70*2+35];
        map
        (
             <instance *strVar10>   => wRef
        );

        wRef = <device RCKBMUX_TEST @[lsx,lsy+11]  of ARCHITECTURE>;
        string strVar11;
        sprintf(strVar11, "RCKBMUX_TEST_%d_%d", lsx, lsy+11);
        device RCKBMUX_TEST ( symbol logsym_e )  *strVar11  @[gsx+500,gsy+450+70*2];
        map
        (
             <instance *strVar11>   => wRef
        );

        wRef = <device VCKBMUX @[lsx,lsy+1]  of ARCHITECTURE>;
        string strVar12;
        sprintf(strVar12, "VCKBMUX_%d_%d", lsx, lsy+1);
        device VCKBMUX ( symbol logsym_e )  *strVar12  @[gsx+300,gsy+450+70*5];
        map
        (
             <instance *strVar12>   => wRef
        );

        wRef = <device VCKBMUX_OUT @[lsx+1,lsy+9]  of ARCHITECTURE>;
        string strVar13;
        sprintf(strVar13, "VCKBMUX_OUT_%d_%d", lsx+1, lsy+9);
        device VCKBMUX_OUT ( symbol logsym_e )  *strVar13  @[gsx+200,gsy+450+70*4+35];
        map
        (
            <instance *strVar13>   => wRef
        );

        wRef = <device VCKBMUX_TEST @[lsx+1,lsy+1]  of ARCHITECTURE>;
        string strVar14;
        sprintf(strVar14, "VCKBMUX_TEST_%d_%d", lsx+1, lsy+1);
        device VCKBMUX_TEST ( symbol logsym_e )  *strVar14  @[gsx+300,gsy+450+70*4];
        map
        (
            <instance *strVar14>   => wRef
        );

        // (dx,dy) = (1200,1200)
        wRef = <device IOCKDLY @[lsx,lsy+6]  of ARCHITECTURE>;
        string strVar15;
        sprintf(strVar15, "IOCKDLY_%d_%d", lsx, lsy+6);
        device IOCKDLY  ( symbol logsym_e )  *strVar15  @[gsx+1100,gsy+30];
        map
        (
            <instance *strVar15>   => wRef
        );

        wRef = <device IOCKDLYMUX @[lsx,lsy+2]  of ARCHITECTURE>;
        string strVar16;
        sprintf(strVar16, "IOCKDLYMUX_%d_%d", lsx, lsy+2);
        device IOCKDLYMUX  ( symbol logsym_e )  *strVar16  @[gsx+1000,gsy+0];
        map
        (
            <instance *strVar16>   => wRef
        );

        wRef = <device IOCKDLY @[lsx,lsy+7]  of ARCHITECTURE>;
        string strVar17;
        sprintf(strVar17, "IOCKDLY_%d_%d", lsx, lsy+7);
        device IOCKDLY  ( symbol logsym_e )  *strVar17  @[gsx+1100,gsy+230];
        map
        (
            <instance *strVar17>   => wRef
        );

        wRef = <device IOCKDLYMUX @[lsx,lsy+3]  of ARCHITECTURE>;
        string strVar18;
        sprintf(strVar18, "IOCKDLYMUX_%d_%d", lsx, lsy+3);
        device IOCKDLYMUX  ( symbol logsym_e )  *strVar18  @[gsx+1000,gsy+200];
        map
        (
            <instance *strVar18>   => wRef
        );

        wRef = <device IOCKGMUX @[lsx,lsy]  of ARCHITECTURE>;
        string strVar19;
        sprintf(strVar19, "IOCKGMUX_%d_%d", lsx, lsy);
        device IOCKGMUX  ( symbol logsym_e )  *strVar19  @[gsx+900,gsy+350];
        map
        (
            <instance *strVar19>   => wRef
        );

        wRef = <device IOCKGMUX_OUT @[lsx+1,lsy+10]  of ARCHITECTURE>;
        string strVar20;
        sprintf(strVar20, "IOCKGMUX_OUT_%d_%d", lsx+1, lsy+10);
        device IOCKGMUX_OUT  ( symbol logsym_e )  *strVar20  @[gsx+800,gsy+350-70+35];
        map
        (
            <instance *strVar20>   => wRef
        );

        wRef = <device IOCKGMUX_TEST @[lsx,lsy+2]  of ARCHITECTURE>;
        string strVar21;
        sprintf(strVar21, "IOCKGMUX_TEST_%d_%d", lsx, lsy+2);
        device IOCKGMUX_TEST  ( symbol logsym_e )  *strVar21  @[gsx+900,gsy+350-70];
        map
        (
            <instance *strVar21>   => wRef
        );

        wRef = <device IOCKGATE @[lsx,lsy]  of ARCHITECTURE>;
        string strVar22;
        sprintf(strVar22, "IOCKGATE_%d_%d", lsx, lsy);
        device IOCKGATE  ( symbol logsym_e )  *strVar22  @[gsx+700,gsy+335];
        map
        (
            <instance *strVar22>   => wRef
        );

        wRef = <device IOCKDIV @[lsx,lsy+8]  of ARCHITECTURE>;
        string strVar23;
        sprintf(strVar23, "IOCKDIV_%d_%d", lsx, lsy+8);
        device IOCKDIV  ( symbol logsym_e )  *strVar23  @[gsx+600,gsy+370];
        map
        (
            <instance *strVar23>   => wRef
        );

        wRef = <device RCKBMUX @[lsx,lsy]  of ARCHITECTURE>;
        string strVar24;
        sprintf(strVar24, "RCKBMUX_%d_%d", lsx, lsy);
        device RCKBMUX ( symbol logsym_e )  *strVar24  @[gsx+500,gsy+350-70*2];
        map
        (
            <instance *strVar24>   => wRef
        );

        wRef = <device RCKBMUX_OUT @[lsx+1,lsy+11]  of ARCHITECTURE>;
        string strVar25;
        sprintf(strVar25, "RCKBMUX_OUT_%d_%d", lsx+1, lsy+11);
        device RCKBMUX_OUT ( symbol logsym_e )  *strVar25  @[gsx+400,gsy+350-70*3+35];
        map
        (
            <instance *strVar25>   => wRef
        );

        wRef = <device RCKBMUX_TEST @[lsx,lsy+10]  of ARCHITECTURE>;
        string strVar26;
        sprintf(strVar26, "RCKBMUX_TEST_%d_%d", lsx, lsy+10);
        device RCKBMUX_TEST ( symbol logsym_e )  *strVar26  @[gsx+500,gsy+350-70*3];
        map
        (
            <instance *strVar26>   => wRef
        );

        wRef = <device VCKBMUX @[lsx,lsy]  of ARCHITECTURE>;
        string strVar27;
        sprintf(strVar27, "VCKBMUX_%d_%d", lsx, lsy);
        device VCKBMUX ( symbol logsym_e )  *strVar27  @[gsx+300,gsy+350-70*4];
        map
        (
            <instance *strVar27>   => wRef
        );

        wRef = <device VCKBMUX_OUT @[lsx,lsy]  of ARCHITECTURE>;
        string strVar28;
        sprintf(strVar28, "VCKBMUX_OUT_%d_%d", lsx, lsy);
        device VCKBMUX_OUT ( symbol logsym_e )  *strVar28  @[gsx+200,gsy+350-70*5+35];
        map
        (
            <instance *strVar28>   => wRef
        );

        wRef = <device VCKBMUX_TEST @[lsx+1,lsy]  of ARCHITECTURE>;
        string strVar29;
        sprintf(strVar29, "VCKBMUX_TEST_%d_%d", lsx+1, lsy);
        device VCKBMUX_TEST ( symbol logsym_e )  *strVar29  @[gsx+300,gsy+350-70*5];
        map
        (
             <instance *strVar29>   => wRef
        );

        gsx = gsx - 1200;   // (dx,dy) = (0,1200)
        
        &device sRef;
        sRef  = <device CKEB  @[lsx,lsy]     of ARCHITECTURE>;
        string strVar32;
        sprintf(strVar32, "CKEB_%d_%d", lsx, lsy);
        device CKEB   ( symbol logsym )  *strVar32  @[gsx+1000,gsy+920];
        map
        (
            <instance *strVar32>   => sRef
        );

        sRef = <device CKEBMUX @[lsx+0,lsy+0]  of ARCHITECTURE>;
        sprintf(strVar32, "CKEBMUX_%d_%d", lsx+0, lsy+0);
        device CKEBMUX  ( symbol logsym )  *strVar32  @[gsx+600,gsy+900];
        map
        (
            <instance *strVar32>   => sRef
        );

        gsx = gsx - 1200;   // (dx,dy) = (-1200,1200)
        
        &device xRef;     
        xRef  = <device DLLMUX  @[lsx,lsy]     of ARCHITECTURE>;
        string strVar30;
        sprintf(strVar30, "DLLMUX_%d_%d", lsx, lsy);
        device DLLMUX   ( symbol logsym )  *strVar30  @[gsx+1000,gsy+430];
        map
        (
            <instance *strVar30>   => xRef
        );

         // Pull out the device instances from logic structure  
        &device mRef;
        mRef  = <device DLL  @[lsx+1,lsy+3]     of ARCHITECTURE>;
        string strVar31;
        sprintf(strVar31, "DLL_%d_%d", lsx+1, lsy+3);
        device DLL   ( symbol logsym_1 )  *strVar31  @[gsx+900,gsy+320];
        map
        (
            <instance *strVar31>   => mRef
        );

        // Pull out the device instances from logic structure  
        sRef  = <device RCKB  @[lsx+1,lsy+4]     of ARCHITECTURE>;
        string strVar33;
        sprintf(strVar33, "RCKB_%d_%d", lsx+1, lsy+4);
        device RCKB   ( symbol logsym_e )  *strVar33  @[gsx+1100,gsy+250];
        map
        (
            <instance *strVar33>   => sRef
        );

        sRef  = <device RCKB  @[lsx+1,lsy+5]     of ARCHITECTURE>;
        string strVar34;
        sprintf(strVar34, "RCKB_%d_%d", lsx+1, lsy+5);
        device RCKB   ( symbol logsym_e )  *strVar34  @[gsx+1100,gsy+550];
        map
        (
            <instance *strVar34>   => sRef
        );

        sRef  = <device RCKB  @[lsx+1,lsy+6]     of ARCHITECTURE>;
        string strVar35;
        sprintf(strVar35, "RCKB_%d_%d", lsx+1, lsy+6);
        device RCKB   ( symbol logsym_e )  *strVar35  @[gsx+1100,gsy+350];
        map
        (
            <instance *strVar35>   => sRef
        );

        sRef  = <device RCKB  @[lsx+1,lsy+7]     of ARCHITECTURE>;
        string strVar36;
        sprintf(strVar36, "RCKB_%d_%d", lsx+1, lsy+7);
        device RCKB   ( symbol logsym_e )  *strVar36  @[gsx+1100,gsy+450];
        map
        (
            <instance *strVar36>   => sRef
        );
    }
}  // end of function draw_iockgatedll

function draw_iockdll_tile(unsigned int tx, ty, tx_iockdll, ty_iockdll)
{
    unsigned int lsx, lsy, gsx, gsy, lsx_iockdll, lsy_iockdll;

    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;
    lsx_iockdll = tx_iockdll * NUM_GRID_X +2 ;    
    lsy_iockdll = ty_iockdll * NUM_GRID_Y ;    

    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
      lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }

    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;

    &device wRef;
    wRef = <device IOCKDLY @[lsx,lsy] of ARCHITECTURE>;
    string strVar0;
    //printf("IOCKDLY: %d %d", gsx+10, gsy+10);
    sprintf(strVar0, "IOCKDLY_%d_%d", lsx, lsy);
    device IOCKDLY  ( symbol logsym_w )  *strVar0  @[gsx+10,gsy+10];
    map
    (
         <instance *strVar0>   => wRef
    );

    wRef = <device IOCKDLYMUX @[lsx,lsy+1] of ARCHITECTURE>;
    string strVar1;
    //printf("IOCKDLYMUX: %d %d", gsx, gsy+100);
    sprintf(strVar1, "IOCKDLYMUX_%d_%d", lsx, lsy+1);
    device IOCKDLYMUX  ( symbol logsym_w )  *strVar1  @[gsx+10,gsy+110];
    map
    (
         <instance *strVar1>   => wRef
    );

    wRef = <device IOCKDLY @[lsx,lsy+2] of ARCHITECTURE>;
    string strVar2;
    //printf("IOCKDLY: %d %d", gsx, gsy+200);
    sprintf(strVar2, "IOCKDLY_%d_%d", lsx, lsy+2);
    device IOCKDLY  ( symbol logsym_w )  *strVar2  @[gsx+10,gsy+210];
    map
    (
         <instance *strVar2>   => wRef
    );

    wRef = <device IOCKDLYMUX @[lsx,lsy+3] of ARCHITECTURE>;
    string strVar3;
    //printf("IOCKDLYMUX: %d %d", gsx, gsy+300);
    sprintf(strVar3, "IOCKDLYMUX_%d_%d", lsx, lsy+3);
    device IOCKDLYMUX  ( symbol logsym_w )  *strVar3  @[gsx+10,gsy+310];
    map
    (
         <instance *strVar3>   => wRef
    );

    wRef = <device IOCKGMUX @[lsx,lsy+4] of ARCHITECTURE>;
    string strVar4;
    //printf("IOCKGMUX: %d %d", gsx, gsy+400);
    sprintf(strVar4, "IOCKGMUX_%d_%d", lsx, lsy+4);
    device IOCKGMUX  ( symbol logsym_w )  *strVar4  @[gsx+10,gsy+410];
    map
    (
         <instance *strVar4>   => wRef
    );

    wRef = <device IOCKGMUX_TEST @[lsx,lsy+5] of ARCHITECTURE>;
    string strVar5;
    //printf("IOCKGMUX_TEST: %d %d", gsx, gsy+500);
    sprintf(strVar5, "IOCKGMUX_TEST_%d_%d", lsx, lsy+5);
    device IOCKGMUX_TEST  ( symbol logsym )  *strVar5  @[gsx+10,gsy+510];
    map
    (
         <instance *strVar5>   => wRef
    );

    wRef = <device IOCKGMUX_OUT @[lsx,lsy+6] of ARCHITECTURE>;
    string strVar6;
    //printf("IOCKGMUX_OUT: %d %d", gsx, gsy+600);
    sprintf(strVar6, "IOCKGMUX_OUT_%d_%d", lsx, lsy+6);
    device IOCKGMUX_OUT  ( symbol logsym )  *strVar6  @[gsx+10,gsy+610];
    map
    (
         <instance *strVar6>   => wRef
    );

    wRef = <device IOCKGATE @[lsx+1,lsy] of ARCHITECTURE>;
    string strVar7;
    //printf("IOCKGATE: %d %d", gsx+100, gsy);
    sprintf(strVar7, "IOCKGATE_%d_%d", lsx+1, lsy);
    device IOCKGATE  ( symbol logsym_w )  *strVar7  @[gsx+110,gsy+10];
    map
    (
         <instance *strVar7>   => wRef
    );

    wRef = <device IOCKDIV @[lsx+1,lsy+1] of ARCHITECTURE>;
    string strVar8;
    //printf("IOCKDIV: %d %d", gsx+100, gsy+100);
    sprintf(strVar8, "IOCKDIV_%d_%d", lsx+1, lsy+1);
    device IOCKDIV  ( symbol logsym_w )  *strVar8  @[gsx+110,gsy+110];
    map
    (
         <instance *strVar8>   => wRef
    );

    wRef = <device IOCKDLY @[lsx+1,lsy+5] of ARCHITECTURE>;
    string strVar9;
    //printf("IOCKDLY: %d %d", gsx+100, gsy+500);
    sprintf(strVar9, "IOCKDLY_%d_%d", lsx+1, lsy+5);
    device IOCKDLY  ( symbol logsym_w )  *strVar9  @[gsx+110,gsy+510];
    map
    (
         <instance *strVar9>   => wRef
    );

    wRef = <device IOCKDLYMUX @[lsx+1,lsy+6] of ARCHITECTURE>;
    string strVar10;
    //printf("IOCKDLYMUX: %d %d", gsx+100, gsy+600);
    sprintf(strVar10, "IOCKDLYMUX_%d_%d", lsx+1, lsy+6);
    device IOCKDLYMUX  ( symbol logsym_w )  *strVar10  @[gsx+110,gsy+610];
    map
    (
         <instance *strVar10>   => wRef
    );

    wRef = <device IOCKDLY @[lsx+1,lsy+7] of ARCHITECTURE>;
    string strVar11;
    //printf("IOCKDLY: %d %d", gsx+100, gsy+700);
    sprintf(strVar11, "IOCKDLY_%d_%d", lsx+1, lsy+7);
    device IOCKDLY  ( symbol logsym_w )  *strVar11  @[gsx+110,gsy+710];
    map
    (
         <instance *strVar11>   => wRef
    );

    wRef = <device IOCKDLYMUX @[lsx+3,lsy+3] of ARCHITECTURE>;
    string strVar12;
    //printf("IOCKDLYMUX: %d %d", gsx+300, gsy+300);
    sprintf(strVar12, "IOCKDLYMUX_%d_%d", lsx+3, lsy+3);
    device IOCKDLYMUX  ( symbol logsym_w )  *strVar12  @[gsx+310,gsy+310];
    map
    (
         <instance *strVar12>   => wRef
    );

    wRef = <device IOCKGMUX @[lsx+3,lsy+2] of ARCHITECTURE>;
    string strVar13;
    //printf("IOCKGMUX: %d %d", gsx+300, gsy+200);
    sprintf(strVar13, "IOCKGMUX_%d_%d", lsx+3, lsy+2);
    device IOCKGMUX  ( symbol logsym_w )  *strVar13  @[gsx+310,gsy+210];
    map
    (
         <instance *strVar13>   => wRef
    );

    wRef = <device IOCKGMUX_TEST @[lsx+3,lsy+1] of ARCHITECTURE>;
    string strVar14;
    //printf("IOCKGMUX_TEST: %d %d", gsx+300, gsy+100);
    sprintf(strVar14, "IOCKGMUX_TEST_%d_%d", lsx+3, lsy+1);
    device IOCKGMUX_TEST  ( symbol logsym )  *strVar14  @[gsx+310,gsy+110];
    map
    (
         <instance *strVar14>   => wRef
    );

    wRef = <device IOCKGMUX_OUT @[lsx+3,lsy] of ARCHITECTURE>;
    string strVar15;
    //printf("IOCKGMUX_OUT: %d %d", gsx+300, gsy);
    sprintf(strVar15, "IOCKGMUX_OUT_%d_%d", lsx+3, lsy);
    device IOCKGMUX_OUT  ( symbol logsym )  *strVar15  @[gsx+310,gsy+10];
    map
    (
         <instance *strVar15>   => wRef
    );

    wRef = <device IOCKGATE @[lsx+2,lsy] of ARCHITECTURE>;
    string strVar16;
    //printf("IOCKGATE: %d %d", gsx+200, gsy);
    sprintf(strVar16, "IOCKGATE_%d_%d", lsx+2, lsy);
    device IOCKGATE  ( symbol logsym_w )  *strVar16  @[gsx+210,gsy];
    map
    (
         <instance *strVar16>   => wRef
    );

    wRef = <device IOCKDIV @[lsx+2,lsy+1] of ARCHITECTURE>;
    string strVar17;
    //printf("IOCKDIV: %d %d", gsx+200, gsy+100);
    sprintf(strVar17, "IOCKDIV_%d_%d", lsx+2, lsy+1);
    device IOCKDIV  ( symbol logsym_w )  *strVar17  @[gsx+210,gsy+110];
    map
    (
         <instance *strVar17>   => wRef
    );

    wRef = <device DLLMUX @[lsx+2,lsy+2] of ARCHITECTURE>;
    string strVar18;
    //printf("DLLMUX: %d %d", gsx+200, gsy+200);
    sprintf(strVar18, "DLLMUX_%d_%d", lsx+2, lsy+2);
    device DLLMUX  ( symbol logsym_w )  *strVar18  @[gsx+710,gsy+210];
    map
    (
         <instance *strVar18>   => wRef
    );

    wRef = <device DLL @[lsx+2,lsy+3] of ARCHITECTURE>;
    string strVar19;
    //printf("DLL: %d %d", gsx+1600, gsy+300);
    sprintf(strVar19, "DLL_%d_%d", lsx+2, lsy+3);
    device DLL  ( symbol logsym )  *strVar19  @[gsx+910,gsy+310];
    map
    (
         <instance *strVar19>   => wRef
    );
}

function draw_iob_tile_u(unsigned int tx, ty)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;

    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;

    unsigned int temp_ty;
    for(temp_ty = ty; temp_ty > MID_TILE_REGION; temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }

    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;

    unsigned int dx, dy;
    unsigned int d_tx, d_tx_l;

    // device reference variables
    &device xRef;
    string strVar;

    // draw CRYSTAL
    unsigned int crystal_y = 1;
    unsigned int crystal_x[] = {136};
    
    foreach dx (crystal_x) {
        d_tx = dx / NUM_GRID_X;  // tile x-coordinate
        d_tx_l = dx % NUM_GRID_X;
        dy = crystal_y;
        xRef = <device CRYSTAL @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "CRYSTAL_%d_%d", lsx + dx, lsy + dy);
        device CRYSTAL (symbol logsym) *strVar @[gsx + 360 + 100 * d_tx_l + TILE_NUM_GUI_GRID_X * d_tx, gsy + 400];
        map
        (
            <instance *strVar> => xRef
        );
    }
    
    // draw RESCAL
    unsigned int rescal_y = 1;
    unsigned int rescal_x[] = {135};
    
    foreach dx (rescal_x) {
        d_tx = dx / NUM_GRID_X;  // tile x-coordinate
        d_tx_l = dx % NUM_GRID_X;
        dy = rescal_y;
        xRef = <device RESCAL @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "RESCAL_%d_%d", lsx + dx, lsy + dy);
        device RESCAL (symbol logsym) *strVar @[gsx + 360 + 100 * d_tx_l + TILE_NUM_GUI_GRID_X * d_tx, gsy + 400];
        map
        (
            <instance *strVar> => xRef
        );
    }
    
    
    // draw BKCL
    unsigned int bkcl_y = 1;
    unsigned int bkcl_x[] = {137};
    
    foreach dx (bkcl_x) {
        d_tx = dx / NUM_GRID_X;  // tile x-coordinate
        d_tx_l = dx % NUM_GRID_X;
        dy = bkcl_y;
        xRef = <device BKCL @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "BKCL_%d_%d", lsx + dx, lsy + dy);
        device BKCL (symbol logsym) *strVar @[gsx + 360 + 100 * d_tx_l + TILE_NUM_GUI_GRID_X * d_tx, gsy + 400];
        map
        (
            <instance *strVar> => xRef
        );
    }

    // draw IOBS
    unsigned int iobs_y = 0;
    unsigned int iobs_x[] = {205, 213, 217, 13, 17, 29, 37, 41, 185, 189};

    foreach dx (iobs_x) {
        d_tx = dx / NUM_GRID_X;  // tile x-coordinate
        d_tx_l = dx % NUM_GRID_X;
        dy = iobs_y;
        xRef = <device IOBS @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "IOBS_%d_%d", lsx + dx, lsy + dy);
        device IOBS (symbol logsym_u) *strVar @[gsx + 360 + 300 * d_tx_l + TILE_NUM_GUI_GRID_X * d_tx, gsy + 700];
        map
        (
            <instance *strVar> => xRef
        );
    }

    // draw IOBR
    unsigned int iobr_y = 0;
    unsigned int iobr_x[] = {193, 9};

    foreach dx (iobr_x) {
        d_tx = dx / NUM_GRID_X;  // tile x-coordinate
        d_tx_l = dx % NUM_GRID_X;
        dy = iobr_y;
        xRef = <device IOBR @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "IOBR_%d_%d", lsx + dx, lsy + dy);
        device IOBR (symbol logsym) *strVar @[gsx + 360 + 300 * d_tx_l + TILE_NUM_GUI_GRID_X * d_tx, gsy + 700];
        map
        (
            <instance *strVar> => xRef
        );
    }

    // draw IOBD
    unsigned int iobd_y = 0;
    unsigned int iobd_x[] = {8, 192, 12, 16, 28, 36, 40, 184, 188, 204, 212, 216};

    foreach dx (iobd_x) {
        d_tx = dx / NUM_GRID_X;  // tile x-coordinate
        d_tx_l = dx % NUM_GRID_X;
        dy = iobd_y;
        xRef = <device IOBD @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "IOBD_%d_%d", lsx + dx, lsy + dy);
        device IOBD (symbol logsym) *strVar @[gsx + 360 + 300 * d_tx_l + TILE_NUM_GUI_GRID_X * d_tx, gsy + 700];
        map
        (
            <instance *strVar> => xRef
        );
    }
}

function draw_iob_tile_d(unsigned int tx, ty)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;

    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;

    unsigned int temp_ty;
    for(temp_ty = ty; temp_ty > MID_TILE_REGION; temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }

    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;

    unsigned int dx, dy;
    unsigned int d_tx, d_tx_l;

    // device reference variables
    &device xRef;
    string strVar;

    // draw CRYSTAL
    unsigned int crystal_y = 1;
    unsigned int crystal_x[] = {134};

    foreach dx (crystal_x) {
        d_tx = dx / NUM_GRID_X;  // tile x-coordinate
        d_tx_l = dx % NUM_GRID_X;
        dy = crystal_y;
        xRef = <device CRYSTAL @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "CRYSTAL_%d_%d", lsx + dx, lsy + dy);
        device CRYSTAL (symbol logsym) *strVar @[gsx + 360 + 100 * d_tx_l + TILE_NUM_GUI_GRID_X * d_tx, gsy + 400];
        map
        (
            <instance *strVar> => xRef
        );
    }

    // draw RESCAL
    unsigned int rescal_y = 1;
    unsigned int rescal_x[] = {132};

    foreach dx (rescal_x) {
        d_tx = dx / NUM_GRID_X;  // tile x-coordinate
        d_tx_l = dx % NUM_GRID_X;
        dy = rescal_y;
        xRef = <device RESCAL @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "RESCAL_%d_%d", lsx + dx, lsy + dy);
        device RESCAL (symbol logsym) *strVar @[gsx + 360 + 100 * d_tx_l + TILE_NUM_GUI_GRID_X * d_tx, gsy + 400];
        map
        (
            <instance *strVar> => xRef
        );
    }


    // draw BKCL
    unsigned int bkcl_y = 1;
    unsigned int bkcl_x[] = {130};

    foreach dx (bkcl_x) {
        d_tx = dx / NUM_GRID_X;  // tile x-coordinate
        d_tx_l = dx % NUM_GRID_X;
        dy = bkcl_y;
        xRef = <device BKCL @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "BKCL_%d_%d", lsx + dx, lsy + dy);
        device BKCL (symbol logsym) *strVar @[gsx + 360 + 100 * d_tx_l + TILE_NUM_GUI_GRID_X * d_tx, gsy + 400];
        map
        (
            <instance *strVar> => xRef
        );
    }

    // draw IOBS
    unsigned int iobs_y = 0;
    unsigned int iobs_x[] = {184, 188, 196, 204, 208, 212, 216, 220, 224, 120, 124, 136, 140, 144, 152, 156, 168, 172,
        116, 72, 80, 84, 88, 100, 104, 0, 4, 8, 12, 16, 20, 28, 36, 40, 52, 56, 60};

    foreach dx (iobs_x) {
        d_tx = dx / NUM_GRID_X;  // tile x-coordinate
        d_tx_l = dx % NUM_GRID_X;
        dy = iobs_y;
        xRef = <device IOBS @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "IOBS_%d_%d", lsx + dx, lsy + dy);
        device IOBS (symbol logsym_u) *strVar @[gsx + 360 + 300 * d_tx_l + TILE_NUM_GUI_GRID_X * d_tx, gsy + 700];
        map
        (
            <instance *strVar> => xRef
        );
    }

    // special (0, 2)
    //xRef = <device IOBS @[lsx + 0, lsy + 2] of ARCHITECTURE>;
    //sprintf(strVar, "IOBS_%d_%d", lsx + 0, lsy + 2);
    //device IOBS (symbol logsym_d) *strVar @[gsx + 360 , gsy + 700 + 2 * 300 ];
    //map
    //(
    //    <instance *strVar> => xRef
    //);

    // draw IOBR
    unsigned int iobr_y = 0;
    unsigned int iobr_x[] = {176, 68, 112};

    foreach dx (iobr_x) {
        d_tx = dx / NUM_GRID_X;  // tile x-coordinate
        d_tx_l = dx % NUM_GRID_X;
        dy = iobr_y;
        xRef = <device IOBR @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "IOBR_%d_%d", lsx + dx, lsy + dy);
        device IOBR (symbol logsym) *strVar @[gsx + 360 + 300 * d_tx_l + TILE_NUM_GUI_GRID_X * d_tx, gsy + 700];
        map
        (
            <instance *strVar> => xRef
        );
    }

    // draw IOBD
    unsigned int iobd_y = 0;
    unsigned int iobd_x[] = {185, 189, 197, 205, 209, 213, 217, 221, 225, 177, 121, 125, 137, 141, 145, 153, 157, 169, 173, 117, 113,
        73, 81, 85, 89, 101, 105, 69, 1, 5, 9, 13, 17, 21, 29, 37, 41, 53, 57, 61};

    foreach dx (iobd_x) {
        d_tx = dx / NUM_GRID_X;  // tile x-coordinate
        d_tx_l = dx % NUM_GRID_X;
        dy = iobd_y;
        xRef = <device IOBD @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "IOBD_%d_%d", lsx + dx, lsy + dy);
        device IOBD (symbol logsym) *strVar @[gsx + 360 + 300 * d_tx_l + TILE_NUM_GUI_GRID_X * d_tx, gsy + 700];
        map
        (
            <instance *strVar> => xRef
        );
    }
}

function draw_iob_tile_r(unsigned int tx, ty)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;

    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;

    unsigned int temp_ty;
    for(temp_ty = ty; temp_ty > MID_TILE_REGION; temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }

    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;

    unsigned int dx, dy;
    unsigned int d_ty, d_ty_l;

    // device reference variables
    &device xRef;
    string strVar;

    // draw CRYSTAL
    unsigned int crystal_x = 1;
    unsigned int crystal_y[] = {142};

    foreach dy (crystal_y) {
        d_ty = dy / NUM_GRID_Y;  // tile y-coordinate
        d_ty_l = dy % NUM_GRID_Y;
        dx = crystal_x;
        xRef = <device CRYSTAL @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "CRYSTAL_%d_%d", lsx + dx, lsy + dy);
        device CRYSTAL (symbol logsym) *strVar @[gsx + 900, gsy + 360 + 100 * d_ty_l + TILE_NUM_GUI_GRID_Y * d_ty];
        map
        (
            <instance *strVar> => xRef
        );
    }

    // draw RESCAL
    unsigned int rescal_x = 1;
    unsigned int rescal_y[] = {141};

    foreach dy (rescal_y) {
        d_ty = dy / NUM_GRID_Y;  // tile y-coordinate
        d_ty_l = dy % NUM_GRID_Y;
        dx = rescal_x;
        xRef = <device RESCAL @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "RESCAL_%d_%d", lsx + dx, lsy + dy);
        device RESCAL (symbol logsym) *strVar @[gsx + 900, gsy + 360 + 100 * d_ty_l + TILE_NUM_GUI_GRID_Y * d_ty];
        map
        (
            <instance *strVar> => xRef
        );
    }


    // draw BKCL
    unsigned int bkcl_x = 1;
    unsigned int bkcl_y[] = {140};

    foreach dy (bkcl_y) {
        d_ty = dy / NUM_GRID_Y;  // tile y-coordinate
        d_ty_l = dy % NUM_GRID_Y;
        dx = bkcl_x;
        xRef = <device BKCL @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "BKCL_%d_%d", lsx + dx, lsy + dy);
        device BKCL (symbol logsym) *strVar @[gsx + 900, gsy + 360 + 100 * d_ty_l + TILE_NUM_GUI_GRID_Y * d_ty];
        map
        (
            <instance *strVar> => xRef
        );
    }

    // draw IOBS
    unsigned int iobs_x = 0;
    unsigned int iobs_y[] = {129, 133, 137, 141, 145, 157, 161, 165, 169, 173, 5, 9, 13, 17, 21, 33, 37, 41, 45, 49, 73, 77, 81, 85, 89,
        101, 105, 109, 113, 117, 197, 201, 205, 209, 213, 225, 229, 233, 237, 241, 4, 8, 12, 16, 20, 32, 40, 44, 48, 72, 76, 80, 84, 88, 100,
        104, 108, 112, 116, 196, 200, 204, 208, 212, 224, 228, 232, 236, 128, 132, 136, 140, 144, 156, 160, 164, 168, 172};

    foreach dy (iobs_y) {
        d_ty = dy / NUM_GRID_Y;  // tile y-coordinate
        d_ty_l = dy % NUM_GRID_Y;
        dx = iobs_x;
        xRef = <device IOBS @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "IOBS_%d_%d", lsx + dx, lsy + dy);
        if (d_ty_l % 2)
        {
            device IOBS (symbol logsym_u) *strVar @[gsx + 600, gsy + 260 + 350 * d_ty_l + TILE_NUM_GUI_GRID_Y * d_ty];
            map
            (
                <instance *strVar> => xRef
            );
        }
        else
        {
            device IOBS (symbol logsym_d) *strVar @[gsx + 600, gsy + 260 + 200 * d_ty_l + TILE_NUM_GUI_GRID_Y * d_ty];
            map
            (
                <instance *strVar> => xRef
            );
        }
    }

    // draw IOBR
    unsigned int iobr_x = 0;
    unsigned int iobr_y[] = {36, 240};

    foreach dy (iobr_y) {
        d_ty = dy / NUM_GRID_Y;  // tile y-coordinate
        d_ty_l = dy % NUM_GRID_Y;
        dx = iobr_x;
        xRef = <device IOBR @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "IOBR_%d_%d", lsx + dx, lsy + dy);
        device IOBR (symbol logsym) *strVar @[gsx + 600, gsy + 360 + 200 * d_ty_l + TILE_NUM_GUI_GRID_Y * d_ty];
        map
        (
            <instance *strVar> => xRef
        );
    }
}

function draw_iob_tile_l(unsigned int tx, ty)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;

    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;

    unsigned int temp_ty;
    for(temp_ty = ty; temp_ty > MID_TILE_REGION; temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }

    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;

    unsigned int dx, dy;
    unsigned int d_ty, d_ty_l;

    // device reference variables
    &device xRef;
    string strVar;

    // draw CRYSTAL
    unsigned int crystal_x = 1;
    unsigned int crystal_y[] = {142};

    foreach dy (crystal_y) {
        d_ty = dy / NUM_GRID_Y;  // tile y-coordinate
        d_ty_l = dy % NUM_GRID_Y;
        dx = crystal_x;
        xRef = <device CRYSTAL @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "CRYSTAL_%d_%d", lsx + dx, lsy + dy);
        device CRYSTAL (symbol logsym) *strVar @[gsx + 900, gsy + 360 + 100 * d_ty_l + TILE_NUM_GUI_GRID_Y * d_ty];
        map
        (
            <instance *strVar> => xRef
        );
    }

    // draw RESCAL
    unsigned int rescal_x = 1;
    unsigned int rescal_y[] = {141};

    foreach dy (rescal_y) {
        d_ty = dy / NUM_GRID_Y;  // tile y-coordinate
        d_ty_l = dy % NUM_GRID_Y;
        dx = rescal_x;
        xRef = <device RESCAL @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "RESCAL_%d_%d", lsx + dx, lsy + dy);
        device RESCAL (symbol logsym) *strVar @[gsx + 900, gsy + 360 + 100 * d_ty_l + TILE_NUM_GUI_GRID_Y * d_ty];
        map
        (
            <instance *strVar> => xRef
        );
    }


    // draw BKCL
    unsigned int bkcl_x = 1;
    unsigned int bkcl_y[] = {140};

    foreach dy (bkcl_y) {
        d_ty = dy / NUM_GRID_Y;  // tile y-coordinate
        d_ty_l = dy % NUM_GRID_Y;
        dx = bkcl_x;
        xRef = <device BKCL @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "BKCL_%d_%d", lsx + dx, lsy + dy);
        device BKCL (symbol logsym) *strVar @[gsx + 900, gsy + 360 + 100 * d_ty_l + TILE_NUM_GUI_GRID_Y * d_ty];
        map
        (
            <instance *strVar> => xRef
        );
    }

    // draw IOBS
    unsigned int iobs_x = 0;
    unsigned int iobs_y[] = {40, 44, 48, 72, 76, 80, 84, 88, 100, 104, 108, 112, 116, 240, 4, 128, 132, 136, 140, 144, 156, 160, 164, 168, 
        172, 36, 8, 12, 16, 20, 32, 196, 200, 204, 208, 212, 224, 228, 232, 236, 41, 45, 49, 73, 77, 81, 85, 89, 101, 105, 109, 113, 117, 129,
        133, 137, 141, 145, 157, 161, 165, 169, 173, 197, 201, 205, 209, 213, 225, 229, 233, 237, 9, 13, 17, 21, 33};

    foreach dy (iobs_y) {
        d_ty = dy / NUM_GRID_Y;  // tile y-coordinate
        d_ty_l = dy % NUM_GRID_Y;
        dx = iobs_x;
        xRef = <device IOBS @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "IOBS_%d_%d", lsx + dx, lsy + dy);
        if (d_ty_l % 2)
        {
            device IOBS (symbol logsym_u) *strVar @[gsx + 600, gsy + 260 + 350 * d_ty_l + TILE_NUM_GUI_GRID_Y * d_ty];
            map
            (
                <instance *strVar> => xRef
            );
        }
        else
        {
            device IOBS (symbol logsym_d) *strVar @[gsx + 600, gsy + 260 + 200 * d_ty_l + TILE_NUM_GUI_GRID_Y * d_ty];
            map
            (
                <instance *strVar> => xRef
            );
        }
    }

    // draw IOBR
    unsigned int iobr_x = 0;
    unsigned int iobr_y[] = {5, 37, 241};

    foreach dy (iobr_y) {
        d_ty = dy / NUM_GRID_Y;  // tile y-coordinate
        d_ty_l = dy % NUM_GRID_Y;
        dx = iobr_x;
        xRef = <device IOBR @[lsx + dx, lsy + dy] of ARCHITECTURE>;
        sprintf(strVar, "IOBR_%d_%d", lsx + dx, lsy + dy);
        device IOBR (symbol logsym) *strVar @[gsx + 600, gsy + 360 + 200 * d_ty_l + TILE_NUM_GUI_GRID_Y * d_ty];
        map
        (
            <instance *strVar> => xRef
        );
    }
}

function draw_wlsr_tile(unsigned int tx, ty)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;

    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;

    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }

    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;

    // device reference variables
    &device xRef, rRef;
    string strVar, strVar1;

    xRef = <device CKEB @[lsx+1,lsy+1]  of ARCHITECTURE>;
    sprintf(strVar, "CKEB_%d_%d", lsx+1, lsy+1);
    device CKEB  ( symbol logsym )  *strVar  @[gsx+1000,gsy+920];
    map
    (
         <instance *strVar>   => xRef
    );

    rRef = <device CKEBMUX @[lsx+1,lsy+2]  of ARCHITECTURE>;
    sprintf(strVar1, "CKEBMUX_%d_%d", lsx+1, lsy+2);
    device CKEBMUX  ( symbol logsym )  *strVar1  @[gsx+600,gsy+900];
    map
    (
         <instance *strVar1>   => rRef
    );
}   // end of function draw_wlsr_tile

function draw_wlsr1_tile(unsigned int tx, ty)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;

    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;

    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }

    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;

    // device reference variables
    &device xRef, rRef;
    string strVar, strVar1;

    xRef = <device CKEB @[lsx+1,lsy+1]  of ARCHITECTURE>;
    sprintf(strVar, "CKEB_%d_%d", lsx+1, lsy+1);
    device CKEB  ( symbol logsym )  *strVar  @[gsx+1000,gsy+920];
    map
    (
         <instance *strVar>   => xRef
    );

    rRef = <device CKEBMUX @[lsx+1,lsy+2]  of ARCHITECTURE>;
    sprintf(strVar1, "CKEBMUX_%d_%d", lsx+1, lsy+2);
    device CKEBMUX  ( symbol logsym )  *strVar1  @[gsx+600,gsy+900];
    map
    (
         <instance *strVar1>   => rRef
    );
}   // end of function draw_wlsr_tile

function draw_wlsr2_tile(unsigned int tx, ty)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;

    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;

    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }

    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;

    // device reference variables
    &device xRef, rRef;
    string strVar, strVar1;

    xRef = <device CKEB @[lsx+1,lsy+1]  of ARCHITECTURE>;
    sprintf(strVar, "CKEB_%d_%d", lsx+1, lsy+1);
    device CKEB  ( symbol logsym )  *strVar  @[gsx+1000,gsy+920];
    map
    (
         <instance *strVar>   => xRef
    );

    rRef = <device CKEBMUX @[lsx+1,lsy+2]  of ARCHITECTURE>;
    sprintf(strVar1, "CKEBMUX_%d_%d", lsx+1, lsy+2);
    device CKEBMUX  ( symbol logsym )  *strVar1  @[gsx+600,gsy+900];
    map
    (
         <instance *strVar1>   => rRef
    );
}   // end of function draw_wlsr_tile

function draw_wlsra_tile(unsigned int tx, ty)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;

    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;

    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }

    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;

    // device reference variables
    &device xRef, rRef;
    string strVar, strVar1;

    xRef = <device CKEB @[lsx+1,lsy+1]  of ARCHITECTURE>;
    sprintf(strVar, "CKEB_%d_%d", lsx+1, lsy+1);
    device CKEB  ( symbol logsym )  *strVar  @[gsx+1000,gsy+920];
    map
    (
         <instance *strVar>   => xRef
    );

    rRef = <device CKEBMUX @[lsx+1,lsy+2]  of ARCHITECTURE>;
    sprintf(strVar1, "CKEBMUX_%d_%d", lsx+1, lsy+2);
    device CKEBMUX  ( symbol logsym )  *strVar1  @[gsx+600,gsy+900];
    map
    (
         <instance *strVar1>   => rRef
    );
}   // end of function draw_wlsra_tile

function draw_wlsrd_tile(unsigned int tx, ty)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;

    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;

    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }

    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;

    // device reference variables
    &device xRef, rRef;
    string strVar, strVar1;

    xRef = <device CKEB @[lsx+1,lsy+1]  of ARCHITECTURE>;
    sprintf(strVar, "CKEB_%d_%d", lsx+1, lsy+1);
    device CKEB  ( symbol logsym )  *strVar  @[gsx+1000,gsy+920];
    map
    (
         <instance *strVar>   => xRef
    );

    rRef = <device CKEBMUX @[lsx+1,lsy+2]  of ARCHITECTURE>;
    sprintf(strVar1, "CKEBMUX_%d_%d", lsx+1, lsy+2);
    device CKEBMUX  ( symbol logsym )  *strVar1  @[gsx+600,gsy+900];
    map 
    ( 
         <instance *strVar1>   => rRef
     );
}   // end of function draw_wlsrd_tile

function draw_rckb_tile(unsigned int tx,ty)
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X + 2;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef;
    string strVar;
    
    unsigned int dt, dx, dy;
    
    for ( dt = 0; dt < 2; dt += 1 )
    {
        // Part1.1
        dx = 0;
        dy = dt;
        xRef = <device RCKBMUX  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "RCKBMUX_%d_%d", lsx+dx, lsy+dy);
        device RCKBMUX  ( symbol sym )  *strVar  @[gsx+800,gsy+280+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        dy = 10 + dt;
        xRef = <device RCKBMUX_TEST  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "RCKBMUX_TEST_%d_%d", lsx+dx, lsy+dy);
        device RCKBMUX_TEST  ( symbol sym )  *strVar  @[gsx+800,gsy+400+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        dx = 1;
        dy = 11 - 3*dt;
        xRef = <device RCKBMUX_OUT  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "RCKBMUX_OUT_%d_%d", lsx+dx, lsy+dy);
        device RCKBMUX_OUT  ( symbol sym )  *strVar  @[gsx+850,gsy+340+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        // Part1.2
        dx = 0;
        dy = dt;
        xRef = <device VCKBMUX  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "VCKBMUX_%d_%d", lsx+dx, lsy+dy);
        device VCKBMUX  ( symbol sym )  *strVar  @[gsx+800,gsy+580+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        dx = 1;
        dy = dt;
        xRef = <device VCKBMUX_TEST  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "VCKBMUX_TEST_%d_%d", lsx+dx, lsy+dy);
        device VCKBMUX_TEST  ( symbol sym )  *strVar  @[gsx+800,gsy+700+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        dx = dt;
        dy = 9*dt;
        xRef = <device VCKBMUX_OUT  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "VCKBMUX_OUT_%d_%d", lsx+dx, lsy+dy);
        device VCKBMUX_OUT  ( symbol sym )  *strVar  @[gsx+850,gsy+640+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        // Part1.3
        dx = 1;
        
        dy = 6 + dt;
        xRef = <device RCKB  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "RCKB_%d_%d", lsx+dx, lsy+dy);
        device RCKB  ( symbol sym )  *strVar  @[gsx+900,gsy+360+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        dy = 4 + dt;
        xRef = <device RCKB  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "RCKB_%d_%d", lsx+dx, lsy+dy);
        device RCKB  ( symbol sym )  *strVar  @[gsx+900,gsy+660+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
    }
    
    gsy = gsy + 1200;    
    
    dx = 0;
    dy = 0;
    xRef = <device CKEB  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
    sprintf(strVar, "CKEB_%d_%d", lsx+dx, lsy+dy);
    device CKEB  ( symbol logsym )  *strVar  @[gsx+1000,gsy+920];
    map 
    (
         <instance *strVar>   => xRef
    );
    
    xRef = <device CKEBMUX @[lsx+0,lsy+0]  of ARCHITECTURE>;
    sprintf(strVar, "CKEBMUX_%d_%d", lsx+0, lsy+0);
    device CKEBMUX  ( symbol logsym )  *strVar  @[gsx+600,gsy+900];
    map 
    ( 
         <instance *strVar>   => xRef
     );
}  // end of function draw_rckb_tile

function draw_clkmux_tile(unsigned int tx,ty)
{
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X + 2;
    lsy = ty * NUM_GRID_Y;

    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;

    // device reference variables
    &device xRef;
    string strVar;

    xRef = <device PREGMUX @[lsx,lsy]  of ARCHITECTURE>;
    sprintf(strVar, "PREGMUX_%d_%d", lsx, lsy+5);
    device PREGMUX  ( symbol logsym )  *strVar  @[gsx+1100,gsy+220];
    map
    (
         <instance *strVar>   => xRef
    );

    xRef = <device PREGMUX_TEST @[lsx,lsy+2]  of ARCHITECTURE>;
    sprintf(strVar, "PREGMUX_TEST_%d_%d", lsx, lsy+4);
    device PREGMUX_TEST  ( symbol logsym )  *strVar  @[gsx+900,gsy+220];
    map
    (
         <instance *strVar>   => xRef
    );

    xRef = <device PREGMUX_OUT @[lsx,lsy+3]  of ARCHITECTURE>;
    sprintf(strVar, "PREGMUX_OUT_%d_%d", lsx, lsy+3);
    device PREGMUX_OUT  ( symbol logsym )  *strVar  @[gsx+700,gsy+420];
    map
    (
         <instance *strVar>   => xRef
    );

    xRef = <device G2RCKMUX @[lsx+1,lsy]  of ARCHITECTURE>;
    sprintf(strVar, "G2RCKMUX_%d_%d", lsx, lsy+2);
    device G2RCKMUX  ( symbol logsym )  *strVar  @[gsx+700,gsy+320];
    map
    (
         <instance *strVar>   => xRef
    );

    xRef = <device G2RCKMUX @[lsx+1,lsy+1]  of ARCHITECTURE>;
    sprintf(strVar, "G2RCKMUX_%d_%d", lsx, lsy+1);
    device G2RCKMUX  ( symbol logsym )  *strVar  @[gsx+700,gsy+220];
    map
    (
         <instance *strVar>   => xRef
    );
}

function draw_hsst_tile(unsigned int tx,ty)
{
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;

    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;

    // device reference variables
    &device xRef;
    string strVar;

    xRef = <device HSST @[lsx,lsy]  of ARCHITECTURE>;
    sprintf(strVar, "HSST_%d_%d", lsx, lsy);
    device HSST  ( symbol logsym )  *strVar  @[gsx,gsy+10];
    map
    (
         <instance *strVar>   => xRef
    );
}

};
