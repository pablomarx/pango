*******************************************************************

  Package   [pango_schm_funcs]

  Author    [jhxie]

  Abstract  [Schematic description common to pango architecture]

  Revision History:

********************************************************************************/
library work;
USE pgl_defs, pgl35es_defs, pango_defs;

package pgl_schm_funcs
{

function draw_srb_tile( unsigned int tx, ty )
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;

    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
      lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef, rRef;
    string strVar, strVar1;

    // Pull out the device instances from logic structure
    xRef = <device SRB @[lsx,lsy] of ARCHITECTURE>;
    sprintf(strVar, "SRB_%d_%d", lsx, lsy);
    device SRB ( symbol logsym ) *strVar @[gsx+201,gsy+200];
    map 
    (
        <instance *strVar> => xRef
    );
    
    // Pull out the device instances from logic structure
    rRef = <device HARD0N1 @[lsx,lsy+1] of ARCHITECTURE>;
    sprintf(strVar1, "HARD0N1_%d_%d", lsx, lsy+1);
    device HARD0N1 ( symbol logsym ) *strVar1 @[gsx+620,gsy+780];
    map
    (
        <instance *strVar1> => rRef
    );   
}   // end of function draw_srb_tile

function draw_srb_soc_tile( unsigned int tx, ty )
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;

    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
      lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef, rRef;
    string strVar, strVar1;

    // Pull out the device instances from logic structure
    xRef = <device SRB @[lsx,lsy] of ARCHITECTURE>;
    sprintf(strVar, "SRB_%d_%d", lsx, lsy);
    device SRB ( symbol logsym ) *strVar @[gsx+201,gsy+200];
    map 
    (
        <instance *strVar> => xRef
    );
    
    // Pull out the device instances from logic structure
    rRef = <device HARD0N1 @[lsx,lsy+1] of ARCHITECTURE>;
    sprintf(strVar1, "HARD0N1_%d_%d", lsx, lsy+1);
    device HARD0N1 ( symbol logsym ) *strVar1 @[gsx+620,gsy+780];
    map
    (
        <instance *strVar1> => rRef
    );   
}   // end of function draw_srb_soc_tile


function draw_clm_tile( unsigned int tx, ty, clm_flag )
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X + 2;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef, rRef;
    
    if(clm_flag == 1)
    {
       xRef = <device CLMA @[lsx,lsy]   of ARCHITECTURE>;
       rRef = <device CLMA @[lsx,lsy+1] of ARCHITECTURE>;
    
       // Instantiate the schematic. 
       device LOGIC_CLMA_TILE ( schematic logic_clma_tile_schm ) 
       instance map
       (
           <symbol CLMA @[740,280]> => xRef,
           <symbol CLMA @[870,540]> => rRef
       )
       @[gsx,gsy];
    }
    else
    {
       xRef = <device CLMA @[lsx,lsy]   of ARCHITECTURE>;
       rRef = <device CLMS @[lsx,lsy+1] of ARCHITECTURE>;
       
       // Instantiate the schematic. 
       device LOGIC_CLMS_TILE ( schematic logic_clms_tile_schm )
       instance map
       (
           <symbol CLMA @[740,280]> => xRef,
           <symbol CLMS @[870,540]> => rRef
       )
       @[gsx,gsy];
    }
}   // end of function draw_clm_tile


function draw_ccs_tile_pgl35es( unsigned int tx, ty )
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X + 2;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef;
    string strVar;
    
    gsx += 1200;
    
    gsx -= 2400;
    
    xRef = <device START @[lsx+14,lsy+14] of ARCHITECTURE>;
    sprintf(strVar, "START_%d_%d", lsx+14, lsy+14);
    device START ( symbol logsym ) *strVar @[gsx+3600+400,gsy+3600+200];
    map 
    ( 
        <instance *strVar> => xRef
    );
    
    xRef = <device IPAL @[lsx+14,lsy+15] of ARCHITECTURE>;
    sprintf(strVar, "IPAL_%d_%d", lsx+14, lsy+15);
    device IPAL ( symbol logsym ) *strVar @[gsx+3600+400,gsy+3600+600];
    map 
    ( 
        <instance *strVar> => xRef
    );
    
    unsigned int dt, dx, dy;
    dx = 14;
    for ( dt = 0; dt < 4; dt += 1 )
    {
        dy = 16 + dt;
        
        xRef = <device SCANCHAIN @[lsx+dx,lsy+dy] of ARCHITECTURE>;
        sprintf(strVar, "SCANCHAIN_%d_%d", lsx+dx, lsy+dy);
        device SCANCHAIN ( symbol logsym_0 ) *strVar @[gsx+3600+400,gsy+4800+80+280*dt];
        map 
        ( 
            <instance *strVar> => xRef
        );
    }
    
    xRef = <device MFG_TEST @[lsx+14,lsy+25] of ARCHITECTURE>;
    sprintf(strVar, "MFG_TEST_%d_%d", lsx+14, lsy+25);
    device MFG_TEST ( symbol logsym ) *strVar @[gsx+3600+400,gsy+7200+200];
    map 
    ( 
        <instance *strVar> => xRef
    );
    
    gsx -= 4800;    // (gsx + 2400) - 7200
    
    xRef = <device OSC @[lsx+34,lsy] of ARCHITECTURE>;
    sprintf(strVar, "OSC_%d_%d", lsx+34, lsy);
    device OSC ( symbol logsym ) *strVar @[gsx+9600+600,gsy+200];
    map 
    ( 
        <instance *strVar> => xRef
    );
}   // end of function draw_ccs_tile_pgl35es


//function draw_ccs_tile( unsigned int tx, ty )
//{
//    // Site index variable. The X index for logic and GUI are declared separately
//    unsigned int lsx, lsy, gsx, gsy;
//    
//    lsx = tx * NUM_GRID_X + 2;
//    lsy = ty * NUM_GRID_Y;
//    
//    unsigned int temp_ty;
//    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
//    {
//        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
//    }
//    
//    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
//    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
//    
//    // device reference variables
//    &device xRef;
//    string strVar;
//    
//    gsx += 1200;
//
//    xRef = <device LDOCLK @[lsx+6,lsy+1] of ARCHITECTURE>;
//    sprintf(strVar, "LDOCLK_%d_%d", lsx+6, lsy+1);
//    device LDOCLK ( symbol logsym ) *strVar @[gsx+1000,gsy+400];
//    map 
//    ( 
//        <instance *strVar> => xRef
//    );
//    
//    xRef = <device ADC @[lsx+2,lsy+28] of ARCHITECTURE>;
//    sprintf(strVar, "ADC_%d_%d", lsx+2, lsy+28);
//    device ADC ( symbol logsym ) *strVar @[gsx+1000,gsy+8400+400];
//    map 
//    ( 
//        <instance *strVar> => xRef
//    );
//    
//    gsx -= 2400;
//    
//    xRef = <device FUSECODE @[lsx+14,lsy+13] of ARCHITECTURE>;
//    sprintf(strVar, "FUSECODE_%d_%d", lsx+14, lsy+13);
//    device FUSECODE ( symbol logsym ) *strVar @[gsx+3600+800,gsy+3600+200];
//    map 
//    ( 
//        <instance *strVar> => xRef
//    );
//      
//    xRef = <device START @[lsx+14,lsy+14] of ARCHITECTURE>;
//    sprintf(strVar, "START_%d_%d", lsx+14, lsy+14);
//    device START ( symbol logsym ) *strVar @[gsx+3600+400,gsy+3600+200];
//    map 
//    ( 
//        <instance *strVar> => xRef
//    );
//     
//    xRef = <device IPAL @[lsx+14,lsy+15] of ARCHITECTURE>;
//    sprintf(strVar, "IPAL_%d_%d", lsx+14, lsy+15);
//    device IPAL ( symbol logsym ) *strVar @[gsx+3600+400,gsy+3600+600];
//    map 
//    ( 
//        <instance *strVar> => xRef
//    );
//    
//    unsigned int dt, dx, dy;
//    dx = 14;
//    for ( dt = 0; dt < 4; dt += 1 )
//    {
//        dy = 16 + dt;
//        
//        xRef = <device SCANCHAIN @[lsx+dx,lsy+dy] of ARCHITECTURE>;
//        sprintf(strVar, "SCANCHAIN_%d_%d", lsx+dx, lsy+dy);
//        device SCANCHAIN ( symbol logsym_0 ) *strVar @[gsx+3600+400,gsy+4800+80+280*dt];
//        map 
//        ( 
//            <instance *strVar> => xRef
//        );
//    }
//     
//    xRef = <device FLSIF @[lsx+14,lsy+20] of ARCHITECTURE>;
//    sprintf(strVar, "FLSIF_%d_%d", lsx+14, lsy+20);
//    device FLSIF ( symbol logsym ) *strVar @[gsx+3600+400,gsy+6000+200];
//    map 
//    ( 
//        <instance *strVar> => xRef
//    );
//    
//    xRef = <device UDID @[lsx+14,lsy+21] of ARCHITECTURE>;
//    sprintf(strVar, "UDID_%d_%d", lsx+14, lsy+21);
//    device UDID ( symbol logsym ) *strVar @[gsx+3600+400,gsy+6000+600];
//    map 
//    ( 
//        <instance *strVar> => xRef
//    );
//    
//    xRef = <device MFG_TEST @[lsx+14,lsy+25] of ARCHITECTURE>;
//    sprintf(strVar, "MFG_TEST_%d_%d", lsx+14, lsy+25);
//    device MFG_TEST ( symbol logsym ) *strVar @[gsx+3600+400,gsy+7200+200];
//    map 
//    ( 
//        <instance *strVar> => xRef
//    );
//    
//    gsx -= 4800;    // (gsx + 2400) - 7200
//    
//    xRef = <device OSC @[lsx+34,lsy] of ARCHITECTURE>;
//    sprintf(strVar, "OSC_%d_%d", lsx+34, lsy);
//    device OSC ( symbol logsym ) *strVar @[gsx+9600+600,gsy+200];
//    map 
//    ( 
//        <instance *strVar> => xRef
//    );
//}   // end of function draw_ccs_tile


//function draw_hmemc_tile( unsigned int tx, ty, flag )
//{
//    unsigned int lsx, lsy, gsx, gsy;
//    
//    lsx = (tx+1) * NUM_GRID_X + 2;
//    lsy = ty * NUM_GRID_Y;
//    
//    unsigned int temp_ty;
//    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
//    {
//        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
//    }
//    
//    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
//    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
//    
//    if(tx*2 < NUM_TILE_X)
//    {
//        gsx = gsx - 1200;
//    }
//    
//    unsigned int dy, d_ty;
//    
//    unsigned int hmemcmux_srb_dy1[] = { 4, 8, 12, 16, 20, 32, 36, 40, 44, 48 };
//    unsigned int hmemcmux_srb_dy2[] = { 68, 72, 76, 80, 84, 96, 100, 104, 108, 112, 124, 128, 132, 136, 140, 152, 156, 160, 164, 168 };
//    
//    if(flag==1)
//    {
//        foreach dy ( hmemcmux_srb_dy1 )
//        {
//            d_ty = dy / 4;
//            
//            &device xRef;
//            xRef = <device HMEMCMUX_SRB @[lsx+5,lsy+dy]  of ARCHITECTURE>;
//            string strVar;
//            sprintf(strVar, "HMEMCMUX_SRB%d_%d", lsx+5, lsy+dy);
//            device HMEMCMUX_SRB  ( symbol logsym )  *strVar  @[gsx+800,gsy+330+d_ty*1200];
//            map 
//            ( 
//                <instance *strVar>   => xRef
//            );   
//        }
//        foreach dy ( hmemcmux_srb_dy2 )
//        {
//            d_ty = dy / 4;
//            
//            &device xRef;
//            xRef = <device HMEMCMUX_SRB @[lsx+5,lsy+dy]  of ARCHITECTURE>;
//            string strVar;
//            sprintf(strVar, "HMEMCMUX_SRB%d_%d", lsx+5, lsy+dy);
//            device HMEMCMUX_SRB  ( symbol logsym )  *strVar  @[gsx+800,gsy+1530+d_ty*1200];
//            map 
//            ( 
//                <instance *strVar>   => xRef
//            );   
//        }
//        
//        &device xRef;
//        xRef = <device HMEMC@[lsx+2,lsy+1]  of ARCHITECTURE>;
//        string strVar;
//        sprintf(strVar, "HMEMC%d_%d", lsx+2, lsy+1);
//        device HMEMC  ( symbol logsym )  *strVar  @[gsx+1400,gsy+200];
//        map 
//        ( 
//           <instance *strVar>   => xRef
//        );
//    }
//    else if(flag==0)
//    {
//        foreach dy ( hmemcmux_srb_dy1 )
//        {
//            d_ty = dy / 4;
//            
//            &device xRef;
//            xRef = <device HMEMCMUX_SRB @[lsx+5,lsy+dy]  of ARCHITECTURE>;
//            string strVar;
//            sprintf(strVar, "HMEMCMUX_SRB%d_%d", lsx+5, lsy+dy);
//            device HMEMCMUX_SRB  ( symbol logsym )  *strVar  @[gsx+3000,gsy+330+d_ty*1200];
//            map 
//            ( 
//                <instance *strVar>   => xRef
//            );   
//        }
//        foreach dy ( hmemcmux_srb_dy2 )
//        {
//            d_ty = dy / 4;
//            
//            &device xRef;
//            xRef = <device HMEMCMUX_SRB @[lsx+5,lsy+dy]  of ARCHITECTURE>;
//            string strVar;
//            sprintf(strVar, "HMEMCMUX_SRB%d_%d", lsx+5, lsy+dy);
//            device HMEMCMUX_SRB  ( symbol logsym )  *strVar  @[gsx+3000,gsy+1530+d_ty*1200];
//            map 
//            ( 
//                <instance *strVar>   => xRef
//            );   
//        }
//        
//        &device xRef;
//        xRef = <device HMEMC@[lsx+2,lsy+1]  of ARCHITECTURE>;
//        string strVar;
//        sprintf(strVar, "HMEMC%d_%d", lsx+2, lsy+1);
//        device HMEMC  ( symbol logsym_e )  *strVar  @[gsx+1000,gsy+200];
//        map 
//        ( 
//           <instance *strVar>   => xRef
//        );
//    }
//    
//}// end of function draw_hmemc_tile


function draw_drm_tile( unsigned int tx, ty )
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X + 2;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef;
    string strVar;
    
    xRef = <device DRM @[lsx,lsy]  of ARCHITECTURE>;
    sprintf(strVar, "DRM_%d_%d", lsx, lsy);
    device DRM  ( symbol logsym_0 )  *strVar  @[gsx+800,gsy+200];
    map 
    ( 
        <instance *strVar> => xRef
     ); 
        
}// end of function draw_drm_tile


function draw_apm_tile( unsigned int tx, ty )
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X + 2;
    lsy = ty * NUM_GRID_Y;
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef, rRef;
    string strVar, strVar1;
    
    xRef = <device APM @[lsx,lsy] of ARCHITECTURE>;
    sprintf(strVar, "APM_%d_%d", lsx, lsy);
    device APM ( symbol logsym ) *strVar @[gsx+800,gsy+200];
    map 
    ( 
        <instance *strVar> => xRef
    );
    
    rRef = <device APMMUX @[lsx,lsy+4] of ARCHITECTURE>;
    sprintf(strVar1, "APMMUX_%d_%d", lsx, lsy+4);
    device APMMUX ( symbol logsym_w ) *strVar1 @[gsx+750,gsy+1670];
    map 
    ( 
        <instance *strVar1> => rRef
    );
}   // end of function draw_apm_tile

function draw_pll_tile( unsigned int tx, ty, pll_flag )
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X + 2;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
      lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef;
    string strVar;
    
    if (pll_flag == 1)
    {
        xRef = <device PLL @[lsx,lsy+7] of ARCHITECTURE>;
        sprintf(strVar, "PLL_%d_%d", lsx, lsy+7);
        device PLL ( symbol logsym_1 ) *strVar @[gsx+800,gsy+200];
        map 
        ( 
            <instance *strVar> => xRef
        );
        
        xRef = <device PLLMUX @[lsx,lsy+11] of ARCHITECTURE>;
        sprintf(strVar, "PLLMUX_%d_%d", lsx, lsy+11);
        device PLLMUX ( symbol logsym ) *strVar @[gsx+700,gsy+500-32];
        map 
        ( 
            <instance *strVar> => xRef
        );
    }
    else
    {
        xRef = <device PLL @[lsx,lsy+7] of ARCHITECTURE>;
        sprintf(strVar, "PLL_%d_%d", lsx, lsy+7);
        device PLL ( symbol logsym ) *strVar @[gsx+800,gsy+200];
        map 
        ( 
            <instance *strVar> => xRef
        );
        
        xRef = <device PLLMUX @[lsx,lsy+11] of ARCHITECTURE>;
        sprintf(strVar, "PLLMUX_%d_%d", lsx, lsy+11);
        device PLLMUX ( symbol logsym ) *strVar @[gsx+700,gsy+500-32+3600];
        map 
        ( 
            <instance *strVar> => xRef
        );
    }
    
    xRef = <device PREGMUX @[lsx,lsy+5] of ARCHITECTURE>;
    sprintf(strVar, "PREGMUX_%d_%d", lsx, lsy+5);
    device PREGMUX ( symbol logsym ) *strVar @[gsx+1100,gsy+2610];
    map 
    ( 
        <instance *strVar> => xRef
    );
    
    xRef = <device PREGMUX_TEST @[lsx,lsy+4] of ARCHITECTURE>;
    sprintf(strVar, "PREGMUX_TEST_%d_%d", lsx, lsy+4);
    device PREGMUX_TEST ( symbol logsym ) *strVar @[gsx+1100,gsy+1400];
    map 
    ( 
        <instance *strVar> => xRef
    );
    
    xRef = <device PREGMUX_OUT @[lsx,lsy+3] of ARCHITECTURE>;
    sprintf(strVar, "PREGMUX_OUT_%d_%d", lsx, lsy+3);
    device PREGMUX_OUT ( symbol logsym ) *strVar @[gsx+1250,gsy+2710];
    map 
    ( 
        <instance *strVar> => xRef
    );
     
    if(pll_flag == 1)
    {
        xRef = <device G2RCKMUX @[lsx,lsy+2] of ARCHITECTURE>;
        sprintf(strVar, "G2RCKMUX_%d_%d", lsx, lsy+2);
        device G2RCKMUX ( symbol logsym ) *strVar @[gsx+1100,gsy-200];
        map 
        ( 
            <instance *strVar> => xRef
        );
        
        xRef = <device G2RCKMUX @[lsx,lsy+1] of ARCHITECTURE>;
        sprintf(strVar, "G2RCKMUX_%d_%d", lsx, lsy+1);
        device G2RCKMUX ( symbol logsym ) *strVar @[gsx+1100,gsy-100];
        map 
        ( 
            <instance *strVar> => xRef
        );
    }
    else
    {
        xRef = <device G2RCKMUX @[lsx,lsy+2] of ARCHITECTURE>;
        sprintf(strVar, "G2RCKMUX_%d_%d", lsx, lsy+2);
        device G2RCKMUX ( symbol logsym ) *strVar @[gsx+1100,gsy+4900];
        map 
        ( 
            <instance *strVar> => xRef
        );
        
        xRef = <device G2RCKMUX @[lsx,lsy+1] of ARCHITECTURE>;
        sprintf(strVar, "G2RCKMUX_%d_%d", lsx, lsy+1);
        device G2RCKMUX ( symbol logsym ) *strVar @[gsx+1100,gsy+4800];
        map 
        ( 
            <instance *strVar> => xRef
        );
    }
}   // end of function draw_pll_tile


function draw_uscm_tile( unsigned int tx, ty )
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X + 2;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    if (ty == 31)
    {
        gsy = gsy - 3 * TILE_NUM_GUI_GRID_Y;
    }
    
    gsx = gsx + 1200;
    
    // device reference variables
    &device xRef;
    string strVar;
    
    unsigned int temp_num_x, temp_num_y;

    for(temp_num_y = 0;temp_num_y < 8;temp_num_y = temp_num_y + 1)
    {
        xRef = <device USCM @[lsx,lsy+temp_num_y]  of ARCHITECTURE>;
        sprintf(strVar, "USCM_%d_%d", lsx, lsy+temp_num_y);
        device USCM  ( symbol logsym )  *strVar  @[gsx-700,gsy+3700+lsy+temp_num_y*70];
        map 
        ( 
            <instance *strVar>   => xRef
        );  
        
        xRef = <device USCMMUX @[lsx,lsy+temp_num_y]  of ARCHITECTURE>;
        sprintf(strVar, "USCMMUX_%d_%d", lsx, lsy+temp_num_y);
        device USCMMUX  ( symbol logsym )  *strVar  @[gsx-1050,gsy+3700+lsy+temp_num_y*70];
        map 
        ( 
            <instance *strVar>   => xRef
        );
        
        xRef = <device USCMMUX_OUT @[lsx,lsy+temp_num_y]  of ARCHITECTURE>;
        sprintf(strVar, "USCMMUX_OUT_%d_%d", lsx, lsy+temp_num_y);
        device USCMMUX_OUT  ( symbol logsym )  *strVar  @[gsx-800,gsy+3700+lsy+temp_num_y*70];
        map 
        ( 
            <instance *strVar>   => xRef
        ); 
    }
    
    for(temp_num_y = 15;temp_num_y < 20;temp_num_y = temp_num_y + 1)
    {
        xRef = <device USCMMUX_TEST @[lsx,lsy+temp_num_y]  of ARCHITECTURE>;
        sprintf(strVar, "USCMMUX_TEST_%d_%d", lsx, lsy+temp_num_y);
        device USCMMUX_TEST  ( symbol logsym )  *strVar  @[gsx-900,gsy+2650+lsy+temp_num_y*70];
        map 
        ( 
            <instance *strVar>   => xRef
        );
    }
    
    for(temp_num_y = 0;temp_num_y < 3;temp_num_y = temp_num_y + 1)
    {
        xRef = <device USCMMUX_TEST @[lsx+1,lsy+temp_num_y]  of ARCHITECTURE>;
        sprintf(strVar, "USCMMUX_TEST_%d_%d", lsx+1, lsy+temp_num_y);
        device USCMMUX_TEST  ( symbol logsym )  *strVar  @[gsx-900,gsy+4050+lsy+temp_num_y*70];
        map 
        ( 
            <instance *strVar>   => xRef
        );
    }
    
    // 2nd part
    for(temp_num_y = 8;temp_num_y < 15;temp_num_y = temp_num_y + 1)
    {
        xRef = <device USCM @[lsx,lsy+temp_num_y]  of ARCHITECTURE>;
        sprintf(strVar, "USCM_%d_%d", lsx, lsy+temp_num_y);
        device USCM  ( symbol logsym )  *strVar  @[gsx-700,gsy+4900+lsy+(temp_num_y-8)*70];
        map 
        ( 
            <instance *strVar>   => xRef
        );  
        
        xRef = <device USCMMUX @[lsx,lsy+temp_num_y]  of ARCHITECTURE>;
        sprintf(strVar, "USCMMUX_%d_%d", lsx, lsy+temp_num_y);
        device USCMMUX  ( symbol logsym )  *strVar  @[gsx-1050,gsy+4900+lsy+(temp_num_y-8)*70];
        map 
        ( 
            <instance *strVar>   => xRef
        );
        
        xRef = <device USCMMUX_OUT @[lsx,lsy+temp_num_y]  of ARCHITECTURE>;
        sprintf(strVar, "USCMMUX_OUT_%d_%d", lsx, lsy+temp_num_y);
        device USCMMUX_OUT  ( symbol logsym )  *strVar  @[gsx-800,gsy+4900+lsy+(temp_num_y-8)*70];
        map 
        ( 
            <instance *strVar>   => xRef
        ); 
    }
    
    for(temp_num_y = 3;temp_num_y < 10;temp_num_y = temp_num_y + 1)
    {
        xRef = <device USCMMUX_TEST @[lsx+1,lsy+temp_num_y]  of ARCHITECTURE>;
        sprintf(strVar, "USCMMUX_TEST_%d_%d", lsx+1, lsy+temp_num_y);
        device USCMMUX_TEST  ( symbol logsym )  *strVar  @[gsx-900,gsy+5250+lsy+(temp_num_y-8)*70];
        map 
        ( 
            <instance *strVar>   => xRef
        );
    }
}// end of function draw_uscm_tile


function draw_iol_tile( unsigned int tx, ty )
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X + 2;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef, rRef, mRef, nRef;
    
    xRef = <device IOLMUX @[lsx,lsy+1]   of ARCHITECTURE>;
    rRef = <device IOLMUX @[lsx,lsy+2]   of ARCHITECTURE>;
    mRef = <device IOL    @[lsx+1,lsy+1] of ARCHITECTURE>;
    nRef = <device IOL    @[lsx+1,lsy+2] of ARCHITECTURE>;
    // Instantiate the schematic. 
    device LOGIC_IOL_TILE ( schematic logic_iol_tile_schm )
    instance map
    (
        <symbol IOLMUX  @[1100,425]> => xRef,
        <symbol IOLMUX  @[1100,585]> => rRef,
        <symbol IOL     @[960,280] > => mRef,
        <symbol IOL     @[960,540] > => nRef
    )
    @[gsx,gsy];
}   // end of function draw_iol_tile


//function draw_hmemciol_tile( unsigned int tx, ty )
//{   
//    unsigned int lsx, lsy, gsx, gsy;
//    
//    lsx = tx * NUM_GRID_X + 2;
//    lsy = ty * NUM_GRID_Y;
//    
//    unsigned int temp_ty;
//    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
//    {
//      lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
//    }
//    
//    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
//    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
//    
//     
//    &device xRef, mRef, s0Ref, nRef,fRef;
//    fRef   = <device HMEMCMUX_IOL @[lsx,lsy]         of ARCHITECTURE>;
//    xRef   = <device IOLMUX       @[lsx,lsy+1]       of ARCHITECTURE>;
//    nRef   = <device IOLMUX       @[lsx,lsy+2]       of ARCHITECTURE>;
//    mRef   = <device IOL          @[lsx+1,lsy+1]     of ARCHITECTURE>;
//    s0Ref  = <device IOL          @[lsx+1,lsy+2]     of ARCHITECTURE>;
//    // Instantiate the schematic. 
//    device LOGIC_HMEMCIOL_TILE ( schematic logic_hmemciol_tile_schm ) 
//        instance map
//        (
//                <symbol HMEMCMUX_IOL  @[420+410,310+100]>  => fRef,
//                <symbol IOLMUX        @[420+680,325+100]>  => xRef,
//                <symbol IOLMUX        @[420+680,485+100]>  => nRef,
//                <symbol IOL           @[420+540,180+100]>  => mRef,
//                <symbol IOL           @[420+540,440+100]>  => s0Ref
//        )
//        @[gsx,gsy];
//     
//        
//}// end of function draw_hmemcmux_tile(draw_hmemciol_tile)


function draw_dqsl_tile( unsigned int tx, ty, flag )
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X+2;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef;
    string strVar;
    
    if(flag==1)  //draw hmemcdqsl
    {
        xRef = <device DQSL @[lsx,lsy] of ARCHITECTURE>;
        sprintf(strVar, "DQSL_%d_%d", lsx, lsy);
        device DQSL ( symbol logsym ) *strVar @[gsx+800,gsy+280];
        map
        (
            <instance *strVar>   => xRef
        );
        
        xRef = <device HMEMCMUX_DQS @[lsx+1,lsy+1] of ARCHITECTURE>;
        sprintf(strVar, "HMEMCMUX_DQSL_%d_%d", lsx+1, lsy+1);
        device HMEMCMUX_DQS ( symbol logsym ) *strVar @[gsx+1300,gsy+380];
        map
        (
            <instance *strVar>   => xRef
        );
        
        xRef = <device DQSLMUX @[lsx,lsy+1] of ARCHITECTURE>;
        sprintf(strVar, "DQSLMUX_%d_%d", lsx, lsy+1);
        device DQSLMUX ( symbol logsym ) *strVar @[gsx+950,gsy+430];
        map
        (
            <instance *strVar>   => xRef
        );
    }
    else  //draw dqsl
    {
        xRef = <device DQSL @[lsx,lsy] of ARCHITECTURE>;
        sprintf(strVar, "DQSL_%d_%d", lsx, lsy);
        device DQSL ( symbol logsym ) *strVar @[gsx+800,gsy+280];
        map
        (
            <instance *strVar>   => xRef
        );
         
        xRef = <device DQSLMUX @[lsx,lsy+1] of ARCHITECTURE>;
        sprintf(strVar, "DQSLMUX_%d_%d", lsx, lsy+1);
        device DQSLMUX ( symbol logsym ) *strVar @[gsx+950,gsy+430];
        map
        (
            <instance *strVar>   => xRef
        );
    }
}   // end of function draw_dqsl_tile


function draw_iockgatedll_tile( unsigned int tx, ty )
{   
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X + 2;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
      lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    gsy = gsy + 1200;

  if(tx*2 < NUM_TILE_X)
  {
    gsx = gsx - 2200;
    gsy = gsy + 300;
           
    &device wRef;
    wRef = <device IOCKDLY @[lsx,lsy+4]  of ARCHITECTURE>;
    string strVar0;
    sprintf(strVar0, "IOCKDLY_%d_%d", lsx, lsy+4);
    device IOCKDLY  ( symbol logsym_w )  *strVar0  @[gsx+1100,gsy+330];
    map 
    ( 
         <instance *strVar0>   => wRef
     );
    

    wRef = <device IOCKDLYMUX @[lsx,lsy]  of ARCHITECTURE>;
    string strVar1;
    sprintf(strVar1, "IOCKDLYMUX_%d_%d", lsx, lsy);
    device IOCKDLYMUX  ( symbol logsym_w )  *strVar1  @[gsx+1200,gsy+300];
    map 
    ( 
         <instance *strVar1>   => wRef
     );
     
    wRef = <device IOCKDLY @[lsx,lsy+5]  of ARCHITECTURE>;
    string strVar2;
    sprintf(strVar2, "IOCKDLY_%d_%d", lsx, lsy+5);
    device IOCKDLY  ( symbol logsym_w )  *strVar2  @[gsx+1100,gsy+530];
    map 
    ( 
         <instance *strVar2>   => wRef
     );
    

    wRef = <device IOCKDLYMUX @[lsx,lsy+1]  of ARCHITECTURE>;
    string strVar3;
    sprintf(strVar3, "IOCKDLYMUX_%d_%d", lsx, lsy+1);
    device IOCKDLYMUX  ( symbol logsym_w )  *strVar3  @[gsx+1200,gsy+500];
    map 
    ( 
         <instance *strVar3>   => wRef
     );
     
    wRef = <device IOCKGMUX @[lsx,lsy+1]  of ARCHITECTURE>;
    string strVar4;
    sprintf(strVar4, "IOCKGMUX_%d_%d", lsx, lsy+1);
    device IOCKGMUX  ( symbol logsym_w )  *strVar4  @[gsx+1300,gsy+500];
    map 
    ( 
         <instance *strVar4>   => wRef
     );
     
    wRef = <device IOCKGMUX_OUT @[lsx,lsy+1]  of ARCHITECTURE>;
    string strVar5;
    sprintf(strVar5, "IOCKGMUX_OUT_%d_%d", lsx, lsy+1);
    device IOCKGMUX_OUT  ( symbol logsym )  *strVar5  @[gsx+1400,gsy+400];
    map 
    ( 
         <instance *strVar5>   => wRef
     );
     
    wRef = <device IOCKGMUX_TEST @[lsx,lsy+3]  of ARCHITECTURE>;
    string strVar6;
    sprintf(strVar6, "IOCKGMUX_TEST_%d_%d", lsx, lsy+3);
    device IOCKGMUX_TEST  ( symbol logsym )  *strVar6  @[gsx+1300,gsy+300];
    map 
    ( 
         <instance *strVar6>   => wRef
     ); 
     
    wRef = <device IOCKGATE @[lsx,lsy+1]  of ARCHITECTURE>;
    string strVar7;
    sprintf(strVar7, "IOCKGATE_%d_%d", lsx, lsy+1);
    device IOCKGATE  ( symbol logsym_w )  *strVar7  @[gsx+1500,gsy+420];
    map 
    ( 
         <instance *strVar7>   => wRef
     ); 
     
    wRef = <device IOCKDIV @[lsx,lsy+9]  of ARCHITECTURE>;
    string strVar8;
    sprintf(strVar8, "IOCKDIV_%d_%d", lsx, lsy+9);
    device IOCKDIV  ( symbol logsym_w )  *strVar8  @[gsx+1600,gsy+170];
    map 
    ( 
         <instance *strVar8>   => wRef
     ); 
     
    wRef = <device RCKBMUX @[lsx,lsy+1]  of ARCHITECTURE>;
    string strVar9;
    sprintf(strVar9, "RCKBMUX_%d_%d", lsx, lsy+1);
    device RCKBMUX ( symbol logsym )  *strVar9  @[gsx+1700,gsy+500];
    map 
    ( 
         <instance *strVar9>   => wRef
     );

    wRef = <device RCKBMUX_OUT @[lsx+1,lsy+8]  of ARCHITECTURE>;
    string strVar10;
    sprintf(strVar10, "RCKBMUX_OUT_%d_%d", lsx+1, lsy+8);
    device RCKBMUX_OUT ( symbol logsym )  *strVar10  @[gsx+1800,gsy+400];
    map 
    ( 
         <instance *strVar10>   => wRef
     );
     
    wRef = <device RCKBMUX_TEST @[lsx,lsy+11]  of ARCHITECTURE>;
    string strVar11;
    sprintf(strVar11, "RCKBMUX_TEST_%d_%d", lsx, lsy+11);
    device RCKBMUX_TEST ( symbol logsym )  *strVar11  @[gsx+1700,gsy+300];
    map 
    ( 
         <instance *strVar11>   => wRef
     );
     
    wRef = <device VCKBMUX @[lsx,lsy+1]  of ARCHITECTURE>;
    string strVar12;
    sprintf(strVar12, "VCKBMUX_%d_%d", lsx, lsy+1);
    device VCKBMUX ( symbol logsym )  *strVar12  @[gsx+1900,gsy+500];
    map 
    ( 
         <instance *strVar12>   => wRef
     );
     
    wRef = <device VCKBMUX_OUT @[lsx+1,lsy+9]  of ARCHITECTURE>;
    string strVar13;
    sprintf(strVar13, "VCKBMUX_OUT_%d_%d", lsx+1, lsy+9);
    device VCKBMUX_OUT ( symbol logsym )  *strVar13  @[gsx+2000,gsy+400];
    map 
    ( 
         <instance *strVar13>   => wRef
     );
     
    wRef = <device VCKBMUX_TEST @[lsx+1,lsy+1]  of ARCHITECTURE>;
    string strVar14;
    sprintf(strVar14, "VCKBMUX_TEST_%d_%d", lsx+1, lsy+1);
    device VCKBMUX_TEST ( symbol logsym )  *strVar14  @[gsx+1900,gsy+300];
    map 
    ( 
         <instance *strVar14>   => wRef
     );
     
    gsx = gsx - 1400;
    gsy = gsy - 600;
    
    wRef = <device IOCKDLY @[lsx,lsy+6]  of ARCHITECTURE>;
    string strVar15;
    sprintf(strVar15, "IOCKDLY_%d_%d", lsx, lsy+6);
    device IOCKDLY  ( symbol logsym_w )  *strVar15  @[gsx+2500,gsy+330];
    map 
    ( 
         <instance *strVar15>   => wRef
     );
    

    wRef = <device IOCKDLYMUX @[lsx,lsy+2]  of ARCHITECTURE>;
    string strVar16;
    sprintf(strVar16, "IOCKDLYMUX_%d_%d", lsx, lsy+2);
    device IOCKDLYMUX  ( symbol logsym_w )  *strVar16  @[gsx+2600,gsy+300];
    map 
    ( 
         <instance *strVar16>   => wRef
     );
     
    wRef = <device IOCKDLY @[lsx,lsy+7]  of ARCHITECTURE>;
    string strVar17;
    sprintf(strVar17, "IOCKDLY_%d_%d", lsx, lsy+7);
    device IOCKDLY  ( symbol logsym_w )  *strVar17  @[gsx+2500,gsy+530];
    map 
    ( 
         <instance *strVar17>   => wRef
     );
    

    wRef = <device IOCKDLYMUX @[lsx,lsy+3]  of ARCHITECTURE>;
    string strVar18;
    sprintf(strVar18, "IOCKDLYMUX_%d_%d", lsx, lsy+3);
    device IOCKDLYMUX  ( symbol logsym_w )  *strVar18  @[gsx+2600,gsy+500];
    map 
    ( 
         <instance *strVar18>   => wRef
     );
    
    wRef = <device IOCKGMUX @[lsx,lsy]  of ARCHITECTURE>;
    string strVar19;
    sprintf(strVar19, "IOCKGMUX_%d_%d", lsx, lsy);
    device IOCKGMUX  ( symbol logsym_w )  *strVar19  @[gsx+2700,gsy+500];
    map 
    ( 
         <instance *strVar19>   => wRef
     );
     
    wRef = <device IOCKGMUX_OUT @[lsx+1,lsy+10]  of ARCHITECTURE>;
    string strVar20;
    sprintf(strVar20, "IOCKGMUX_OUT_%d_%d", lsx+1, lsy+10);
    device IOCKGMUX_OUT  ( symbol logsym )  *strVar20  @[gsx+2800,gsy+400];
    map 
    ( 
         <instance *strVar20>   => wRef
     );
     
    wRef = <device IOCKGMUX_TEST @[lsx,lsy+2]  of ARCHITECTURE>;
    string strVar21;
    sprintf(strVar21, "IOCKGMUX_TEST_%d_%d", lsx, lsy+2);
    device IOCKGMUX_TEST  ( symbol logsym )  *strVar21  @[gsx+2700,gsy+300];
    map 
    ( 
         <instance *strVar21>   => wRef
     );
     
    wRef = <device IOCKGATE @[lsx,lsy]  of ARCHITECTURE>;
    string strVar22;
    sprintf(strVar22, "IOCKGATE_%d_%d", lsx, lsy);
    device IOCKGATE  ( symbol logsym_w )  *strVar22  @[gsx+2900,gsy+420];
    map 
    ( 
         <instance *strVar22>   => wRef
     ); 
     
    wRef = <device IOCKDIV @[lsx,lsy+8]  of ARCHITECTURE>;
    string strVar23;
    sprintf(strVar23, "IOCKDIV_%d_%d", lsx, lsy+8);
    device IOCKDIV  ( symbol logsym_w )  *strVar23  @[gsx+3000,gsy+670];
    map 
    ( 
         <instance *strVar23>   => wRef
     ); 
     
    wRef = <device RCKBMUX @[lsx,lsy]  of ARCHITECTURE>;
    string strVar24;
    sprintf(strVar24, "RCKBMUX_%d_%d", lsx, lsy);
    device RCKBMUX ( symbol logsym )  *strVar24  @[gsx+3100,gsy+500];
    map 
    ( 
         <instance *strVar24>   => wRef
     );

    wRef = <device RCKBMUX_OUT @[lsx+1,lsy+11]  of ARCHITECTURE>;
    string strVar25;
    sprintf(strVar25, "RCKBMUX_OUT_%d_%d", lsx+1, lsy+11);
    device RCKBMUX_OUT ( symbol logsym )  *strVar25  @[gsx+3200,gsy+400];
    map 
    ( 
         <instance *strVar25>   => wRef
     );
     
    wRef = <device RCKBMUX_TEST @[lsx,lsy+10]  of ARCHITECTURE>;
    string strVar26;
    sprintf(strVar26, "RCKBMUX_TEST_%d_%d", lsx, lsy+10);
    device RCKBMUX_TEST ( symbol logsym )  *strVar26  @[gsx+3100,gsy+300];
    map 
    ( 
         <instance *strVar26>   => wRef
     );
     
    wRef = <device VCKBMUX @[lsx,lsy]  of ARCHITECTURE>;
    string strVar27;
    sprintf(strVar27, "VCKBMUX_%d_%d", lsx, lsy);
    device VCKBMUX ( symbol logsym )  *strVar27  @[gsx+3300,gsy+500];
    map 
    ( 
         <instance *strVar27>   => wRef
     );
     
    wRef = <device VCKBMUX_OUT @[lsx,lsy]  of ARCHITECTURE>;
    string strVar28;
    sprintf(strVar28, "VCKBMUX_OUT_%d_%d", lsx, lsy);
    device VCKBMUX_OUT ( symbol logsym )  *strVar28  @[gsx+3400,gsy+400];
    map 
    ( 
         <instance *strVar28>   => wRef
     );
     
    wRef = <device VCKBMUX_TEST @[lsx+1,lsy]  of ARCHITECTURE>;
    string strVar29;
    sprintf(strVar29, "VCKBMUX_TEST_%d_%d", lsx+1, lsy);
    device VCKBMUX_TEST ( symbol logsym )  *strVar29  @[gsx+3300,gsy+300];
    map 
    ( 
         <instance *strVar29>   => wRef
     );
     
    gsx = gsx + 1400;
    gsy = gsy + 300;    
    
    &device xRef;     
    xRef  = <device DLLMUX  @[lsx,lsy]     of ARCHITECTURE>;
    string strVar30;
    sprintf(strVar30, "DLLMUX_%d_%d", lsx, lsy);
    device DLLMUX   ( symbol logsym_w )  *strVar30  @[gsx+4000,gsy+430];
    map 
    ( 
        <instance *strVar30>   => xRef
     );   
     
     
     // Pull out the device instances from logic structure  
    &device mRef;
    mRef  = <device DLL  @[lsx+1,lsy+3]     of ARCHITECTURE>;
    string strVar31;
    sprintf(strVar31, "DLL_%d_%d", lsx+1, lsy+3);
    device DLL   ( symbol logsym )  *strVar31  @[gsx+4100,gsy+320];
    map 
    ( 
        <instance *strVar31>   => mRef
     );
     
    &device sRef;
    sRef  = <device CKEB  @[lsx,lsy]     of ARCHITECTURE>;
    string strVar32;
    sprintf(strVar32, "CKEB_%d_%d", lsx, lsy);
    device CKEB   ( symbol logsym_n )  *strVar32  @[gsx+3200,gsy+920];
    map 
    ( 
        <instance *strVar32>   => sRef
     );    
    
    sRef = <device CKEBMUX @[lsx+0,lsy+0]  of ARCHITECTURE>;
    sprintf(strVar32, "CKEBMUX_%d_%d", lsx+0, lsy+0);
    device CKEBMUX  ( symbol logsym )  *strVar32  @[gsx+2800,gsy+900];
    map 
    ( 
         <instance *strVar32>   => sRef
     );
     
     
    // Pull out the device instances from logic structure    
    sRef  = <device RCKB  @[lsx+1,lsy+4]     of ARCHITECTURE>;
    string strVar33;
    sprintf(strVar33, "RCKB_%d_%d", lsx+1, lsy+4);
    device RCKB   ( symbol logsym )  *strVar33  @[gsx+3900,gsy+250];
    map 
    ( 
        <instance *strVar33>   => sRef
     );
     
    sRef  = <device RCKB  @[lsx+1,lsy+5]     of ARCHITECTURE>;
    string strVar34;
    sprintf(strVar34, "RCKB_%d_%d", lsx+1, lsy+5);
    device RCKB   ( symbol logsym )  *strVar34  @[gsx+3900,gsy+550];
    map 
    ( 
        <instance *strVar34>   => sRef
     );
     
    sRef  = <device RCKB  @[lsx+1,lsy+6]     of ARCHITECTURE>;
    string strVar35;
    sprintf(strVar35, "RCKB_%d_%d", lsx+1, lsy+6);
    device RCKB   ( symbol logsym )  *strVar35  @[gsx+3900,gsy+350];
    map 
    ( 
        <instance *strVar35>   => sRef
     );
     
    sRef  = <device RCKB  @[lsx+1,lsy+7]     of ARCHITECTURE>;
    string strVar36;
    sprintf(strVar36, "RCKB_%d_%d", lsx+1, lsy+7);
    device RCKB   ( symbol logsym )  *strVar36  @[gsx+3900,gsy+450];
    map 
    ( 
        <instance *strVar36>   => sRef
     );
  }
  else
  {
    gsx = gsx + 3400;
    gsy = gsy + 300;
    
    &device wRef;
    wRef = <device IOCKDLY @[lsx,lsy+4]  of ARCHITECTURE>;
    string strVar0;
    sprintf(strVar0, "IOCKDLY_%d_%d", lsx, lsy+4);
    device IOCKDLY  ( symbol logsym_e )  *strVar0  @[gsx-1100,gsy+330];
    map 
    ( 
         <instance *strVar0>   => wRef
     );
    

    wRef = <device IOCKDLYMUX @[lsx,lsy]  of ARCHITECTURE>;
    string strVar1;
    sprintf(strVar1, "IOCKDLYMUX_%d_%d", lsx, lsy);
    device IOCKDLYMUX  ( symbol logsym_e )  *strVar1  @[gsx-1200,gsy+300];
    map 
    ( 
         <instance *strVar1>   => wRef
     );
     
    wRef = <device IOCKDLY @[lsx,lsy+5]  of ARCHITECTURE>;
    string strVar2;
    sprintf(strVar2, "IOCKDLY_%d_%d", lsx, lsy+5);
    device IOCKDLY  ( symbol logsym_e )  *strVar2  @[gsx-1100,gsy+530];
    map 
    ( 
         <instance *strVar2>   => wRef
     );
    

    wRef = <device IOCKDLYMUX @[lsx,lsy+1]  of ARCHITECTURE>;
    string strVar3;
    sprintf(strVar3, "IOCKDLYMUX_%d_%d", lsx, lsy+1);
    device IOCKDLYMUX  ( symbol logsym_e )  *strVar3  @[gsx-1200,gsy+500];
    map 
    ( 
         <instance *strVar3>   => wRef
     );
     
    wRef = <device IOCKGMUX @[lsx,lsy+1]  of ARCHITECTURE>;
    string strVar4;
    sprintf(strVar4, "IOCKGMUX_%d_%d", lsx, lsy+1);
    device IOCKGMUX  ( symbol logsym_e )  *strVar4  @[gsx-1300,gsy+500];
    map 
    ( 
         <instance *strVar4>   => wRef
     );
     
    wRef = <device IOCKGMUX_OUT @[lsx,lsy+1]  of ARCHITECTURE>;
    string strVar5;
    sprintf(strVar5, "IOCKGMUX_OUT_%d_%d", lsx, lsy+1);
    device IOCKGMUX_OUT  ( symbol logsym_e )  *strVar5  @[gsx-1400,gsy+400];
    map 
    ( 
         <instance *strVar5>   => wRef
     );
     
    wRef = <device IOCKGMUX_TEST @[lsx,lsy+3]  of ARCHITECTURE>;
    string strVar6;
    sprintf(strVar6, "IOCKGMUX_TEST_%d_%d", lsx, lsy+3);
    device IOCKGMUX_TEST  ( symbol logsym_e )  *strVar6  @[gsx-1300,gsy+300];
    map 
    ( 
         <instance *strVar6>   => wRef
     ); 
     
    wRef = <device IOCKGATE @[lsx,lsy+1]  of ARCHITECTURE>;
    string strVar7;
    sprintf(strVar7, "IOCKGATE_%d_%d", lsx, lsy+1);
    device IOCKGATE  ( symbol logsym_e )  *strVar7  @[gsx-1500,gsy+420];
    map 
    ( 
         <instance *strVar7>   => wRef
     ); 
     
    wRef = <device IOCKDIV @[lsx,lsy+9]  of ARCHITECTURE>;
    string strVar8;
    sprintf(strVar8, "IOCKDIV_%d_%d", lsx, lsy+9);
    device IOCKDIV  ( symbol logsym_e )  *strVar8  @[gsx-1600,gsy+170];
    map 
    ( 
         <instance *strVar8>   => wRef
     ); 
     
    wRef = <device RCKBMUX @[lsx,lsy+1]  of ARCHITECTURE>;
    string strVar9;
    sprintf(strVar9, "RCKBMUX_%d_%d", lsx, lsy+1);
    device RCKBMUX ( symbol logsym_e )  *strVar9  @[gsx-1700,gsy+500];
    map 
    ( 
         <instance *strVar9>   => wRef
     );

    wRef = <device RCKBMUX_OUT @[lsx+1,lsy+8]  of ARCHITECTURE>;
    string strVar10;
    sprintf(strVar10, "RCKBMUX_OUT_%d_%d", lsx+1, lsy+8);
    device RCKBMUX_OUT ( symbol logsym_e )  *strVar10  @[gsx-1800,gsy+400];
    map 
    ( 
         <instance *strVar10>   => wRef
     );
     
    wRef = <device RCKBMUX_TEST @[lsx,lsy+11]  of ARCHITECTURE>;
    string strVar11;
    sprintf(strVar11, "RCKBMUX_TEST_%d_%d", lsx, lsy+11);
    device RCKBMUX_TEST ( symbol logsym_e )  *strVar11  @[gsx-1700,gsy+300];
    map 
    ( 
         <instance *strVar11>   => wRef
     );
     
    wRef = <device VCKBMUX @[lsx,lsy+1]  of ARCHITECTURE>;
    string strVar12;
    sprintf(strVar12, "VCKBMUX_%d_%d", lsx, lsy+1);
    device VCKBMUX ( symbol logsym_e )  *strVar12  @[gsx-1900,gsy+500];
    map 
    ( 
         <instance *strVar12>   => wRef
     );
     
    wRef = <device VCKBMUX_OUT @[lsx+1,lsy+9]  of ARCHITECTURE>;
    string strVar13;
    sprintf(strVar13, "VCKBMUX_OUT_%d_%d", lsx+1, lsy+9);
    device VCKBMUX_OUT ( symbol logsym_e )  *strVar13  @[gsx-2000,gsy+400];
    map 
    ( 
         <instance *strVar13>   => wRef
     );
     
    wRef = <device VCKBMUX_TEST @[lsx+1,lsy+1]  of ARCHITECTURE>;
    string strVar14;
    sprintf(strVar14, "VCKBMUX_TEST_%d_%d", lsx+1, lsy+1);
    device VCKBMUX_TEST ( symbol logsym_e )  *strVar14  @[gsx-1900,gsy+300];
    map 
    ( 
         <instance *strVar14>   => wRef
     );
     
    gsx = gsx + 1400;
    gsy = gsy - 600;   
    
    wRef = <device IOCKDLY @[lsx,lsy+6]  of ARCHITECTURE>;
    string strVar15;
    sprintf(strVar15, "IOCKDLY_%d_%d", lsx, lsy+6);
    device IOCKDLY  ( symbol logsym_e )  *strVar15  @[gsx-2500,gsy+330];
    map 
    ( 
         <instance *strVar15>   => wRef
     );
    

    wRef = <device IOCKDLYMUX @[lsx,lsy+2]  of ARCHITECTURE>;
    string strVar16;
    sprintf(strVar16, "IOCKDLYMUX_%d_%d", lsx, lsy+2);
    device IOCKDLYMUX  ( symbol logsym_e )  *strVar16  @[gsx-2600,gsy+300];
    map 
    ( 
         <instance *strVar16>   => wRef
     );
     
    wRef = <device IOCKDLY @[lsx,lsy+7]  of ARCHITECTURE>;
    string strVar17;
    sprintf(strVar17, "IOCKDLY_%d_%d", lsx, lsy+7);
    device IOCKDLY  ( symbol logsym_e )  *strVar17  @[gsx-2500,gsy+530];
    map 
    ( 
         <instance *strVar17>   => wRef
     );
    

    wRef = <device IOCKDLYMUX @[lsx,lsy+3]  of ARCHITECTURE>;
    string strVar18;
    sprintf(strVar18, "IOCKDLYMUX_%d_%d", lsx, lsy+3);
    device IOCKDLYMUX  ( symbol logsym_e )  *strVar18  @[gsx-2600,gsy+500];
    map 
    ( 
         <instance *strVar18>   => wRef
     );
    
    wRef = <device IOCKGMUX @[lsx,lsy]  of ARCHITECTURE>;
    string strVar19;
    sprintf(strVar19, "IOCKGMUX_%d_%d", lsx, lsy);
    device IOCKGMUX  ( symbol logsym_e )  *strVar19  @[gsx-2700,gsy+500];
    map 
    ( 
         <instance *strVar19>   => wRef
     );
     
    wRef = <device IOCKGMUX_OUT @[lsx+1,lsy+10]  of ARCHITECTURE>;
    string strVar20;
    sprintf(strVar20, "IOCKGMUX_OUT_%d_%d", lsx+1, lsy+10);
    device IOCKGMUX_OUT  ( symbol logsym_e )  *strVar20  @[gsx-2800,gsy+400];
    map 
    ( 
         <instance *strVar20>   => wRef
     );
     
    wRef = <device IOCKGMUX_TEST @[lsx,lsy+2]  of ARCHITECTURE>;
    string strVar21;
    sprintf(strVar21, "IOCKGMUX_TEST_%d_%d", lsx, lsy+2);
    device IOCKGMUX_TEST  ( symbol logsym_e )  *strVar21  @[gsx-2700,gsy+300];
    map 
    ( 
         <instance *strVar21>   => wRef
     );
     
    wRef = <device IOCKGATE @[lsx,lsy]  of ARCHITECTURE>;
    string strVar22;
    sprintf(strVar22, "IOCKGATE_%d_%d", lsx, lsy);
    device IOCKGATE  ( symbol logsym_e )  *strVar22  @[gsx-2900,gsy+420];
    map 
    ( 
         <instance *strVar22>   => wRef
     ); 
     
    wRef = <device IOCKDIV @[lsx,lsy+8]  of ARCHITECTURE>;
    string strVar23;
    sprintf(strVar23, "IOCKDIV_%d_%d", lsx, lsy+8);
    device IOCKDIV  ( symbol logsym_e )  *strVar23  @[gsx-3000,gsy+670];
    map 
    ( 
         <instance *strVar23>   => wRef
     ); 
     
    wRef = <device RCKBMUX @[lsx,lsy]  of ARCHITECTURE>;
    string strVar24;
    sprintf(strVar24, "RCKBMUX_%d_%d", lsx, lsy);
    device RCKBMUX ( symbol logsym_e )  *strVar24  @[gsx-3100,gsy+500];
    map 
    ( 
         <instance *strVar24>   => wRef
     );

    wRef = <device RCKBMUX_OUT @[lsx+1,lsy+11]  of ARCHITECTURE>;
    string strVar25;
    sprintf(strVar25, "RCKBMUX_OUT_%d_%d", lsx+1, lsy+11);
    device RCKBMUX_OUT ( symbol logsym_e )  *strVar25  @[gsx-3200,gsy+400];
    map 
    ( 
         <instance *strVar25>   => wRef
     );
     
    wRef = <device RCKBMUX_TEST @[lsx,lsy+10]  of ARCHITECTURE>;
    string strVar26;
    sprintf(strVar26, "RCKBMUX_TEST_%d_%d", lsx, lsy+10);
    device RCKBMUX_TEST ( symbol logsym_e )  *strVar26  @[gsx-3100,gsy+300];
    map 
    ( 
         <instance *strVar26>   => wRef
     );
     
    wRef = <device VCKBMUX @[lsx,lsy]  of ARCHITECTURE>;
    string strVar27;
    sprintf(strVar27, "VCKBMUX_%d_%d", lsx, lsy);
    device VCKBMUX ( symbol logsym_e )  *strVar27  @[gsx-3300,gsy+500];
    map 
    ( 
         <instance *strVar27>   => wRef
     );
     
    wRef = <device VCKBMUX_OUT @[lsx,lsy]  of ARCHITECTURE>;
    string strVar28;
    sprintf(strVar28, "VCKBMUX_OUT_%d_%d", lsx, lsy);
    device VCKBMUX_OUT ( symbol logsym_e )  *strVar28  @[gsx-3400,gsy+400];
    map 
    ( 
         <instance *strVar28>   => wRef
     );
     
    wRef = <device VCKBMUX_TEST @[lsx+1,lsy]  of ARCHITECTURE>;
    string strVar29;
    sprintf(strVar29, "VCKBMUX_TEST_%d_%d", lsx+1, lsy);
    device VCKBMUX_TEST ( symbol logsym_e )  *strVar29  @[gsx-3300,gsy+300];
    map 
    ( 
         <instance *strVar29>   => wRef
     );
     
    gsx = gsx - 1000;
    gsy = gsy + 300;    
    
    &device xRef;     
    xRef  = <device DLLMUX  @[lsx,lsy]     of ARCHITECTURE>;
    string strVar30;
    sprintf(strVar30, "DLLMUX_%d_%d", lsx, lsy);
    device DLLMUX   ( symbol logsym )  *strVar30  @[gsx-4000,gsy+430];
    map 
    ( 
        <instance *strVar30>   => xRef
     );   
     
     
     // Pull out the device instances from logic structure  
    &device mRef;
    mRef  = <device DLL  @[lsx+1,lsy+3]     of ARCHITECTURE>;
    string strVar31;
    sprintf(strVar31, "DLL_%d_%d", lsx+1, lsy+3);
    device DLL   ( symbol logsym_1 )  *strVar31  @[gsx-4100,gsy+320];
    map 
    ( 
        <instance *strVar31>   => mRef
     );
     
    &device sRef;
    sRef  = <device CKEB  @[lsx,lsy]     of ARCHITECTURE>;
    string strVar32;
    sprintf(strVar32, "CKEB_%d_%d", lsx, lsy);
    device CKEB   ( symbol logsym_n )  *strVar32  @[gsx-2800,gsy+920];
    map 
    ( 
        <instance *strVar32>   => sRef
     );    
    
    sRef = <device CKEBMUX @[lsx+0,lsy+0]  of ARCHITECTURE>;
    sprintf(strVar32, "CKEBMUX_%d_%d", lsx+0, lsy+0);
    device CKEBMUX  ( symbol logsym )  *strVar32  @[gsx-2400,gsy+900];
    map 
    ( 
         <instance *strVar32>   => sRef
     );
        
    // Pull out the device instances from logic structure  
    sRef  = <device RCKB  @[lsx+1,lsy+4]     of ARCHITECTURE>;
    string strVar33;
    sprintf(strVar33, "RCKB_%d_%d", lsx+1, lsy+4);
    device RCKB   ( symbol logsym_e )  *strVar33  @[gsx-3900,gsy+250];
    map 
    ( 
        <instance *strVar33>   => sRef
     );
     
    sRef  = <device RCKB  @[lsx+1,lsy+5]     of ARCHITECTURE>;
    string strVar34;
    sprintf(strVar34, "RCKB_%d_%d", lsx+1, lsy+5);
    device RCKB   ( symbol logsym_e )  *strVar34  @[gsx-3900,gsy+550];
    map 
    ( 
        <instance *strVar34>   => sRef
     );
     
    sRef  = <device RCKB  @[lsx+1,lsy+6]     of ARCHITECTURE>;
    string strVar35;
    sprintf(strVar35, "RCKB_%d_%d", lsx+1, lsy+6);
    device RCKB   ( symbol logsym_e )  *strVar35  @[gsx-3900,gsy+350];
    map 
    ( 
        <instance *strVar35>   => sRef
     );
     
    sRef  = <device RCKB  @[lsx+1,lsy+7]     of ARCHITECTURE>;
    string strVar36;
    sprintf(strVar36, "RCKB_%d_%d", lsx+1, lsy+7);
    device RCKB   ( symbol logsym_e )  *strVar36  @[gsx-3900,gsy+450];
    map 
    ( 
        <instance *strVar36>   => sRef
     );
  }
}  // end of function draw_iockgatedll


//function draw_hmemciockgatedll_tile(unsigned int tx, ty)
//{
//    unsigned int lsx, lsy, gsx, gsy;
//    
//    lsx = tx * NUM_GRID_X + 2;
//    lsy = ty * NUM_GRID_Y;
//    
//    unsigned int temp_ty;
//    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
//    {
//      lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
//    }
//    
//    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
//    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
//    
//    gsy = gsy + 1200;
//
//  if(tx*2 < NUM_TILE_X)
//  {
//    gsx = gsx - 2200;
//    gsy = gsy + 300;
//    
//    &device wRef;
//    wRef = <device IOCKDLY @[lsx,lsy+4]  of ARCHITECTURE>;
//    string strVar0;
//    sprintf(strVar0, "IOCKDLY_%d_%d", lsx, lsy+4);
//    device IOCKDLY  ( symbol logsym_w )  *strVar0  @[gsx+1100,gsy+330];
//    map 
//    ( 
//         <instance *strVar0>   => wRef
//     );
//    
//
//    wRef = <device IOCKDLYMUX @[lsx,lsy]  of ARCHITECTURE>;
//    string strVar1;
//    sprintf(strVar1, "IOCKDLYMUX_%d_%d", lsx, lsy);
//    device IOCKDLYMUX  ( symbol logsym_w )  *strVar1  @[gsx+1200,gsy+300];
//    map 
//    ( 
//         <instance *strVar1>   => wRef
//     );
//     
//    wRef = <device IOCKDLY @[lsx,lsy+5]  of ARCHITECTURE>;
//    string strVar2;
//    sprintf(strVar2, "IOCKDLY_%d_%d", lsx, lsy+5);
//    device IOCKDLY  ( symbol logsym_w )  *strVar2  @[gsx+1100,gsy+530];
//    map 
//    ( 
//         <instance *strVar2>   => wRef
//     );
//    
//
//    wRef = <device IOCKDLYMUX @[lsx,lsy+1]  of ARCHITECTURE>;
//    string strVar3;
//    sprintf(strVar3, "IOCKDLYMUX_%d_%d", lsx, lsy+1);
//    device IOCKDLYMUX  ( symbol logsym_w )  *strVar3  @[gsx+1200,gsy+500];
//    map 
//    ( 
//         <instance *strVar3>   => wRef
//     );
//     
//    wRef = <device IOCKGMUX @[lsx,lsy+1]  of ARCHITECTURE>;
//    string strVar4;
//    sprintf(strVar4, "IOCKGMUX_%d_%d", lsx, lsy+1);
//    device IOCKGMUX  ( symbol logsym_w )  *strVar4  @[gsx+1300,gsy+500];
//    map 
//    ( 
//         <instance *strVar4>   => wRef
//     );
//     
//    wRef = <device IOCKGMUX_OUT @[lsx,lsy+1]  of ARCHITECTURE>;
//    string strVar5;
//    sprintf(strVar5, "IOCKGMUX_OUT_%d_%d", lsx, lsy+1);
//    device IOCKGMUX_OUT  ( symbol logsym )  *strVar5  @[gsx+1400,gsy+400];
//    map 
//    ( 
//         <instance *strVar5>   => wRef
//     );
//     
//    wRef = <device IOCKGMUX_TEST @[lsx,lsy+3]  of ARCHITECTURE>;
//    string strVar6;
//    sprintf(strVar6, "IOCKGMUX_TEST_%d_%d", lsx, lsy+3);
//    device IOCKGMUX_TEST  ( symbol logsym )  *strVar6  @[gsx+1300,gsy+300];
//    map 
//    ( 
//         <instance *strVar6>   => wRef
//     ); 
//     
//    wRef = <device IOCKGATE @[lsx,lsy+1]  of ARCHITECTURE>;
//    string strVar7;
//    sprintf(strVar7, "IOCKGATE_%d_%d", lsx, lsy+1);
//    device IOCKGATE  ( symbol logsym_w )  *strVar7  @[gsx+1500,gsy+420];
//    map 
//    ( 
//         <instance *strVar7>   => wRef
//     ); 
//     
//    wRef = <device IOCKDIV @[lsx,lsy+9]  of ARCHITECTURE>;
//    string strVar8;
//    sprintf(strVar8, "IOCKDIV_%d_%d", lsx, lsy+9);
//    device IOCKDIV  ( symbol logsym_w )  *strVar8  @[gsx+1600,gsy+170];
//    map 
//    ( 
//         <instance *strVar8>   => wRef
//     ); 
//     
//    wRef = <device RCKBMUX @[lsx,lsy+1]  of ARCHITECTURE>;
//    string strVar9;
//    sprintf(strVar9, "RCKBMUX_%d_%d", lsx, lsy+1);
//    device RCKBMUX ( symbol logsym )  *strVar9  @[gsx+1700,gsy+500];
//    map 
//    ( 
//         <instance *strVar9>   => wRef
//     );
//
//    wRef = <device RCKBMUX_OUT @[lsx+1,lsy+8]  of ARCHITECTURE>;
//    string strVar10;
//    sprintf(strVar10, "RCKBMUX_OUT_%d_%d", lsx+1, lsy+8);
//    device RCKBMUX_OUT ( symbol logsym )  *strVar10  @[gsx+1800,gsy+400];
//    map 
//    ( 
//         <instance *strVar10>   => wRef
//     );
//     
//    wRef = <device RCKBMUX_TEST @[lsx,lsy+11]  of ARCHITECTURE>;
//    string strVar11;
//    sprintf(strVar11, "RCKBMUX_TEST_%d_%d", lsx, lsy+11);
//    device RCKBMUX_TEST ( symbol logsym )  *strVar11  @[gsx+1700,gsy+300];
//    map 
//    ( 
//         <instance *strVar11>   => wRef
//     );
//     
//    wRef = <device VCKBMUX @[lsx,lsy+1]  of ARCHITECTURE>;
//    string strVar12;
//    sprintf(strVar12, "VCKBMUX_%d_%d", lsx, lsy+1);
//    device VCKBMUX ( symbol logsym )  *strVar12  @[gsx+1900,gsy+500];
//    map 
//    ( 
//         <instance *strVar12>   => wRef
//     );
//     
//    wRef = <device VCKBMUX_OUT @[lsx+1,lsy+9]  of ARCHITECTURE>;
//    string strVar13;
//    sprintf(strVar13, "VCKBMUX_OUT_%d_%d", lsx+1, lsy+9);
//    device VCKBMUX_OUT ( symbol logsym )  *strVar13  @[gsx+2000,gsy+400];
//    map 
//    ( 
//         <instance *strVar13>   => wRef
//     );
//     
//    wRef = <device VCKBMUX_TEST @[lsx+1,lsy+1]  of ARCHITECTURE>;
//    string strVar14;
//    sprintf(strVar14, "VCKBMUX_TEST_%d_%d", lsx+1, lsy+1);
//    device VCKBMUX_TEST ( symbol logsym )  *strVar14  @[gsx+1900,gsy+300];
//    map 
//    ( 
//         <instance *strVar14>   => wRef
//     );
//     
//    gsx = gsx - 1400;
//    gsy = gsy - 600;
//     
//    wRef = <device IOCKDLY @[lsx,lsy+6]  of ARCHITECTURE>;
//    string strVar15;
//    sprintf(strVar15, "IOCKDLY_%d_%d", lsx, lsy+7);
//    device IOCKDLY  ( symbol logsym_w )  *strVar15  @[gsx+2500,gsy+330];
//    map 
//    ( 
//         <instance *strVar15>   => wRef
//     );
//    
//
//    wRef = <device IOCKDLYMUX @[lsx,lsy+2]  of ARCHITECTURE>;
//    string strVar16;
//    sprintf(strVar16, "IOCKDLYMUX_%d_%d", lsx, lsy+7);
//    device IOCKDLYMUX  ( symbol logsym_w )  *strVar16  @[gsx+2600,gsy+300];
//    map 
//    ( 
//         <instance *strVar16>   => wRef
//     );
//     
//    wRef = <device IOCKDLY @[lsx,lsy+7]  of ARCHITECTURE>;
//    string strVar17;
//    sprintf(strVar17, "IOCKDLY_%d_%d", lsx, lsy+8);
//    device IOCKDLY  ( symbol logsym_w )  *strVar17  @[gsx+2500,gsy+530];
//    map 
//    ( 
//         <instance *strVar17>   => wRef
//     );
//    
//
//    wRef = <device IOCKDLYMUX @[lsx,lsy+3]  of ARCHITECTURE>;
//    string strVar18;
//    sprintf(strVar18, "IOCKDLYMUX_%d_%d", lsx, lsy+8);
//    device IOCKDLYMUX  ( symbol logsym_w )  *strVar18  @[gsx+2600,gsy+500];
//    map 
//    ( 
//         <instance *strVar18>   => wRef
//     );
//    
//    wRef = <device IOCKGMUX @[lsx,lsy]  of ARCHITECTURE>;
//    string strVar19;
//    sprintf(strVar19, "IOCKGMUX_%d_%d", lsx, lsy);
//    device IOCKGMUX  ( symbol logsym_w )  *strVar19  @[gsx+2700,gsy+500];
//    map 
//    ( 
//         <instance *strVar19>   => wRef
//     );
//     
//    wRef = <device IOCKGMUX_OUT @[lsx+1,lsy+10]  of ARCHITECTURE>;
//    string strVar20;
//    sprintf(strVar20, "IOCKGMUX_OUT_%d_%d", lsx+1, lsy+10);
//    device IOCKGMUX_OUT  ( symbol logsym )  *strVar20  @[gsx+2800,gsy+400];
//    map 
//    ( 
//         <instance *strVar20>   => wRef
//     );
//     
//    wRef = <device IOCKGMUX_TEST @[lsx,lsy+2]  of ARCHITECTURE>;
//    string strVar21;
//    sprintf(strVar21, "IOCKGMUX_TEST_%d_%d", lsx, lsy+2);
//    device IOCKGMUX_TEST  ( symbol logsym )  *strVar21  @[gsx+2700,gsy+300];
//    map 
//    ( 
//         <instance *strVar21>   => wRef
//     );
//     
//    wRef = <device IOCKGATE @[lsx,lsy]  of ARCHITECTURE>;
//    string strVar22;
//    sprintf(strVar22, "IOCKGATE_%d_%d", lsx, lsy);
//    device IOCKGATE  ( symbol logsym_w )  *strVar22  @[gsx+2900,gsy+420];
//    map 
//    ( 
//         <instance *strVar22>   => wRef
//     ); 
//     
//    wRef = <device IOCKDIV @[lsx,lsy+8]  of ARCHITECTURE>;
//    string strVar23;
//    sprintf(strVar23, "IOCKDIV_%d_%d", lsx, lsy+8);
//    device IOCKDIV  ( symbol logsym_w )  *strVar23  @[gsx+3000,gsy+670];
//    map 
//    ( 
//         <instance *strVar23>   => wRef
//     ); 
//     
//    wRef = <device RCKBMUX @[lsx,lsy]  of ARCHITECTURE>;
//    string strVar24;
//    sprintf(strVar24, "RCKBMUX_%d_%d", lsx, lsy);
//    device RCKBMUX ( symbol logsym )  *strVar24  @[gsx+3100,gsy+500];
//    map 
//    ( 
//         <instance *strVar24>   => wRef
//     );
//
//    wRef = <device RCKBMUX_OUT @[lsx+1,lsy+11]  of ARCHITECTURE>;
//    string strVar25;
//    sprintf(strVar25, "RCKBMUX_OUT_%d_%d", lsx+1, lsy+11);
//    device RCKBMUX_OUT ( symbol logsym )  *strVar25  @[gsx+3200,gsy+400];
//    map 
//    ( 
//         <instance *strVar25>   => wRef
//     );
//     
//    wRef = <device RCKBMUX_TEST @[lsx,lsy+10]  of ARCHITECTURE>;
//    string strVar26;
//    sprintf(strVar26, "RCKBMUX_TEST_%d_%d", lsx+1, lsy);
//    device RCKBMUX_TEST ( symbol logsym )  *strVar26  @[gsx+3100,gsy+300];
//    map 
//    ( 
//         <instance *strVar26>   => wRef
//     );
//     
//    wRef = <device VCKBMUX @[lsx,lsy]  of ARCHITECTURE>;
//    string strVar27;
//    sprintf(strVar27, "VCKBMUX_%d_%d", lsx, lsy);
//    device VCKBMUX ( symbol logsym )  *strVar27  @[gsx+3300,gsy+500];
//    map 
//    ( 
//         <instance *strVar27>   => wRef
//     );
//     
//    wRef = <device VCKBMUX_OUT @[lsx,lsy]  of ARCHITECTURE>;
//    string strVar28;
//    sprintf(strVar28, "VCKBMUX_OUT_%d_%d", lsx, lsy);
//    device VCKBMUX_OUT ( symbol logsym )  *strVar28  @[gsx+3400,gsy+400];
//    map 
//    ( 
//         <instance *strVar28>   => wRef
//     );
//     
//    wRef = <device VCKBMUX_TEST @[lsx+1,lsy]  of ARCHITECTURE>;
//    string strVar29;
//    sprintf(strVar29, "VCKBMUX_TEST_%d_%d", lsx+1, lsy);
//    device VCKBMUX_TEST ( symbol logsym )  *strVar29  @[gsx+3300,gsy+300];
//    map 
//    ( 
//         <instance *strVar29>   => wRef
//     );
//     
//    gsx = gsx + 1400;
//    gsy = gsy + 300;
//     
//    &device hRef;
//    hRef = <device HMEMCMUX_DLL  @[lsx,lsy]  of ARCHITECTURE>;
//    string strVar37;
//    sprintf(strVar37, "HEMMCMUCX_DLL_%d_%d", lsx, lsy);
//    device HMEMCMUX_DLL   ( symbol logsym )  *strVar37  @[gsx+3700,gsy+470];
//    map 
//    ( 
//        <instance *strVar37>   => hRef
//     );      
//     
//    &device xRef;     
//    xRef  = <device DLLMUX  @[lsx,lsy+1]     of ARCHITECTURE>;
//    string strVar30;
//    sprintf(strVar30, "DLLMUX_%d_%d", lsx, lsy+1);
//    device DLLMUX   ( symbol logsym_w )  *strVar30  @[gsx+4000,gsy+430];
//    map 
//    ( 
//        <instance *strVar30>   => xRef
//     );   
//     
//     
//     // Pull out the device instances from logic structure  
//    &device mRef;
//    mRef  = <device DLL  @[lsx+1,lsy+3]     of ARCHITECTURE>;
//    string strVar31;
//    sprintf(strVar31, "DLL_%d_%d", lsx+1, lsy+3);
//    device DLL   ( symbol logsym )  *strVar31  @[gsx+4100,gsy+320];
//    map 
//    ( 
//        <instance *strVar31>   => mRef
//     );   
//     
//     
//    // Pull out the device instances from logic structure  
//    &device sRef;  
//    sRef  = <device RCKB  @[lsx+1,lsy+4]     of ARCHITECTURE>;
//    string strVar33;
//    sprintf(strVar33, "RCKB_%d_%d", lsx+1, lsy+4);
//    device RCKB   ( symbol logsym )  *strVar33  @[gsx+3900,gsy+250];
//    map 
//    ( 
//        <instance *strVar33>   => sRef
//     );
//     
//    sRef  = <device RCKB  @[lsx+1,lsy+5]     of ARCHITECTURE>;
//    string strVar34;
//    sprintf(strVar34, "RCKB_%d_%d", lsx+1, lsy+5);
//    device RCKB   ( symbol logsym )  *strVar34  @[gsx+3900,gsy+550];
//    map 
//    ( 
//        <instance *strVar34>   => sRef
//     );
//     
//    sRef  = <device RCKB  @[lsx+1,lsy+6]     of ARCHITECTURE>;
//    string strVar35;
//    sprintf(strVar35, "RCKB_%d_%d", lsx+1, lsy+6);
//    device RCKB   ( symbol logsym )  *strVar35  @[gsx+3900,gsy+350];
//    map 
//    ( 
//        <instance *strVar35>   => sRef
//     );
//     
//    sRef  = <device RCKB  @[lsx+1,lsy+7]     of ARCHITECTURE>;
//    string strVar36;
//    sprintf(strVar36, "RCKB_%d_%d", lsx+1, lsy+7);
//    device RCKB   ( symbol logsym )  *strVar36  @[gsx+3900,gsy+450];
//    map 
//    ( 
//        <instance *strVar36>   => sRef
//     );
//  }            
//  else
//  {
//    gsx = gsx + 3400;
//    gsy = gsy + 300;
//    
//    &device wRef;
//    wRef = <device IOCKDLY @[lsx,lsy+4]  of ARCHITECTURE>;
//    string strVar0;
//    sprintf(strVar0, "IOCKDLY_%d_%d", lsx, lsy+4);
//    device IOCKDLY  ( symbol logsym_e )  *strVar0  @[gsx-1100,gsy+330];
//    map 
//    ( 
//         <instance *strVar0>   => wRef
//     );
//    
//
//    wRef = <device IOCKDLYMUX @[lsx,lsy]  of ARCHITECTURE>;
//    string strVar1;
//    sprintf(strVar1, "IOCKDLYMUX_%d_%d", lsx, lsy);
//    device IOCKDLYMUX  ( symbol logsym_e )  *strVar1  @[gsx-1200,gsy+300];
//    map 
//    ( 
//         <instance *strVar1>   => wRef
//     );
//     
//    wRef = <device IOCKDLY @[lsx,lsy+5]  of ARCHITECTURE>;
//    string strVar2;
//    sprintf(strVar2, "IOCKDLY_%d_%d", lsx, lsy+5);
//    device IOCKDLY  ( symbol logsym_e )  *strVar2  @[gsx-1100,gsy+530];
//    map 
//    ( 
//         <instance *strVar2>   => wRef
//     );
//    
//
//    wRef = <device IOCKDLYMUX @[lsx,lsy+1]  of ARCHITECTURE>;
//    string strVar3;
//    sprintf(strVar3, "IOCKDLYMUX_%d_%d", lsx, lsy+1);
//    device IOCKDLYMUX  ( symbol logsym_e )  *strVar3  @[gsx-1200,gsy+500];
//    map 
//    ( 
//         <instance *strVar3>   => wRef
//     );
//     
//    wRef = <device IOCKGMUX @[lsx,lsy+1]  of ARCHITECTURE>;
//    string strVar4;
//    sprintf(strVar4, "IOCKGMUX_%d_%d", lsx, lsy+1);
//    device IOCKGMUX  ( symbol logsym_e )  *strVar4  @[gsx-1300,gsy+500];
//    map 
//    ( 
//         <instance *strVar4>   => wRef
//     );
//     
//    wRef = <device IOCKGMUX_OUT @[lsx,lsy+1]  of ARCHITECTURE>;
//    string strVar5;
//    sprintf(strVar5, "IOCKGMUX_OUT_%d_%d", lsx, lsy+1);
//    device IOCKGMUX_OUT  ( symbol logsym_e )  *strVar5  @[gsx-1400,gsy+400];
//    map 
//    ( 
//         <instance *strVar5>   => wRef
//     );
//     
//    wRef = <device IOCKGMUX_TEST @[lsx,lsy+3]  of ARCHITECTURE>;
//    string strVar6;
//    sprintf(strVar6, "IOCKGMUX_TEST_%d_%d", lsx, lsy+3);
//    device IOCKGMUX_TEST  ( symbol logsym_e )  *strVar6  @[gsx-1300,gsy+300];
//    map 
//    ( 
//         <instance *strVar6>   => wRef
//     ); 
//     
//    wRef = <device IOCKGATE @[lsx,lsy+1]  of ARCHITECTURE>;
//    string strVar7;
//    sprintf(strVar7, "IOCKGATE_%d_%d", lsx, lsy+1);
//    device IOCKGATE  ( symbol logsym_e )  *strVar7  @[gsx-1500,gsy+420];
//    map 
//    ( 
//         <instance *strVar7>   => wRef
//     ); 
//     
//    wRef = <device IOCKDIV @[lsx,lsy+9]  of ARCHITECTURE>;
//    string strVar8;
//    sprintf(strVar8, "IOCKDIV_%d_%d", lsx, lsy+9);
//    device IOCKDIV  ( symbol logsym_e )  *strVar8  @[gsx-1600,gsy+170];
//    map 
//    ( 
//         <instance *strVar8>   => wRef
//     ); 
//     
//    wRef = <device RCKBMUX @[lsx,lsy+1]  of ARCHITECTURE>;
//    string strVar9;
//    sprintf(strVar9, "RCKBMUX_%d_%d", lsx, lsy+1);
//    device RCKBMUX ( symbol logsym_e )  *strVar9  @[gsx-1700,gsy+500];
//    map 
//    ( 
//         <instance *strVar9>   => wRef
//     );
//
//    wRef = <device RCKBMUX_OUT @[lsx+1,lsy+8]  of ARCHITECTURE>;
//    string strVar10;
//    sprintf(strVar10, "RCKBMUX_OUT_%d_%d", lsx+1, lsy+8);
//    device RCKBMUX_OUT ( symbol logsym_e )  *strVar10  @[gsx-1800,gsy+400];
//    map 
//    ( 
//         <instance *strVar10>   => wRef
//     );
//     
//    wRef = <device RCKBMUX_TEST @[lsx,lsy+11]  of ARCHITECTURE>;
//    string strVar11;
//    sprintf(strVar11, "RCKBMUX_TEST_%d_%d", lsx, lsy+11);
//    device RCKBMUX_TEST ( symbol logsym_e )  *strVar11  @[gsx-1700,gsy+300];
//    map 
//    ( 
//         <instance *strVar11>   => wRef
//     );
//     
//    wRef = <device VCKBMUX @[lsx,lsy+1]  of ARCHITECTURE>;
//    string strVar12;
//    sprintf(strVar12, "VCKBMUX_%d_%d", lsx, lsy+1);
//    device VCKBMUX ( symbol logsym_e )  *strVar12  @[gsx-1900,gsy+500];
//    map 
//    ( 
//         <instance *strVar12>   => wRef
//     );
//     
//    wRef = <device VCKBMUX_OUT @[lsx+1,lsy+9]  of ARCHITECTURE>;
//    string strVar13;
//    sprintf(strVar13, "VCKBMUX_OUT_%d_%d", lsx+1, lsy+9);
//    device VCKBMUX_OUT ( symbol logsym_e )  *strVar13  @[gsx-2000,gsy+400];
//    map 
//    ( 
//         <instance *strVar13>   => wRef
//     );
//     
//    wRef = <device VCKBMUX_TEST @[lsx+1,lsy+1]  of ARCHITECTURE>;
//    string strVar14;
//    sprintf(strVar14, "VCKBMUX_TEST_%d_%d", lsx+1, lsy+1);
//    device VCKBMUX_TEST ( symbol logsym_e )  *strVar14  @[gsx-1900,gsy+300];
//    map 
//    ( 
//         <instance *strVar14>   => wRef
//     );
//         
//    gsx = gsx + 1400;
//    gsy = gsy - 600;
//     
//    wRef = <device IOCKDLY @[lsx,lsy+6]  of ARCHITECTURE>;
//    string strVar15;
//    sprintf(strVar15, "IOCKDLY_%d_%d", lsx, lsy+6);
//    device IOCKDLY  ( symbol logsym_e )  *strVar15  @[gsx-2500,gsy+330];
//    map 
//    ( 
//         <instance *strVar15>   => wRef
//     );
//    
//
//    wRef = <device IOCKDLYMUX @[lsx,lsy+2]  of ARCHITECTURE>;
//    string strVar16;
//    sprintf(strVar16, "IOCKDLYMUX_%d_%d", lsx, lsy+2);
//    device IOCKDLYMUX  ( symbol logsym_e )  *strVar16  @[gsx-2600,gsy+300];
//    map 
//    ( 
//         <instance *strVar16>   => wRef
//     );
//     
//    wRef = <device IOCKDLY @[lsx,lsy+7]  of ARCHITECTURE>;
//    string strVar17;
//    sprintf(strVar17, "IOCKDLY_%d_%d", lsx, lsy+7);
//    device IOCKDLY  ( symbol logsym_e )  *strVar17  @[gsx-2500,gsy+530];
//    map 
//    ( 
//         <instance *strVar17>   => wRef
//     );
//    
//
//    wRef = <device IOCKDLYMUX @[lsx,lsy+3]  of ARCHITECTURE>;
//    string strVar18;
//    sprintf(strVar18, "IOCKDLYMUX_%d_%d", lsx, lsy+3);
//    device IOCKDLYMUX  ( symbol logsym_e )  *strVar18  @[gsx-2600,gsy+500];
//    map 
//    ( 
//         <instance *strVar18>   => wRef
//     );
//    
//    wRef = <device IOCKGMUX @[lsx,lsy]  of ARCHITECTURE>;
//    string strVar19;
//    sprintf(strVar19, "IOCKGMUX_%d_%d", lsx, lsy);
//    device IOCKGMUX  ( symbol logsym_e )  *strVar19  @[gsx-2700,gsy+500];
//    map 
//    ( 
//         <instance *strVar19>   => wRef
//     );
//     
//    wRef = <device IOCKGMUX_OUT @[lsx+1,lsy+10]  of ARCHITECTURE>;
//    string strVar20;
//    sprintf(strVar20, "IOCKGMUX_OUT_%d_%d", lsx+1, lsy+10);
//    device IOCKGMUX_OUT  ( symbol logsym_e )  *strVar20  @[gsx-2800,gsy+400];
//    map 
//    ( 
//         <instance *strVar20>   => wRef
//     );
//     
//    wRef = <device IOCKGMUX_TEST @[lsx,lsy+2]  of ARCHITECTURE>;
//    string strVar21;
//    sprintf(strVar21, "IOCKGMUX_TEST_%d_%d", lsx, lsy+2);
//    device IOCKGMUX_TEST  ( symbol logsym_e )  *strVar21  @[gsx-2700,gsy+300];
//    map 
//    ( 
//         <instance *strVar21>   => wRef
//     );
//     
//    wRef = <device IOCKGATE @[lsx,lsy]  of ARCHITECTURE>;
//    string strVar22;
//    sprintf(strVar22, "IOCKGATE_%d_%d", lsx, lsy);
//    device IOCKGATE  ( symbol logsym_e )  *strVar22  @[gsx-2900,gsy+420];
//    map 
//    ( 
//         <instance *strVar22>   => wRef
//     ); 
//     
//    wRef = <device IOCKDIV @[lsx,lsy+8]  of ARCHITECTURE>;
//    string strVar23;
//    sprintf(strVar23, "IOCKDIV_%d_%d", lsx, lsy+8);
//    device IOCKDIV  ( symbol logsym_e )  *strVar23  @[gsx-3000,gsy+670];
//    map 
//    ( 
//         <instance *strVar23>   => wRef
//     ); 
//     
//    wRef = <device RCKBMUX @[lsx,lsy]  of ARCHITECTURE>;
//    string strVar24;
//    sprintf(strVar24, "RCKBMUX_%d_%d", lsx, lsy);
//    device RCKBMUX ( symbol logsym_e )  *strVar24  @[gsx-3100,gsy+500];
//    map 
//    ( 
//         <instance *strVar24>   => wRef
//     );
//
//    wRef = <device RCKBMUX_OUT @[lsx+1,lsy+11]  of ARCHITECTURE>;
//    string strVar25;
//    sprintf(strVar25, "RCKBMUX_OUT_%d_%d", lsx+1, lsy+11);
//    device RCKBMUX_OUT ( symbol logsym_e )  *strVar25  @[gsx-3200,gsy+400];
//    map 
//    ( 
//         <instance *strVar25>   => wRef
//     );
//     
//    wRef = <device RCKBMUX_TEST @[lsx,lsy+10]  of ARCHITECTURE>;
//    string strVar26;
//    sprintf(strVar26, "RCKBMUX_TEST_%d_%d", lsx, lsy+10);
//    device RCKBMUX_TEST ( symbol logsym_e )  *strVar26  @[gsx-3100,gsy+300];
//    map 
//    ( 
//         <instance *strVar26>   => wRef
//     );
//     
//    wRef = <device VCKBMUX @[lsx,lsy]  of ARCHITECTURE>;
//    string strVar27;
//    sprintf(strVar27, "VCKBMUX_%d_%d", lsx, lsy);
//    device VCKBMUX ( symbol logsym_e )  *strVar27  @[gsx-3300,gsy+500];
//    map 
//    ( 
//         <instance *strVar27>   => wRef
//     );
//     
//    wRef = <device VCKBMUX_OUT @[lsx,lsy]  of ARCHITECTURE>;
//    string strVar28;
//    sprintf(strVar28, "VCKBMUX_OUT_%d_%d", lsx, lsy);
//    device VCKBMUX_OUT ( symbol logsym_e )  *strVar28  @[gsx-3400,gsy+400];
//    map 
//    ( 
//         <instance *strVar28>   => wRef
//     );
//     
//    wRef = <device VCKBMUX_TEST @[lsx+1,lsy]  of ARCHITECTURE>;
//    string strVar29;
//    sprintf(strVar29, "VCKBMUX_TEST_%d_%d", lsx+1, lsy);
//    device VCKBMUX_TEST ( symbol logsym_e )  *strVar29  @[gsx-3300,gsy+300];
//    map 
//    ( 
//         <instance *strVar29>   => wRef
//     );
//     
//    gsx = gsx - 1000;
//    gsy = gsy + 300;
//     
//    &device hRef;
//    hRef = <device HMEMCMUX_DLL  @[lsx,lsy]  of ARCHITECTURE>;
//    string strVar37;
//    sprintf(strVar37, "HEMMCMUCX_DLL_%d_%d", lsx+1, lsy);
//    device HMEMCMUX_DLL   ( symbol logsym_1 )  *strVar37  @[gsx-3700,gsy+470];
//    map 
//    ( 
//        <instance *strVar37>   => hRef
//     );
//     
//    &device xRef;     
//    xRef  = <device DLLMUX  @[lsx,lsy+1]     of ARCHITECTURE>;
//    string strVar30;
//    sprintf(strVar30, "DLLMUX_%d_%d", lsx, lsy+1);
//    device DLLMUX   ( symbol logsym )  *strVar30  @[gsx-4000,gsy+430];
//    map 
//    ( 
//        <instance *strVar30>   => xRef
//     );   
//     
//     
//     // Pull out the device instances from logic structure  
//    &device mRef;
//    mRef  = <device DLL  @[lsx+1,lsy+3]     of ARCHITECTURE>;
//    string strVar31;
//    sprintf(strVar31, "DLL_%d_%d", lsx+1, lsy+3);
//    device DLL   ( symbol logsym_1 )  *strVar31  @[gsx-4100,gsy+320];
//    map 
//    ( 
//        <instance *strVar31>   => mRef
//     );   
//           
//     
//    // Pull out the device instances from logic structure  
//    &device sRef;   
//    sRef  = <device RCKB  @[lsx+1,lsy+4]     of ARCHITECTURE>;
//    string strVar33;
//    sprintf(strVar33, "RCKB_%d_%d", lsx+1, lsy+4);
//    device RCKB   ( symbol logsym_e )  *strVar33  @[gsx-3900,gsy+250];
//    map 
//    ( 
//        <instance *strVar33>   => sRef
//     );
//     
//    sRef  = <device RCKB  @[lsx+1,lsy+5]     of ARCHITECTURE>;
//    string strVar34;
//    sprintf(strVar34, "RCKB_%d_%d", lsx+1, lsy+5);
//    device RCKB   ( symbol logsym_e )  *strVar34  @[gsx-3900,gsy+550];
//    map 
//    ( 
//        <instance *strVar34>   => sRef
//     );
//     
//    sRef  = <device RCKB  @[lsx+1,lsy+6]     of ARCHITECTURE>;
//    string strVar35;
//    sprintf(strVar35, "RCKB_%d_%d", lsx+1, lsy+6);
//    device RCKB   ( symbol logsym_e )  *strVar35  @[gsx-3900,gsy+350];
//    map 
//    ( 
//        <instance *strVar35>   => sRef
//     );
//     
//    sRef  = <device RCKB  @[lsx+1,lsy+7]     of ARCHITECTURE>;
//    string strVar36;
//    sprintf(strVar36, "RCKB_%d_%d", lsx+1, lsy+7);
//    device RCKB   ( symbol logsym_e )  *strVar36  @[gsx-3900,gsy+450];
//    map 
//    ( 
//        <instance *strVar36>   => sRef
//     );
//  }
//}//end of function draw_hmemciockgatedll_tile


function draw_iob_tile( unsigned int tx, ty )
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef;
    string strVar;
    
    unsigned int dt, dx, dy;
    unsigned int i, j;
    dt = 29;
    for ( i = 0; i < 4; i += 1)
    {
        for ( j = 0; j < 5; j += 1 )                // 5 IOBD one group, 4 groups
        {
            dy = 2 + 4*dt;
            
            xRef = <device IOBD @[lsx, lsy+dy] of ARCHITECTURE>;
            sprintf(strVar, "IOBD_%d_%d", lsx, lsy+dy);
            device IOBD ( symbol logsym ) *strVar @[gsx+500, gsy+660+1200*dt];
            map
            (
                <instance *strVar> => xRef
            );
            
            dy = 1 + 4*dt;
            
            if ( i* 5 + j == 6 )
            {
                xRef = <device IOBR @[lsx, lsy+dy] of ARCHITECTURE>;
                sprintf(strVar, "IOBR_%d_%d", lsx, lsy+dy);
                device IOBR ( symbol logsym ) *strVar @[gsx+500, gsy+300+1200*dt];
                map
                (
                    <instance *strVar> => xRef
                );
            }
            else
            {
                xRef = <device IOBS @[lsx, lsy+dy] of ARCHITECTURE>;
                sprintf(strVar, "IOBS_%d_%d", lsx, lsy+dy);
                device IOBS ( symbol logsym ) *strVar @[gsx+500, gsy+300+1200*dt];
                map
                (
                    <instance *strVar> => xRef
                );
            }
            
            dt -= 1;                                // next tile
        }
        
        dt -= 2;                                    // 2 tiles between two groups
        if ( i == 1 )
        {
            dt -= 3;                                // avoid blank row
        }
    }
    
    xRef = <device BKCL @[lsx+2,lsy+20]  of ARCHITECTURE>;
    sprintf(strVar, "BKCL_%d_%d", lsx+2, lsy+20);
    device BKCL ( symbol logsym ) *strVar @[gsx+500, gsy+7200];
    map 
    ( 
         <instance *strVar> => xRef
    );
    
    xRef = <device CRYSTAL @[lsx+2,lsy+21]  of ARCHITECTURE>;
    sprintf(strVar, "CRYSTAL_%d_%d", lsx+2, lsy+21);
    device CRYSTAL ( symbol logsym ) *strVar @[gsx+500, gsy+7500];
    map 
    ( 
         <instance *strVar> => xRef
    );
    
    xRef = <device RESCAL @[lsx+2,lsy+24]  of ARCHITECTURE>;
    sprintf(strVar, "RESCAL_%d_%d", lsx+2, lsy+24);
    device RESCAL ( symbol logsym ) *strVar @[gsx+500, gsy+8400];
    map 
    ( 
         <instance *strVar> => xRef
    );
    
}   //end of function draw_iob_tile

function draw_iob_wo_tile( unsigned int tx, ty )
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef;
    string strVar;
    
    unsigned int dt, dx, dy;
    unsigned int i, j;
    dt = 29;
    for ( i = 0; i < 4; i += 1)
    {
        for ( j = 0; j < 5; j += 1 )                // 5 IOBD one group, 4 groups
        {
            dy = 2 + 4*dt;
            
            xRef = <device IOBS @[lsx, lsy+dy] of ARCHITECTURE>;
            sprintf(strVar, "IOBS_%d_%d", lsx, lsy+dy);
            device IOBS ( symbol logsym ) *strVar @[gsx+500, gsy+660+1200*dt];
            map
            (
                <instance *strVar> => xRef
            );
            
            dy = 1 + 4*dt;
            
            if ( i* 5 + j == 6 )
            {
                xRef = <device IOBR @[lsx, lsy+dy] of ARCHITECTURE>;
                sprintf(strVar, "IOBR_%d_%d", lsx, lsy+dy);
                device IOBR ( symbol logsym ) *strVar @[gsx+500, gsy+300+1200*dt];
                map
                (
                    <instance *strVar> => xRef
                );
            }
            else
            {
                xRef = <device IOBS @[lsx, lsy+dy] of ARCHITECTURE>;
                sprintf(strVar, "IOBS_%d_%d", lsx, lsy+dy);
                device IOBS ( symbol logsym ) *strVar @[gsx+500, gsy+300+1200*dt];
                map
                (
                    <instance *strVar> => xRef
                );
            }
            
            dt -= 1;                                // next tile
        }
        
        dt -= 2;                                    // 2 tiles between two groups
        if ( i == 1 )
        {
            dt -= 3;                                // avoid blank row
        }
    }
    
    xRef = <device BKCL @[lsx+2,lsy+20]  of ARCHITECTURE>;
    sprintf(strVar, "BKCL_%d_%d", lsx+2, lsy+20);
    device BKCL ( symbol logsym ) *strVar @[gsx+500, gsy+7200];
    map 
    ( 
         <instance *strVar> => xRef
    );
    
    xRef = <device CRYSTAL @[lsx+2,lsy+21]  of ARCHITECTURE>;
    sprintf(strVar, "CRYSTAL_%d_%d", lsx+2, lsy+21);
    device CRYSTAL ( symbol logsym ) *strVar @[gsx+500, gsy+7500];
    map 
    ( 
         <instance *strVar> => xRef
    );
    
    //xRef = <device RESCAL @[lsx+2,lsy+24]  of ARCHITECTURE>;
    //sprintf(strVar, "RESCAL_%d_%d", lsx+2, lsy+24);
    //device RESCAL ( symbol logsym ) *strVar @[gsx+500, gsy+8400];
    //map 
    //( 
    //     <instance *strVar> => xRef
    //);
    
}   //end of function draw_iob_wo_tile

function draw_wlsr_tile( unsigned int tx, ty )
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef, rRef;
    string strVar, strVar1;
    
    xRef = <device CKEB @[lsx+1,lsy+1]  of ARCHITECTURE>;
    sprintf(strVar, "CKEB_%d_%d", lsx+1, lsy+1);
    device CKEB  ( symbol logsym_n )  *strVar  @[gsx+1000,gsy+920];
    map
    (
         <instance *strVar>   => xRef
    );
    
    rRef = <device CKEBMUX @[lsx+1,lsy+2]  of ARCHITECTURE>;
    sprintf(strVar1, "CKEBMUX_%d_%d", lsx+1, lsy+2);
    device CKEBMUX  ( symbol logsym )  *strVar1  @[gsx+600,gsy+900];
    map 
    ( 
         <instance *strVar1>   => rRef
     );
}   // end of function draw_wlsr_tile

function draw_wlsr1_tile( unsigned int tx, ty )
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef, rRef;
    string strVar, strVar1;
    
    xRef = <device CKEB @[lsx+1,lsy+1]  of ARCHITECTURE>;
    sprintf(strVar, "CKEB_%d_%d", lsx+1, lsy+1);
    device CKEB  ( symbol logsym_n )  *strVar  @[gsx+1000,gsy+920];
    map
    (
         <instance *strVar>   => xRef
    );
    
    rRef = <device CKEBMUX @[lsx+1,lsy+2]  of ARCHITECTURE>;
    sprintf(strVar1, "CKEBMUX_%d_%d", lsx+1, lsy+2);
    device CKEBMUX  ( symbol logsym )  *strVar1  @[gsx+600,gsy+900];
    map 
    ( 
         <instance *strVar1>   => rRef
     );
}   // end of function draw_wlsr1_tile

function draw_wlsr2_tile( unsigned int tx, ty )
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef, rRef;
    string strVar, strVar1;
    
    xRef = <device CKEB @[lsx+1,lsy+1]  of ARCHITECTURE>;
    sprintf(strVar, "CKEB_%d_%d", lsx+1, lsy+1);
    device CKEB  ( symbol logsym_n )  *strVar  @[gsx+1000,gsy+920];
    map
    (
         <instance *strVar>   => xRef
    );
    
    rRef = <device CKEBMUX @[lsx+1,lsy+2]  of ARCHITECTURE>;
    sprintf(strVar1, "CKEBMUX_%d_%d", lsx+1, lsy+2);
    device CKEBMUX  ( symbol logsym )  *strVar1  @[gsx+600,gsy+900];
    map 
    ( 
         <instance *strVar1>   => rRef
     );
}   // end of function draw_wlsr2_tile

function draw_wlsra_tile( unsigned int tx, ty )
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef, rRef;
    string strVar, strVar1;
    
    xRef = <device CKEB @[lsx+1,lsy+1]  of ARCHITECTURE>;
    sprintf(strVar, "CKEB_%d_%d", lsx+1, lsy+1);
    device CKEB  ( symbol logsym_n )  *strVar  @[gsx+1000,gsy+920];
    map
    (
         <instance *strVar>   => xRef
    );
    
    rRef = <device CKEBMUX @[lsx+1,lsy+2]  of ARCHITECTURE>;
    sprintf(strVar1, "CKEBMUX_%d_%d", lsx+1, lsy+2);
    device CKEBMUX  ( symbol logsym )  *strVar1  @[gsx+600,gsy+900];
    map 
    ( 
         <instance *strVar1>   => rRef
     );
}   // end of function draw_wlsra_tile

function draw_wlsrd_tile( unsigned int tx, ty )
{
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef, rRef;
    string strVar, strVar1;
    
    xRef = <device CKEB @[lsx+1,lsy+1]  of ARCHITECTURE>;
    sprintf(strVar, "CKEB_%d_%d", lsx+1, lsy+1);
    device CKEB  ( symbol logsym_n )  *strVar  @[gsx+1000,gsy+920];
    map
    (
         <instance *strVar>   => xRef
    );
    
    rRef = <device CKEBMUX @[lsx+1,lsy+2]  of ARCHITECTURE>;
    sprintf(strVar1, "CKEBMUX_%d_%d", lsx+1, lsy+2);
    device CKEBMUX  ( symbol logsym )  *strVar1  @[gsx+600,gsy+900];
    map 
    ( 
         <instance *strVar1>   => rRef
     );
}   // end of function draw_wlsrd_tile

//function draw_iockgatedll_tile_new(unsigned int tx,ty)
//{   
//    // Site index variable. The X index for logic and GUI are declared separately
//    unsigned int lsx, lsy, gsx, gsy;
//    
//    lsx = tx * NUM_GRID_X + 2;
//    lsy = ty * NUM_GRID_Y;
//    
//    unsigned int temp_ty;
//    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
//    {
//        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
//    }
//    
//    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
//    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
//    
//    // device reference variables
//    &device xRef;
//    string strVar;
//    
//    unsigned int dt, dx, dy;
//    
//    for ( dt = 0; dt < 2; dt += 1 )
//    {
//        // Part1.1
//        gsy = gsy + 1200;
//        
//        dx = 0;
//        dy = 2 - 2*dt;
//        xRef = <device IOCKDLYMUX  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//        sprintf(strVar, "IOCKDLYMUX_%d_%d", lsx+dx, lsy+dy);
//        device IOCKDLYMUX  ( symbol sym )  *strVar  @[gsx+700,gsy+280+300*dt];
//        map 
//        (
//             <instance *strVar>   => xRef
//        );
//        
//        dy = 3 - 2*dt;
//        xRef = <device IOCKDLYMUX  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//        sprintf(strVar, "IOCKDLYMUX_%d_%d", lsx+dx, lsy+dy);
//        device IOCKDLYMUX  ( symbol sym )  *strVar  @[gsx+700,gsy+400+300*dt];
//        map 
//        (
//             <instance *strVar>   => xRef
//        );
//        
//        dy = 6 - 2*dt;
//        xRef = <device IOCKDLY  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//        sprintf(strVar, "IOCKDLY_%d_%d", lsx+dx, lsy+dy);
//        device IOCKDLY  ( symbol sym )  *strVar  @[gsx+750,gsy+300+300*dt];
//        map 
//        (
//             <instance *strVar>   => xRef
//        );
//        
//        dy = 7 - 2*dt;
//        xRef = <device IOCKDLY  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//        sprintf(strVar, "IOCKDLY_%d_%d", lsx+dx, lsy+dy);
//        device IOCKDLY  ( symbol sym )  *strVar  @[gsx+750,gsy+420+300*dt];
//        map 
//        (
//             <instance *strVar>   => xRef
//        );
//        
//        // Part1.2
//        dy = 0 + dt;
//        xRef = <device IOCKGMUX  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//        sprintf(strVar, "IOCKGMUX_%d_%d", lsx+dx, lsy+dy);
//        device IOCKGMUX  ( symbol sym )  *strVar  @[gsx+800,gsy+280+300*dt];
//        map 
//        (
//             <instance *strVar>   => xRef
//        );
//        
//        dy = 2 + dt;
//        xRef = <device IOCKGMUX_TEST  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//        sprintf(strVar, "IOCKGMUX_TEST_%d_%d", lsx+dx, lsy+dy);
//        device IOCKGMUX_TEST  ( symbol sym )  *strVar  @[gsx+800,gsy+400+300*dt];
//        map 
//        (
//             <instance *strVar>   => xRef
//        );
//        
//        dx =  1 - dt;
//        dy = 10 - 9*dt;
//        xRef = <device IOCKGMUX_OUT  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//        sprintf(strVar, "IOCKGMUX_OUT_%d_%d", lsx+dx, lsy+dy);
//        device IOCKGMUX_OUT  ( symbol sym )  *strVar  @[gsx+850,gsy+340+300*dt];
//        map 
//        (
//             <instance *strVar>   => xRef
//        );
//        
//        // Part1.3
//        dx = 0;
//        
//        dy = dt;
//        xRef = <device IOCKGATE  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//        sprintf(strVar, "IOCKGATE_%d_%d", lsx+dx, lsy+dy);
//        device IOCKGATE  ( symbol sym )  *strVar  @[gsx+900,gsy+360+300*dt];
//        map 
//        (
//             <instance *strVar>   => xRef
//        );
//        
//        dy = 8 + dt;
//        xRef = <device IOCKDIV  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//        sprintf(strVar, "IOCKDIV_%d_%d", lsx+dx, lsy+dy);
//        device IOCKDIV  ( symbol sym )  *strVar  @[gsx+950,gsy+360+300*dt];
//        map 
//        (
//             <instance *strVar>   => xRef
//        );
//        
//        // Part2.1
//        gsy = gsy - 1200;
//        
//        dy = dt;
//        xRef = <device RCKBMUX  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//        sprintf(strVar, "RCKBMUX_%d_%d", lsx+dx, lsy+dy);
//        device RCKBMUX  ( symbol sym )  *strVar  @[gsx+800,gsy+280+2400*dt];
//        map 
//        (
//             <instance *strVar>   => xRef
//        );
//        
//        dy = 10 + dt;
//        xRef = <device RCKBMUX_TEST  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//        sprintf(strVar, "RCKBMUX_TEST_%d_%d", lsx+dx, lsy+dy);
//        device RCKBMUX_TEST  ( symbol sym )  *strVar  @[gsx+800,gsy+400+2400*dt];
//        map 
//        (
//             <instance *strVar>   => xRef
//        );
//        
//        dx = 1;
//        dy = 11 - 3*dt;
//        xRef = <device RCKBMUX_OUT  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//        sprintf(strVar, "RCKBMUX_OUT_%d_%d", lsx+dx, lsy+dy);
//        device RCKBMUX_OUT  ( symbol sym )  *strVar  @[gsx+850,gsy+340+2400*dt];
//        map 
//        (
//             <instance *strVar>   => xRef
//        );
//        
//        // Part2.2
//        dx = 0;
//        dy = dt;
//        xRef = <device VCKBMUX  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//        sprintf(strVar, "VCKBMUX_%d_%d", lsx+dx, lsy+dy);
//        device VCKBMUX  ( symbol sym )  *strVar  @[gsx+800,gsy+580+2400*dt];
//        map 
//        (
//             <instance *strVar>   => xRef
//        );
//        
//        dx = 1;
//        dy = dt;
//        xRef = <device VCKBMUX_TEST  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//        sprintf(strVar, "VCKBMUX_TEST_%d_%d", lsx+dx, lsy+dy);
//        device VCKBMUX_TEST  ( symbol sym )  *strVar  @[gsx+800,gsy+700+2400*dt];
//        map 
//        (
//             <instance *strVar>   => xRef
//        );
//        
//        dx = dt;
//        dy = 9*dt;
//        xRef = <device VCKBMUX_OUT  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//        sprintf(strVar, "VCKBMUX_OUT_%d_%d", lsx+dx, lsy+dy);
//        device VCKBMUX_OUT  ( symbol sym )  *strVar  @[gsx+850,gsy+640+2400*dt];
//        map 
//        (
//             <instance *strVar>   => xRef
//        );
//        
//        // Part2.3
//        dx = 1;
//        
//        dy = 6 + dt;
//        xRef = <device RCKB  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//        sprintf(strVar, "RCKB_%d_%d", lsx+dx, lsy+dy);
//        device RCKB  ( symbol sym )  *strVar  @[gsx+900,gsy+360+2400*dt];
//        map 
//        (
//             <instance *strVar>   => xRef
//        );
//        
//        dy = 4 + dt;
//        xRef = <device RCKB  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//        sprintf(strVar, "RCKB_%d_%d", lsx+dx, lsy+dy);
//        device RCKB  ( symbol sym )  *strVar  @[gsx+900,gsy+660+2400*dt];
//        map 
//        (
//             <instance *strVar>   => xRef
//        );
//    }
//    
//    gsy = gsy + 1200;    
//    
//    dx = 1;
//    dy = 3;
//    xRef = <device DLL  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//    sprintf(strVar, "DLL_%d_%d", lsx+dx, lsy+dy);
//    device DLL  ( symbol sym )  *strVar  @[gsx+400,gsy+400];
//    map 
//    (
//         <instance *strVar>   => xRef
//    );
//    
//    dx = 0;
//    dy = 0;
//    xRef = <device DLLMUX  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//    sprintf(strVar, "DLLMUX_%d_%d", lsx+dx, lsy+dy);
//    device DLLMUX  ( symbol sym )  *strVar  @[gsx+300,gsy+490];
//    map 
//    (
//         <instance *strVar>   => xRef
//    );
//    
//    dx = 0;
//    dy = 0;
//    xRef = <device CKEB  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
//    sprintf(strVar, "CKEB_%d_%d", lsx+dx, lsy+dy);
//    device CKEB  ( symbol logsym_n )  *strVar  @[gsx+1000,gsy+920];
//    map 
//    (
//         <instance *strVar>   => xRef
//    );
//    
//    xRef = <device CKEBMUX @[lsx+0,lsy+0]  of ARCHITECTURE>;
//    sprintf(strVar, "CKEBMUX_%d_%d", lsx+0, lsy+0);
//    device CKEBMUX  ( symbol logsym )  *strVar  @[gsx+600,gsy+900];
//    map 
//    ( 
//         <instance *strVar>   => xRef
//     );
//}  // end of function draw_iockgatedll_tile_new

function draw_rckb_tile(unsigned int tx,ty)
{   
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X + 2;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef;
    string strVar;
    
    unsigned int dt, dx, dy;
    
    for ( dt = 0; dt < 2; dt += 1 )
    {
        // Part1.1
        dx = 0;
        dy = dt;
        xRef = <device RCKBMUX  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "RCKBMUX_%d_%d", lsx+dx, lsy+dy);
        device RCKBMUX  ( symbol sym )  *strVar  @[gsx+800,gsy+280+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        dy = 10 + dt;
        xRef = <device RCKBMUX_TEST  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "RCKBMUX_TEST_%d_%d", lsx+dx, lsy+dy);
        device RCKBMUX_TEST  ( symbol sym )  *strVar  @[gsx+800,gsy+400+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        dx = 1;
        dy = 11 - 3*dt;
        xRef = <device RCKBMUX_OUT  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "RCKBMUX_OUT_%d_%d", lsx+dx, lsy+dy);
        device RCKBMUX_OUT  ( symbol sym )  *strVar  @[gsx+850,gsy+340+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        // Part1.2
        dx = 0;
        dy = dt;
        xRef = <device VCKBMUX  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "VCKBMUX_%d_%d", lsx+dx, lsy+dy);
        device VCKBMUX  ( symbol sym )  *strVar  @[gsx+800,gsy+580+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        dx = 1;
        dy = dt;
        xRef = <device VCKBMUX_TEST  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "VCKBMUX_TEST_%d_%d", lsx+dx, lsy+dy);
        device VCKBMUX_TEST  ( symbol sym )  *strVar  @[gsx+800,gsy+700+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        dx = dt;
        dy = 9*dt;
        xRef = <device VCKBMUX_OUT  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "VCKBMUX_OUT_%d_%d", lsx+dx, lsy+dy);
        device VCKBMUX_OUT  ( symbol sym )  *strVar  @[gsx+850,gsy+640+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        // Part1.3
        dx = 1;
        
        dy = 6 + dt;
        xRef = <device RCKB  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "RCKB_%d_%d", lsx+dx, lsy+dy);
        device RCKB  ( symbol sym )  *strVar  @[gsx+900,gsy+360+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        dy = 4 + dt;
        xRef = <device RCKB  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "RCKB_%d_%d", lsx+dx, lsy+dy);
        device RCKB  ( symbol sym )  *strVar  @[gsx+900,gsy+660+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
    }
    
    gsy = gsy + 1200;    
    
    dx = 0;
    dy = 0;
    xRef = <device CKEB  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
    sprintf(strVar, "CKEB_%d_%d", lsx+dx, lsy+dy);
    device CKEB  ( symbol logsym_n )  *strVar  @[gsx+1000,gsy+920];
    map 
    (
         <instance *strVar>   => xRef
    );
    
    xRef = <device CKEBMUX @[lsx+0,lsy+0]  of ARCHITECTURE>;
    sprintf(strVar, "CKEBMUX_%d_%d", lsx+0, lsy+0);
    device CKEBMUX  ( symbol logsym )  *strVar  @[gsx+600,gsy+900];
    map 
    ( 
         <instance *strVar>   => xRef
     );
}  // end of function draw_rckb_tile

function draw_rckb_soc_tile(unsigned int tx,ty)
{   
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X + 2;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef;
    string strVar;
    
    unsigned int dt, dx, dy;
    
    for ( dt = 0; dt < 2; dt += 1 )
    {
        // Part1.1
        dx = 0;
        dy = dt;
        xRef = <device RCKBMUX  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "RCKBMUX_%d_%d", lsx+dx, lsy+dy);
        device RCKBMUX  ( symbol sym )  *strVar  @[gsx+800,gsy+280+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        dy = 10 + dt;
        xRef = <device RCKBMUX_TEST  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "RCKBMUX_TEST_%d_%d", lsx+dx, lsy+dy);
        device RCKBMUX_TEST  ( symbol sym )  *strVar  @[gsx+800,gsy+400+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        dx = 1;
        dy = 11 - 3*dt;
        xRef = <device RCKBMUX_OUT  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "RCKBMUX_OUT_%d_%d", lsx+dx, lsy+dy);
        device RCKBMUX_OUT  ( symbol sym )  *strVar  @[gsx+850,gsy+340+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        // Part1.2
        dx = 0;
        dy = dt;
        xRef = <device VCKBMUX  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "VCKBMUX_%d_%d", lsx+dx, lsy+dy);
        device VCKBMUX  ( symbol sym )  *strVar  @[gsx+800,gsy+580+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        dx = 1;
        dy = dt;
        xRef = <device VCKBMUX_TEST  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "VCKBMUX_TEST_%d_%d", lsx+dx, lsy+dy);
        device VCKBMUX_TEST  ( symbol sym )  *strVar  @[gsx+800,gsy+700+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        dx = dt;
        dy = 9*dt;
        xRef = <device VCKBMUX_OUT  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "VCKBMUX_OUT_%d_%d", lsx+dx, lsy+dy);
        device VCKBMUX_OUT  ( symbol sym )  *strVar  @[gsx+850,gsy+640+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        // Part1.3
        dx = 1;
        
        dy = 6 + dt;
        xRef = <device RCKB  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "RCKB_%d_%d", lsx+dx, lsy+dy);
        device RCKB  ( symbol sym )  *strVar  @[gsx+900,gsy+360+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
        
        dy = 4 + dt;
        xRef = <device RCKB  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
        sprintf(strVar, "RCKB_%d_%d", lsx+dx, lsy+dy);
        device RCKB  ( symbol sym )  *strVar  @[gsx+900,gsy+660+2400*dt];
        map 
        (
             <instance *strVar>   => xRef
        );
    }
    
    gsy = gsy + 1200;    
    
    dx = 0;
    dy = 0;
    xRef = <device CKEB  @[lsx+dx,lsy+dy]  of ARCHITECTURE>;
    sprintf(strVar, "CKEB_%d_%d", lsx+dx, lsy+dy);
    device CKEB  ( symbol logsym_n )  *strVar  @[gsx+1000,gsy+920];
    map 
    (
         <instance *strVar>   => xRef
    );
    
    xRef = <device CKEBMUX @[lsx+0,lsy+0]  of ARCHITECTURE>;
    sprintf(strVar, "CKEBMUX_%d_%d", lsx+0, lsy+0);
    device CKEBMUX  ( symbol logsym )  *strVar  @[gsx+600,gsy+900];
    map 
    ( 
         <instance *strVar>   => xRef
     );
}  // end of function draw_rckb_soc_tile


function draw_soc_tile(unsigned int tx,ty)
{   
    // Site index variable. The X index for logic and GUI are declared separately
    unsigned int lsx, lsy, gsx, gsy;
    
    lsx = tx * NUM_GRID_X;
    lsy = ty * NUM_GRID_Y;
    
    unsigned int temp_ty;
    for(temp_ty = ty;temp_ty > MID_TILE_REGION;temp_ty = temp_ty - NUM_TILES_REGION)
    {
        lsy = lsy + NUM_GRID_WLSR_Y - NUM_GRID_Y;
    }
    
    gsx = (lsx/NUM_GRID_X) * TILE_NUM_GUI_GRID_X;
    gsy = (lsy/NUM_GRID_Y) * TILE_NUM_GUI_GRID_Y;
    
    // device reference variables
    &device xRef;
    string strVar;
    
    gsx -= 2400;
    
    xRef = <device SOC @[lsx,lsy] of ARCHITECTURE>;
    sprintf(strVar, "SOC_%d_%d", lsx, lsy);
    device SOC ( symbol logsym ) *strVar @[gsx+800,gsy+200];
    map 
    (
        <instance *strVar> => xRef
    );
}  // end of function draw_soc_tile

};