tarted
grid
device IOLHR
{
    // grid_property_def_start
    // grid_property_def_end

    parameter
    (
        config string CP_DYN_CLKDIVPOL = "FALSE",
        config string CP_OVERSAMPLE_EN = "FALSE",
        config string CP_DYN_CLKPOL = "FALSE",
        config string CP_IHSMEM_EN = "FALSE",
        config string CP_OCLKBPOL = "FALSE",
        config string CP_OCLKPOL = "FALSE",
        config string CP_CLK_POL0 = "FALSE",
        config string CP_CLK_POL1 = "FALSE",
        config string CP_CLK_POL2 = "FALSE",
        config string CP_CLK_POL3 = "FALSE",
        config string CP_LSMEM_EN = "FALSE",
        config string CP_OPPOSITE_EN = "FALSE",
        config string CP_CLK_POL4 = "FALSE",
        config string CP_CLK_POL5 = "FALSE",
        config string CP_CLK_POL6 = "FALSE",
        config string CP_IDLY_EN = "FALSE",
        config bit CP_IDLY_SET[7:0] = 8'b00000000,
        config string CP_IDYN_EN = "FALSE",
        config string CP_ZHOLD_EN = "FALSE",
        config bit CP_ZHOLD_SET[3:0] = 4'b0000,
        config string CP_ODLY_EN = "FALSE",
        config bit CP_ODLY_SET[7:0] = 8'b00000000,
        config string CP_ODYN_EN = "FALSE",
        config bit CP_GRS_DIS = 1'b0,
        config string CP_D_POL0 = "FALSE",
        config string CP_D_POL1 = "FALSE",
        config bit CP_D_SEL0 = 1'b0,
        config bit CP_D_SEL1 = 1'b0,
        config bit CP_D_SEL2 = 1'b0,
        config bit CP_D_SEL3 = 1'b0,
        config bit CP_D_SEL4[1:0] = 2'b00,
        config bit CP_D_SEL5[1:0] = 2'b00,
        config bit CP_D_SEL6[1:0] = 2'b00,
        config string CP_TEST_EN0 = "FALSE",
        config string CP_TEST_EN1 = "FALSE",
        config string CP_MIPI_EN = "FALSE",
        config string CP_DDRI_EN = "FALSE",
        config string CP_DES_DDREN = "FALSE",
        config string CP_DES_SDREN = "FALSE",
        config string CP_ISERDES_MODE = "SDR1TO2",
        config string CP_SAMEPIPELINE_EN = "FALSE",
        config string CP_ISAME_EN = "FALSE",
        config string CP_IOPPOSITE_EN = "FALSE",
        config string CP_IDFFEN = "FALSE",
        config string CP_ILTHEN = "FALSE",
        config string CP_MASTER = "MASTER",
        config string CP_NETWORKING_EN = "FALSE",
        config string CP_BITSLIP_EN = "FALSE",
        config string CP_ISR_POL = "FALSE",
        config string CP_ISR_SYNC = "ASYNC",
        config string CP_ISR_EN = "FALSE",
        config bit CP_NUM_ICE = 1'b0,
        config string CP_IFIFO_EN = "FALSE",
        config bit CP_INIT_Q0 = 1'b0,
        config bit CP_INIT_Q1 = 1'b0,
        config bit CP_INIT_Q2 = 1'b0,
        config bit CP_INIT_Q3 = 1'b0,
        config string CP_SRVAL_Q0 = "RESET",
        config string CP_SRVAL_Q1 = "RESET",
        config string CP_SRVAL_Q2 = "RESET",
        config string CP_SRVAL_Q3 = "RESET",
        config string CP_OSR_POL = "FALSE",
        config string CP_O_SYNC = "ASYNC",
        config string CP_SRO_EN = "FALSE",
        config bit CP_INIT_DQ = 1'b0,
        config string CP_SRVAL_DQ0 = "RESET",
        config string CP_SRVAL_DQ1 = "RESET",
        config string CP_SRVAL_DQ2 = "RESET",
        config string CP_SRVAL_DQ3 = "RESET",
        config string CP_PDIFF = "FALSE",
        config string CP_OSERDES_EN = "FALSE",
        config string CP_OSERDES_MODE = "SDR2TO1",
        config string CP_SER_SDREN = "FALSE",
        config string CP_SER_DDREN = "FALSE",
        config string CP_OHSMEM_EN = "FALSE",
        config string CP_ODFFEN = "FALSE",
        config string CP_OLTHEN = "FALSE",
        config string CP_OCASCADE_EN = "FALSE",
        config bit CP_DO_SEL = 1'b0,
        config string CP_UPD0_SHIFTEN = "FALSE",
        config string CP_UPD1_SHIFTEN = "FALSE",
        config bit CP_DQMODE[1:0] = 2'b00,
        config bit CP_INIT_SET[1:0] = 2'b00,
        config string CP_T_SYNC = "ASYNC",
        config string CP_SRT_EN = "FALSE",
        config bit CP_INIT_TQ = 1'b0,
        config string CP_SRVAL_TQ0 = "RESET",
        config string CP_SRVAL_TQ1 = "RESET",
        config string CP_SRVAL_TQ2 = "RESET",
        config string CP_SRVAL_TQ3 = "RESET",
        config string CP_TBYTE_EN = "FALSE",
        config string CP_TRI_EN = "FALSE",
        config bit CP_TQMODE[1:0] = 2'b00
    );
    port
    (
// configuration_body_def_on


    config input SC_DYN_CLKPOL = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_DYN_CLKPOL" */,

    config input SC_DYN_CLKDIVPOL = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_DYN_CLKDIVPOL" */,

    config input SC_CLK_POL0 = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_CLK_POL0" */,

    config input SC_CLK_POL1 = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_CLK_POL1" */,

    config input SC_CLK_POL2 = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_CLK_POL2" */,

    config input SC_CLK_POL3 = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_CLK_POL3" */,

    config input SC_OCLKPOL = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_OCLKPOL" */,

    config input SC_OCLKBPOL = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_OCLKBPOL" */,

    config input SC_LSMEM_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_LSMEM_EN" */,

    config input SC_IHSMEM_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_IHSMEM_EN" */,

    config input SC_OVERSAMPLE_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_OVERSAMPLE_EN" */,

    config input SC_D_POL0 = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_D_POL0" */,

    config input SC_D_POL1 = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_D_POL1" */,

    config input SC_D_SEL0 = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_D_SEL0" */,

    config input SC_D_SEL1 = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_D_SEL1" */,

    config input SC_D_SEL2 = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_D_SEL2" */,

    config input SC_D_SEL3 = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_D_SEL3" */,

    config input SC_D_SEL4[1:0] = 2'h0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_D_SEL4[1],SC_D_SEL4[0]" */,

    config input SC_D_SEL5[1:0] = 2'h0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_D_SEL5[1],SC_D_SEL5[0]" */,

    config input SC_D_SEL6[1:0] = 2'h0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_D_SEL6[1],SC_D_SEL6[0]" */,

    config input SC_TEST_EN0 = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_TEST_EN0" */,

    config input SC_TEST_EN1 = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_TEST_EN1" */,

    config input SC_MIPI_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_MIPI_EN" */,

    config input SC_DDRI_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_DDRI_EN" */,

    config input SC_DES_DDREN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_DES_DDREN" */,

    config input SC_DES_SDREN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_DES_SDREN" */,

    config input SC_ISERDES_MODE[3:0] = 4'h0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_ISERDES_MODE[3],SC_ISERDES_MODE[2],SC_ISERDES_MODE[1],SC_ISERDES_MODE[0]" */,

    config input SC_SAMEPIPELINE_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_SAMEPIPELINE_EN" */,

    config input SC_ISAME_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_ISAME_EN" */,

    config input SC_IOPPOSITE_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_IOPPOSITE_EN" */,

    config input SC_ILTHEN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_ILTHEN" */,

    config input SC_IDFFEN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_IDFFEN" */,

    config input SC_MASTER = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_MASTER" */,

    config input SC_NETWORKING_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_NETWORKING_EN" */,

    config input SC_BITSLIP_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_BITSLIP_EN" */,

    config input SC_ISR_POL = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_ISR_POL" */,

    config input SC_ISR_SYNC = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_ISR_SYNC" */,

    config input SC_ISR_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_ISR_EN" */,

    config input SC_GRS_DIS = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_GRS_DIS" */,

    config input SC_NUM_ICE = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_NUM_ICE" */,

    config input SC_IFIFO_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_IFIFO_EN" */,

    config input SC_INIT_Q[3:0] = 4'h0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_INIT_Q[3],SC_INIT_Q[2],SC_INIT_Q[1],SC_INIT_Q[0]" */,

    config input SC_SRVAL_Q[3:0] = 4'h0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_SRVAL_Q[3],SC_SRVAL_Q[2],SC_SRVAL_Q[1],SC_SRVAL_Q[0]" */,

    config input SC_IDLY_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_IDLY_EN" */,

    config input SC_ZHOLD_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_ZHOLD_EN" */,

    config input SC_ZHOLD_SET[3:0] = 4'h0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_ZHOLD_SET[3],SC_ZHOLD_SET[2],SC_ZHOLD_SET[1],SC_ZHOLD_SET[0]" */,

    config input SC_IDYN_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_IDYN_EN" */,

    config input SC_IDLY_SET[7:0] = 8'h0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_IDLY_SET[7],SC_IDLY_SET[6],SC_IDLY_SET[5],SC_IDLY_SET[4],SC_IDLY_SET[3],SC_IDLY_SET[2],SC_IDLY_SET[1],SC_IDLY_SET[0]" */,

    config input SC_OSR_POL = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_OSR_POL" */,

    config input SC_SRO_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_SRO_EN" */,

    config input SC_O_SYNC = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_O_SYNC" */,

    config input SC_SRT_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_SRT_EN" */,

    config input SC_T_SYNC = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_T_SYNC" */,

    config input SC_CLK_POL4 = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_CLK_POL4" */,

    config input SC_CLK_POL5 = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_CLK_POL5" */,

    config input SC_CLK_POL6 = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_CLK_POL6" */,

    config input SC_OPPOSITE_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_OPPOSITE_EN" */,

    config input SC_OHSMEM_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_OHSMEM_EN" */,

    config input SC_OSERDES_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_OSERDES_EN" */,

    config input SC_SER_DDREN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_SER_DDREN" */,

    config input SC_SER_SDREN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_SER_SDREN" */,

    config input SC_OLTHEN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_OLTHEN" */,

    config input SC_ODFFEN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_ODFFEN" */,

    config input SC_OSERDES_MODE[3:0] = 4'h0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_OSERDES_MODE[3],SC_OSERDES_MODE[2],SC_OSERDES_MODE[1],SC_OSERDES_MODE[0]" */,

    config input SC_UPD0_SHIFTEN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_UPD0_SHIFTEN" */,

    config input SC_UPD1_SHIFTEN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_UPD1_SHIFTEN" */,

    config input SC_INIT_SET[1:0] = 2'h0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_INIT_SET[1],SC_INIT_SET[0]" */,

    config input SC_ODYN_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_ODYN_EN" */,

    config input SC_ODLY_SET[7:0] = 8'h0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_ODLY_SET[7],SC_ODLY_SET[6],SC_ODLY_SET[5],SC_ODLY_SET[4],SC_ODLY_SET[3],SC_ODLY_SET[2],SC_ODLY_SET[1],SC_ODLY_SET[0]" */,

    config input SC_INIT_DQ = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_INIT_DQ" */,

    config input SC_SRVAL_DQ[3:0] = 4'h0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_SRVAL_DQ[3],SC_SRVAL_DQ[2],SC_SRVAL_DQ[1],SC_SRVAL_DQ[0]" */,

    config input SC_INIT_TQ = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_INIT_TQ" */,

    config input SC_SRVAL_TQ[3:0] = 4'h0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_SRVAL_TQ[3],SC_SRVAL_TQ[2],SC_SRVAL_TQ[1],SC_SRVAL_TQ[0]" */,

    config input SC_PDIFF = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_PDIFF" */,

    config input SC_DO_SEL = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_DO_SEL" */,

    config input SC_OCASCADE_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_OCASCADE_EN" */,

    config input SC_DQMODE[1:0] = 2'h0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_DQMODE[1],SC_DQMODE[0]" */,

    config input SC_TQMODE[1:0] = 2'h0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_TQMODE[1],SC_TQMODE[0]" */,

    config input SC_TRI_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_TRI_EN" */,

    config input SC_ODLY_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_ODLY_EN" */,

    config input SC_TBYTE_EN = 1'b0
    /* pragma  PAP_CFG_BIT_NAME  = "SC_TBYTE_EN" */,

// configuration_body_def_end

        input IFIFO_WADDR[2:0] = 3'b111,
        input IFIFO_RADDR[2:0] = 3'b111,
        input TX_DATA[7:0] = 8'b1111_1111,
        input TS_CTRL[1:0] = 2'b11,
        input IDLY_DYN_SET[7:0] = 8'b1111_1111,
        input ODLY_DYN_SET[7:0] = 8'b1111_1111,
        input DI = 1'b1,
        input DI_N = 1'b1,
        input DI_MIPI = 1'b1,
        input DI_FROM_SRB = 1'b1,
        input ISHIFTIN0 = 1'b1,
        input ISHIFTIN1 = 1'b1,
        input BITSLIP = 1'b1,
        input ISR_IOLHR = 1'b1,
        input ICE0 = 1'b1,
        input ICE1 = 1'b1,
        input DYN_CLKPOL = 1'b1,
        input DYN_CLKDIVPOL = 1'b1,
        input ICLK = 1'b1,
        input ICLKB = 1'b1,
        input DESCLK = 1'b1,
        input SERCLK = 1'b1,
        input SERCLKB = 1'b1,
        input OCLK = 1'b1,
        input OCLKB = 1'b1,
        input ICLKDIV = 1'b1,
        input OCLKDIV = 1'b1,
        input OCLKDIVB = 1'b1,
        input OSHIFTIN0 = 1'b0,
        input OSHIFTIN1 = 1'b0,
        input OSR_IOLHR = 1'b1,
        input OCE = 1'b1,
        input UPD0_SHIFT = 1'b1,
        input UPD1_SHIFT = 1'b1,
        input DO_CAS_IN = 1'b1,
        input INBUF_DYN_DIS_N_I = 1'b1,
        input MIPI_SW_DYN_I = 1'b1,
        input TCE = 1'b1,
        input TERM_BYTEIN = 1'b1,
        input T_BYTEIN = 1'b1,
        input TO_CAS_IN = 1'b1,
        input TERM_CAS_IN = 1'b1,
        input IDLY_SEL = 1'b1,
        input ODLY_SEL = 1'b1,
        output RX_DATA[7:0],
        output ISHIFTOUT0,
        output ISHIFTOUT1,
        output DI_TO_CLK,
        output DI_TO_CLKB,
        output RSTN_OUT,
        output MIPI_SW_DYN_O,
        output INBUF_DYN_DIS_N_O,
        output DO_P,
        output DO_N,
        output OSHIFTOUT0,
        output OSHIFTOUT1,
        output OFB,
        output DO_CAS_OUT,
        output TERM,
        output TERM_CAS_OUT,
        output TO_CAS_OUT
    );
};
//grid device end

//grid device structure netlist started
structure netlist of IOLHR
{

    wire       ntDI_O0;
    wire       ntDI_O1;
    wire       ntDI_O2;
    wire       ntZHOLD_O0;
    wire       ntZHOLD_O1;
    wire       ntM0_REG;
    wire       ntM1_REG;
    wire       ntM2_REG;
    wire       ntM3_REG;
    wire       ntM0;
    wire       ntM1;
    wire       ntM2;

    wire       ntDLY_ZHOLD;
    wire       ntDLY_ODLY;
//    wire       DI_TO_GEAR;

    wire       ntCLK_STG0;
    wire       ntCLKB_STG0;
    wire       ntHSMEM_CLK;
    wire       ntHSMEM_CLKB;
    wire       ntCLK_STG1_0;
    wire       ntCLK_STG1_1;
    wire       ntCLK_STG1_2;
    wire       ntCLK_STG2_0;
    wire       ntCLK_STG2_1;
    wire       ntCLK_STG3;
    wire       ntCLK_FOR_BS;
    wire       ntCLK_STG4;
    wire       ntCLK_STG5;
    wire       ntCLK_STG6_0;
    wire       ntCLK_STG6_1;
    wire       ntCLK_STG6_2;
    wire       ntISR;
    wire       ntOSR;
    wire       ntTO;
    wire       ntQ_SHF0; 
    wire       ntQ_SHF1;
    wire       ntDO_DDR;
    wire       ntDO_SDR;
    wire       ntDO_DD;
    wire       ntBSCLK;
    
    wire       ntDLY_IDLY;
    // for inter connect net
    wire       ntDO_R;
    wire       ntOFB_REG;
    wire       ntTO_DDR;
    wire       ntTERM_DDR;
    
    // for input port net
    wire       ntINBUF_DYN_DIS_N;
    wire       ntMIPI_SW_DYN;
    wire       ntBITSLIP;
    wire       ntISHIFTIN0;
    wire       ntISHIFTIN1;

//    wire       ntGRS_N;
    wire       ntISR_IOLHR;

    wire       ntIDLY_SEL    ;

    wire       ntODLY_SEL;

    wire       ntDESCLK;
    wire       ntICLK;
    wire       ntICLKB;
    wire       ntOCLK;
    wire       ntOCLKB;
    wire       ntICLKDIV;
    wire       ntDYN_CLKPOL;
    wire       ntDYN_CLKDIVPOL;
    wire       ntICE0;
    wire       ntICE1;
    wire       ntDO_CAS_IN;
    wire       ntOSR_IOLHR;
    wire       ntTO_CAS_IN;
    wire       ntTERM_BYTEIN;
    wire       ntOCLKDIV    ; 
    wire       ntOCLKDIVB   ; 
    wire       ntSERCLK     ; 
    wire       ntSERCLKB    ; 
    wire       ntDI;
    wire       ntDI_N;
    wire       ntDI_FROM_SRB;
    wire       ntTERM_CAS_IN;
    wire       ntOCE;

    wire       ntUPD0_SHIFT    ;
    wire       ntUPD1_SHIFT    ;
    wire       ntOSHIFTIN0     ;
    wire       ntOSHIFTIN1     ;
    wire       ntDI_MIPI       ;
    wire       ntTBYTE_IN      ;
    wire       ntTCE           ;
    
    
    // for output port
    wire       ntTFB;
    wire       ntTERM_FB;
    wire       ntRSTN_OUT;

    wire       ntISHIFTOUT0  ;   
    wire       ntISHIFTOUT1  ;
    wire       ntOFB         ;
    wire       ntDO_CAS_OUT  ;
    wire       ntDO_OUT;
    wire       ntDO_P  ;
    wire       ntDO_N  ;
    wire       ntTERM_OUT;
    wire       ntTERM;
    wire       ntOSHIFTOUT0  ;
    wire       ntOSHIFTOUT1  ;
    wire       ntTO_OUT      ;
    
    // connect to input port
    ntINBUF_DYN_DIS_N  <= INBUF_DYN_DIS_N_I;
    ntMIPI_SW_DYN      <= MIPI_SW_DYN_I;
    ntBITSLIP          <= BITSLIP;
    ntISHIFTIN0        <= ISHIFTIN0;
    ntISHIFTIN1        <= ISHIFTIN1; 
   // ntIFIFO_WADDR      <= IFIFO_WADDR;
   // ntIFIFO_RADDR      <= IFIFO_RADDR;
   // ntTS_CTRL          <= TS_CTRL;
//    ntGRS_N            <= GRS_N; 
    ntISR_IOLHR        <= ISR_IOLHR;
    ntTBYTE_IN         <= T_BYTEIN;
    //ntTX_DATA          <= TX_DATA;
    ntTCE              <= TCE    ;
    ntIDLY_SEL         <= IDLY_SEL;
    //ntIDLY_DYN_SET     <= IDLY_DYN_SET;
    ntODLY_SEL         <= ODLY_SEL;
    //ntODLY_DYN_SET     <= ODLY_DYN_SET;
    ntDESCLK           <= DESCLK;
    ntICLK             <= ICLK;
    ntICLKB            <= ICLKB;
    ntOCLK             <= OCLK;
    ntOCLKB            <= OCLKB;
    ntICLKDIV          <= ICLKDIV;
    ntDYN_CLKPOL       <= DYN_CLKPOL;
    ntDYN_CLKDIVPOL    <= DYN_CLKDIVPOL;
    ntICE0             <= ICE0;
    ntICE1             <= ICE1;
    ntDO_CAS_IN        <= DO_CAS_IN;
    ntOSR_IOLHR        <= OSR_IOLHR;
    ntTO_CAS_IN        <= TO_CAS_IN;
    ntTERM_BYTEIN      <= TERM_BYTEIN;
    ntOCLKDIV          <= OCLKDIV  ; 
    ntOCLKDIVB         <= OCLKDIVB ; 
    ntSERCLK           <= SERCLK   ; 
    ntSERCLKB          <= SERCLKB  ; 
    ntDI               <= DI       ;
    ntDI_N             <= DI_N     ;
    ntDI_FROM_SRB      <= DI_FROM_SRB;
    ntTERM_CAS_IN      <= TERM_CAS_IN;
    ntOCE              <= OCE;
    ntUPD0_SHIFT       <= UPD0_SHIFT ;
    ntUPD1_SHIFT       <= UPD1_SHIFT ;
    ntOSHIFTIN0        <= OSHIFTIN0  ;
    ntOSHIFTIN1        <= OSHIFTIN1  ;
    ntDI_MIPI          <= DI_MIPI    ;
     
  
  // connect to output port
    DI_TO_CLKB        <= ntM0 ;
    DI_TO_CLK         <= ntM1 ;
    TO_CAS_OUT        <= ntTFB;
    TERM_CAS_OUT      <= ntTERM_FB;    
    INBUF_DYN_DIS_N_O <= ntINBUF_DYN_DIS_N;
                                        
                                        
    MIPI_SW_DYN_O     <= ntMIPI_SW_DYN;
    RSTN_OUT          <= ntRSTN_OUT ;
    //RX_DATA           <= ntRX_DATA;
    ISHIFTOUT0        <= ntISHIFTOUT0  ;   
    ISHIFTOUT1        <= ntISHIFTOUT1  ;  
    OFB               <= ntOFB    ;
    DO_CAS_OUT        <= ntDO_CAS_OUT;
    DO_P              <= ntDO_P ;
    DO_N              <= ntDO_N;

    TERM              <= ntTERM;
    OSHIFTOUT0        <= ntOSHIFTOUT0   ;  
    OSHIFTOUT1        <= ntOSHIFTOUT1   ;
  
  
  //assign   DI_TO_FABRIC = ntM1;
  //assign   DI_TO_GEAR   = ntM2;
  //assign   DI_TO_IDLY   = ntM3_REG;

  //MUX2
    device MUX2TO1_P DIMUX0
    parameter map
    (
        CP_SEL => CP_D_SEL0
    ) 
    port map    
    (
        DOUT => ntDI_O0      , 
        DIN1 => ntDI         , 
        DIN0 => ntDI_N       
    );
        
    device MUX2TO1 DIMUX1
    parameter map
    (
        CP_POL   => CP_MIPI_EN,
        DIN1_POL => "FALSE"
    ) 
    port map
    (
        DOUT => ntDI_O1     , 
        DIN1 => ntDI_MIPI   , 
        DIN0 => ntDI_O0        
    );
        
    device MUX2TO1_P DIMUX2
    parameter map
    (
        CP_SEL => CP_D_SEL0
    )    
    port map    
    (
        DOUT => ntDI_O2     , 
        DIN1 => ntDI_N      , 
        DIN0 => ntDI     
    );
        
    device MUX2TO1 ZHOLDMUX0
    parameter map
    (
        CP_POL   => CP_D_POL0,
        DIN1_POL => "FALSE"
    )
    port map 
    (
        DOUT => ntZHOLD_O0   , 
        DIN1 => ntDLY_ZHOLD  ,   // input inv of  ntDLY_ZHOLD
        DIN0 => ntDLY_ZHOLD  
    );
        
    device MUX2TO1 ZHOLDMUX1
    parameter map
    (
        CP_POL   => CP_D_POL1,
        DIN1_POL => "TRUE"
    )
    port map 
    (
        DOUT => ntZHOLD_O1   , 
        DIN1 => ntDLY_ZHOLD , // input inv of  ntDLY_ZHOLD
        DIN0 => ntDLY_ZHOLD  
    );
    
    //MUX4
    device MUX4TO1_N M0_REGMUX
    parameter map
    (
        CP_D_SEL   => CP_D_SEL5,
        CP_POL_SEL => 1'b1
    )    
    port map 
    (
        DOUT => ntM0_REG    , 
        DIN3 => ntDI_O1     , 
        DIN2 => ntDLY_IDLY  , 
        DIN1 => ntDI_O0     , 
        DIN0 => ntZHOLD_O0  
    );
        
    device MUX4TO1 M1_REGMUX
    parameter map
    (
        CP_SEL   => CP_D_SEL5
    )    
    port map 
    (
        DOUT  => ntM1_REG    , 
        DIN3  => ntDI_O1     , 
        DIN2  => ntDLY_IDLY  ,  
        DIN1  => ntDI_O2     , 
        DIN0  => ntZHOLD_O0  
    );
        
    device MUX4TO1 M2_REGMUX
    parameter map
    (
        CP_SEL   => CP_D_SEL4
    )      
    port map 
    (
        DOUT => ntM2_REG    , 
        DIN3 => 1'b0      , 
        DIN2 => ntDLY_IDLY  ,  
        DIN1 => ntDI_O2     , 
        DIN0 => ntZHOLD_O1  
    );
        
    device MUX4TO1 M3_REGMUX
    parameter map
    (
        CP_SEL   => CP_D_SEL6
    )    
    port map 
    (
        DOUT => ntM3_REG    , 
        DIN3 => 1'b0        , 
        DIN2 => ntDO_CAS_OUT,
        DIN1 => ntDI_FROM_SRB , 
        DIN0 => ntDI_O2       
    );

    //MUX3
    device MUX3TO1_N M0MUX
    parameter map
    (
        CP_TEST_EN => CP_TEST_EN1,
        CP_D_SEL   => CP_D_SEL1  ,
        CP_POL_SEL => 1'b1
    ) 
    port map
    (
        DOUT => ntM0      , 
        TFB  => ntTFB       , 
        DIN1 => ntDO_CAS_OUT,
        DIN0 => ntM0_REG    
    );
        
    device MUX3TO1 M1MUX
    parameter map
    (
        CP_TEST_EN => CP_TEST_EN1,
        CP_D_SEL   => CP_D_SEL2
    ) 
    port map
    (
        DOUT => ntM1      , 
        TFB  => ntTFB       , 
        DIN1 => ntDO_CAS_OUT,
        DIN0 => ntM1_REG    
    );
        
    device MUX3TO1 M2MUX
    parameter map
    (
        CP_TEST_EN => CP_TEST_EN0,
        CP_D_SEL   => CP_D_SEL3
    ) 
    port map 
    (
        DOUT => ntM2      , 
        TFB  => ntTFB       , 
        DIN1 => ntDO_CAS_OUT,
        DIN0 => ntM2_REG    
    );
  
    device IOLHR_IL_CLKGEN  XIOLHR_IL_CLKGEN
    parameter map
    (    
        CP_DYN_CLKPOL    => CP_DYN_CLKPOL     ,    
        CP_DYN_CLKDIVPOL => CP_DYN_CLKDIVPOL  ,    
        CP_CLK_POL0      => CP_CLK_POL0       ,    
        CP_CLK_POL1      => CP_CLK_POL1       ,    
        CP_CLK_POL2      => CP_CLK_POL2       ,    
        CP_CLK_POL3      => CP_CLK_POL3       ,    
        CP_OCLKPOL       => CP_OCLKPOL        ,
        CP_OCLKBPOL      => CP_OCLKBPOL       ,    
        CP_LSMEM_EN      => CP_LSMEM_EN       ,    
        CP_IHSMEM_EN     => CP_IHSMEM_EN      ,    
        CP_OVERSAMPLE_EN => CP_OVERSAMPLE_EN   
    )
    port map
    (    
        DESCLK        => ntDESCLK        ,    
        ICLK          => ntICLK          ,    
        ICLKB         => ntICLKB         ,    
        BSCLK         => ntBSCLK         ,    
        OCLK          => ntOCLK          ,    
        OCLKB         => ntOCLKB         ,    
        ICLKDIV       => ntICLKDIV       ,    
        DYN_CLKPOL    => ntDYN_CLKPOL    ,    
        DYN_CLKDIVPOL => ntDYN_CLKDIVPOL ,    
        CLK_STG0      => ntCLK_STG0      ,    
        CLKB_STG0     => ntCLKB_STG0     ,    
        HSMEM_CLK     => ntHSMEM_CLK     ,    
        HSMEM_CLKB    => ntHSMEM_CLKB    ,    
        CLK_STG1_0    => ntCLK_STG1_0    ,    
        CLK_STG1_1    => ntCLK_STG1_1    ,    
        CLK_STG1_2    => ntCLK_STG1_2    ,    
        CLK_STG2_0    => ntCLK_STG2_0    ,    
        CLK_STG2_1    => ntCLK_STG2_1    ,    
        CLK_STG3      => ntCLK_STG3      ,    
        CLK_FOR_BS    => ntCLK_FOR_BS        
    );

    device IREG_IDDR XIREG_IDDR
    parameter map
    (    
        CP_ISR_SYNC            => CP_ISR_SYNC,
        CP_ISR_EN              => CP_ISR_EN,
        CP_GRS_DIS             => CP_GRS_DIS,
        CP_IHSMEM_EN           => CP_IHSMEM_EN,
        CP_DDRI_EN             => CP_DDRI_EN,
        CP_NUM_ICE             => CP_NUM_ICE,
        //iolhr_il_gearctrl
        CP_DES_DDREN           => CP_DES_DDREN,
        CP_DES_SDREN           => CP_DES_SDREN,
        CP_ISERDES_MODE        => CP_ISERDES_MODE,
        CP_LSMEM_EN            => CP_LSMEM_EN,
        CP_SAMEPIPELINE_EN     => CP_SAMEPIPELINE_EN,
        CP_ISAME_EN            => CP_ISAME_EN,
        CP_IOPPOSITE_EN        => CP_IOPPOSITE_EN,
        CP_ILTHEN              => CP_ILTHEN,
        CP_IDFFEN              => CP_IDFFEN,
        CP_OVERSAMPLE_EN       => CP_OVERSAMPLE_EN,
        CP_MASTER              => CP_MASTER,
        CP_NETWORKING_EN       => CP_NETWORKING_EN,
        CP_BITSLIP_EN          => CP_BITSLIP_EN,
        //iolhr_il_gear        
        CP_IFIFO_EN            => CP_IFIFO_EN,
        CP_INIT_Q0             => CP_INIT_Q0,
        CP_INIT_Q1             => CP_INIT_Q1,
        CP_INIT_Q2             => CP_INIT_Q2,
        CP_INIT_Q3             => CP_INIT_Q3,
        CP_SRVAL_Q0            => CP_SRVAL_Q0,
        CP_SRVAL_Q1            => CP_SRVAL_Q1,
        CP_SRVAL_Q2            => CP_SRVAL_Q2,
        CP_SRVAL_Q3            => CP_SRVAL_Q3   
    )
    port map    
    (
//        GLOGEN       => GLOGEN      ,    
//        GRS_N        => ntGRS_N       ,    
        SR           => ntISR         ,    
        ICE0         => ntICE0        ,    
        ICE1         => ntICE1        ,    
        CLK_STG0     => ntCLK_STG0    ,    
        CLKB_STG0    => ntCLKB_STG0   ,    
        HSMEM_CLK    => ntHSMEM_CLK   ,    
        HSMEM_CLKB   => ntHSMEM_CLKB  ,    
        BSCLK        => ntBSCLK       ,    
        CLK_STG1_0   => ntCLK_STG1_0  ,    
        CLK_STG1_1   => ntCLK_STG1_1  ,    
        CLK_STG1_2   => ntCLK_STG1_2  ,    
        CLK_STG2_0   => ntCLK_STG2_0  ,    
        CLK_STG2_1   => ntCLK_STG2_1  ,    
        CLK_STG3     => ntCLK_STG3    ,    
        CLK_FOR_BS   => ntCLK_FOR_BS  ,    
        BITSLIP      => ntBITSLIP     ,    
        ISHIFTIN0    => ntISHIFTIN0   ,    
        ISHIFTIN1    => ntISHIFTIN1   ,    
        IFIFO_WADDR  => IFIFO_WADDR ,    
        IFIFO_RADDR  => IFIFO_RADDR ,    
        RSTN_OUT     => ntRSTN_OUT         ,    
        RX_DATA      => RX_DATA     ,    
        ISHIFTOUT0   => ntISHIFTOUT0  ,    
        ISHIFTOUT1   => ntISHIFTOUT1  ,    
        DI_TO_GEAR   => ntM2      
   );

//    assign  TO_SEL = (CP_TRI_EN == "TRUE") && ntTO;
    
    
    //MUX2
    device MUX2TO1_P DO_RMUX
    parameter map
    (
        CP_SEL => CP_DO_SEL
    )
    port map 
    (
        DOUT => ntDO_R    , 
        DIN1 => ntDO_SDR    , 
        DIN0 => ntDO_DDR    
    );
        
    device MUX2TO1 DO_CASMUX
    parameter map
    (
        CP_POL   => CP_ODLY_EN,
        DIN1_POL => "FALSE"
    )
    port map
    (
        DOUT => ntDO_CAS_OUT , 
        DIN1 => ntDLY_ODLY   , 
        DIN0 => ntOFB    
    );
        
    device MUX2TO1 DO_OUTMUX
    parameter map
    (
        CP_POL => CP_PDIFF,
        DIN1_POL => "TRUE"
    ) 
    port map
    (
        DOUT => ntDO_OUT     , 
        DIN1 => ntDO_CAS_IN , // input inv of  DO_CAS_IN 
        DIN0 => ntDO_CAS_OUT 
    );
        
    device MUX2TO1_P1  DO_PMUX
    parameter map
    (
        CP_TRI_EN => CP_TRI_EN
    )
    port map
    (
        DOUT  => ntDO_P   , 
        TO    => ntTO ,         
        DIN1  => 1'b0   , 
        DIN0  => ntDO_OUT 
    );
        
    device MUX2TO1_P1 DO_NMUX
    parameter map
    (
        CP_TRI_EN => CP_TRI_EN
    )
    port map
    (         
        DOUT  => ntDO_N   , 
        TO    => ntTO     ,
        DIN1  => 1'b1   , 
        DIN0  => ntDO_OUT 
    );
        
    device MUX2TO1 OSRMUX
    parameter map
    (
        CP_POL   => CP_OSR_POL,
        DIN1_POL => "TRUE"
    )
    port map 
    (
        DOUT => ntOSR        , 
        DIN1 => ntOSR_IOLHR ,  // input inv of  OSR_IOLHR 
        DIN0 => ntOSR_IOLHR  
    );
        
    device MUX2TO1 ISRMUX
    parameter map
    (
        CP_POL   => CP_ISR_POL,
        DIN1_POL => "TRUE"
    )
    port map 
    (
        DOUT => ntISR        , 
        DIN1 => ntISR_IOLHR , // input inv of  ISR_IOLHR
        DIN0 => ntISR_IOLHR  
    );

    device MUX2TO1 TFBMUX
    parameter map
    (
        CP_POL   => CP_TBYTE_EN,
        DIN1_POL => "FALSE"
    ) 
    port map 
    (
        DOUT  => ntTFB      , 
        DIN1  => ntTBYTE_IN , 
        DIN0  => ntTO_OUT   
    );
        
    device MUX2TO1 TOMUX
    parameter map
    (
        CP_POL   => CP_PDIFF,
        DIN1_POL => "FALSE"
    ) 
    port map 
    (
        DOUT => ntTO        , 
        DIN1 => ntTO_CAS_IN , 
        DIN0 => ntTFB       
    );
      
    device MUX2TO1 TERMMUX
    parameter map
    (
        CP_POL   => CP_PDIFF,
        DIN1_POL => "FALSE"
    ) 
    port map 
    (
        DOUT => ntTERM     , // Fixed ME
        DIN1 => ntTERM_CAS_IN , 
        DIN0 => ntTERM_FB     
    );
        
    device MUX2TO1 TERM_FBMUX 
    parameter map
    (
        CP_POL   => CP_TBYTE_EN,
        DIN1_POL => "FALSE"
    ) 
    port map 
    (
        DOUT => ntTERM_FB        ,    // Fixed ME
        DIN1 => ntTERM_BYTEIN , 
        DIN0 => ntTERM_OUT     
    );
 
    //MUX4
    device MUX4TO1_P OFBMUX
    parameter map
    (
        CP_DQMODE  => CP_DQMODE  , 
        CP_MIPI_EN => CP_MIPI_EN 
    ) 
    port map 
    (
        MIPI_I => ntMIPI_SW_DYN , 
        DOUT   => ntOFB     , 
        DIN3   => 1'b0          , 
        DIN2   => ntDO_R        , 
        DIN1   => ntDO_SDR        , 
        DIN0   => ntDO_DD         
    );
        
    device MUX4TO1  TO_OUTMUX
    parameter map
    (
        CP_SEL  => CP_TQMODE  
    )     
    port map
    (
        DOUT => ntTO_OUT        ,   
        DIN3 => 1'b0          , 
        DIN2 => ntTO_DDR        , 
        DIN1 => ntQ_SHF0      , 
        DIN0 => TS_CTRL[0]    
    );
      
    device MUX4TO1  TERM_OUTMUX
    parameter map
    (
        CP_SEL  => CP_TQMODE  
    )    
    port map
    (
        DOUT => ntTERM_OUT   , 
        DIN3 => 1'b0       , 
        DIN2 => ntTERM_DDR , 
        DIN1 => ntQ_SHF0   , 
        DIN0 => TS_CTRL[0] 
    );
    

    device IOLHR_OL_CLKGEN XIOLHR_OL_CLKGEN
    parameter map
    (    
        CP_CLK_POL4    => CP_CLK_POL4    ,    
        CP_CLK_POL5    => CP_CLK_POL5    ,    
        CP_CLK_POL6    => CP_CLK_POL6    ,    
        CP_OPPOSITE_EN => CP_OPPOSITE_EN 
    )
    port map    
    (    
        OCLKDIV    => ntOCLKDIV    ,    
        OCLKDIVB   => ntOCLKDIVB   ,    
        SERCLK     => ntSERCLK     ,    
        SERCLKB    => ntSERCLKB    ,    
        OCLK       => ntOCLK       ,    
        OCLKB      => ntOCLKB      ,    
        CLK_STG0   => ntCLK_STG4   ,    
        CLK_STG1   => ntCLK_STG5   ,    
        CLK_STG2_0 => ntCLK_STG6_0 ,    
        CLK_STG2_1 => ntCLK_STG6_1 ,    
        CLK_STG2_2 => ntCLK_STG6_2     
    );

    device OREG_ODDR XOREG_ODDR 
    parameter map
    (    
        CP_SRO_EN        => CP_SRO_EN        ,    
        CP_O_SYNC        => CP_O_SYNC        ,    
        CP_GRS_DIS       => CP_GRS_DIS       ,    
        CP_OHSMEM_EN     => CP_OHSMEM_EN     ,    
        //CP_MEMDQ         => CP_MEMDQ         ,    
        CP_OSERDES_EN    => CP_OSERDES_EN    ,    
        CP_SER_DDREN     => CP_SER_DDREN     ,    
        CP_SER_SDREN     => CP_SER_SDREN     ,    
        CP_OLTHEN        => CP_OLTHEN        ,    
        CP_ODFFEN        => CP_ODFFEN        ,    
      //  CP_OUNREGEN      => CP_OUNREGEN      ,    
        CP_OSERDES_MODE  => CP_OSERDES_MODE  ,    
        CP_UPD0_SHIFTEN  => CP_UPD0_SHIFTEN  ,    
        CP_UPD1_SHIFTEN  => CP_UPD1_SHIFTEN  ,    
        CP_INIT_SET      => CP_INIT_SET      ,    
        CP_INIT_DQ       => CP_INIT_DQ       ,    
        CP_SRVAL_DQ0     => CP_SRVAL_DQ0     ,    
        CP_SRVAL_DQ1     => CP_SRVAL_DQ1     ,    
        CP_SRVAL_DQ2     => CP_SRVAL_DQ2     ,    
        CP_SRVAL_DQ3     => CP_SRVAL_DQ3     ,
        CP_OCASCADE_EN   => CP_OCASCADE_EN   ,
        CP_DQMODE        => CP_DQMODE        ,    
        CP_MIPI_EN       => CP_MIPI_EN       
    ) 
    port map    
    (    
        CLK_STG0    => ntCLK_STG4              ,    
        CLK_STG1    => ntCLK_STG5              ,    
        CLK_STG2_0  => ntCLK_STG6_0            ,    
        CLK_STG2_1  => ntCLK_STG6_1            ,    
        CLK_STG2_2  => ntCLK_STG6_2            ,    
        SR          => ntOSR                   ,
//        GWEN        => GWEN                  ,
//        GLOGEN      => GLOGEN                ,    
//        GRS_N       => ntGRS_N                 ,    
        OCE         => ntOCE                   ,    
        UPD0_SHIFT  => ntUPD0_SHIFT            ,    
        UPD1_SHIFT  => ntUPD1_SHIFT            ,    
        OSHIFTIN0   => ntOSHIFTIN0             ,    
        OSHIFTIN1   => ntOSHIFTIN1             ,    
        TX_DATA     => TX_DATA               ,     
        TO          => ntTO                    ,
        OSHIFTOUT0  => ntOSHIFTOUT0            ,    
        OSHIFTOUT1  => ntOSHIFTOUT1            ,    
        DO_DDR      => ntDO_DDR                ,    
        DO_SDR      => ntDO_SDR                ,    
        DO_DD       => ntDO_DD                     
   );


   device TREG_TDDR XTREG_TDDR
   parameter map
   (    
        CP_SRVAL_TQ0 => CP_SRVAL_TQ0  ,    
        CP_SRVAL_TQ1 => CP_SRVAL_TQ1  ,    
        CP_SRVAL_TQ2 => CP_SRVAL_TQ2  ,    
        CP_SRVAL_TQ3 => CP_SRVAL_TQ3  ,    
        CP_INIT_TQ   => CP_INIT_TQ    ,    
        CP_OLTHEN    => CP_OLTHEN     ,    
        CP_SRT_EN    => CP_SRT_EN     ,
         CP_T_SYNC    => CP_T_SYNC    , 
        CP_GRS_DIS   => CP_GRS_DIS    
    )
    port map     
    (    
        TS_CTRL     =>  TS_CTRL ,    
        CLK_STG2_0  =>  ntCLK_STG6_0   ,    
        CLK_STG2_1  =>  ntCLK_STG6_1   ,    
        CLK_STG2_2  =>  ntCLK_STG6_2   ,    
//        GLOGEN      =>  1'b1         ,    
//        GWEN        =>  1'b1         ,    
//        GRS_N       =>  ntGRS_N        ,    
        SR          =>  ntOSR          ,    
        TCE         =>  ntTCE          ,    
        TO_DDR      =>  ntTO_DDR     ,    
        TERM_DDR    =>  ntTERM_DDR   ,    
        Q_SHF       =>  {ntQ_SHF1,ntQ_SHF0}            
     );
    
    device IOLHR_IDLY XIOLHR_IDLY 
    parameter map
    (    
         CP_IDLY_EN   => CP_IDLY_EN   ,    
         CP_IDYN_EN   => CP_IDYN_EN   ,    
         //CP_LDO_CTRL  =>            ,    
         CP_IDLY_SET  => CP_IDLY_SET 
    )
    port map 
    (    
        DI           => ntM3_REG     ,    
        IDLY_SEL     => ntIDLY_SEL     ,    
        IDLY_DYN_SET => IDLY_DYN_SET ,    
        D_DLY        => ntDLY_IDLY         
    );

    device IOLHR_ODLY XIOLHR_ODLY 
    parameter map
    (    
        CP_ODLY_EN   => CP_ODLY_EN  ,    
        //CP_LDO_CTRL  =>             ,    
        CP_ODYN_EN   => CP_ODYN_EN  ,    
        CP_ODLY_SET  => CP_ODLY_SET 
    )
    port map      
    (    
        DI           => ntOFB        ,    
        ODLY_SEL     => ntODLY_SEL     ,    
        ODLY_DYN_SET => ODLY_DYN_SET ,    
        D_DLY        => ntDLY_ODLY         
    );

    device IOLHR_ZHOLD XIOLHR_ZHOLD
    parameter map
    (    
        CP_ZHOLD_EN  => CP_ZHOLD_EN  ,    
        CP_ZHOLD_SET => CP_ZHOLD_SET 
    ) 
    port map  
    (    
        DI    => ntDI_O2     ,    
        D_DLY => ntDLY_ZHOLD       
    ); 
};
//grid device structure netlist end
//grid device configure body started

configuration cfg of IOLHR
{

 // assign config body begin
    SC_GRS_DIS  :=  CP_GRS_DIS;
    SC_NUM_ICE  :=  CP_NUM_ICE;
    SC_INIT_Q[0]  :=  CP_INIT_Q0;
    SC_INIT_Q[1]  :=  CP_INIT_Q1;
    SC_INIT_Q[2]  :=  CP_INIT_Q2;
    SC_INIT_Q[3]  :=  CP_INIT_Q3;
    SC_IDLY_SET[0]  :=  CP_IDLY_SET[0];
    SC_IDLY_SET[1]  :=  CP_IDLY_SET[1];
    SC_IDLY_SET[2]  :=  CP_IDLY_SET[2];
    SC_IDLY_SET[3]  :=  CP_IDLY_SET[3];
    SC_IDLY_SET[4]  :=  CP_IDLY_SET[4];
    SC_IDLY_SET[5]  :=  CP_IDLY_SET[5];
    SC_IDLY_SET[6]  :=  CP_IDLY_SET[6];
    SC_IDLY_SET[7]  :=  CP_IDLY_SET[7];
    SC_D_SEL0  :=  CP_D_SEL0;
    SC_D_SEL1  :=  CP_D_SEL1;
    SC_D_SEL2  :=  CP_D_SEL2;
    SC_D_SEL3  :=  CP_D_SEL3;
    SC_D_SEL4[0]  :=  CP_D_SEL4[0];
    SC_D_SEL4[1]  :=  CP_D_SEL4[1];
    SC_D_SEL5[0]  :=  CP_D_SEL5[0];
    SC_D_SEL5[1]  :=  CP_D_SEL5[1];
    SC_D_SEL6[0]  :=  CP_D_SEL6[0];
    SC_D_SEL6[1]  :=  CP_D_SEL6[1];
    SC_ZHOLD_SET[0]  :=  CP_ZHOLD_SET[0];
    SC_ZHOLD_SET[1]  :=  CP_ZHOLD_SET[1];
    SC_ZHOLD_SET[2]  :=  CP_ZHOLD_SET[2];
    SC_ZHOLD_SET[3]  :=  CP_ZHOLD_SET[3];
    SC_ODLY_SET[0]  :=  CP_ODLY_SET[0];
    SC_ODLY_SET[1]  :=  CP_ODLY_SET[1];
    SC_ODLY_SET[2]  :=  CP_ODLY_SET[2];
    SC_ODLY_SET[3]  :=  CP_ODLY_SET[3];
    SC_ODLY_SET[4]  :=  CP_ODLY_SET[4];
    SC_ODLY_SET[5]  :=  CP_ODLY_SET[5];
    SC_ODLY_SET[6]  :=  CP_ODLY_SET[6];
    SC_ODLY_SET[7]  :=  CP_ODLY_SET[7];
    SC_INIT_DQ  :=  CP_INIT_DQ;
    SC_INIT_TQ  :=  CP_INIT_TQ;
    SC_DQMODE[0]  :=  CP_DQMODE[0];
    SC_DQMODE[1]  :=  CP_DQMODE[1];
    SC_TQMODE[0]  :=  CP_TQMODE[0];
    SC_TQMODE[1]  :=  CP_TQMODE[1];
    SC_INIT_SET[0]  :=  CP_INIT_SET[0];
    SC_INIT_SET[1]  :=  CP_INIT_SET[1];
    SC_DO_SEL  :=  CP_DO_SEL;
// assign config body end

//initial config body0 begin
    if(CP_CLK_POL0 == "FALSE")
    {
        SC_CLK_POL0  :=  1'b0;
    }
    else if(CP_CLK_POL0 == "TRUE")
    {
        SC_CLK_POL0  :=  1'b1;
    }
    else
    {
        SC_CLK_POL0  :=  1'bx;
        error("illegal setting for CP_CLK_POL0  :=  %s",CP_CLK_POL0);
    }

//initial config body0 end


//initial config body1 begin
    if (CP_CLK_POL1 == "FALSE")
    {
        SC_CLK_POL1  :=  1'b0;
    }
    else if(CP_CLK_POL1 == "TRUE")
    {
        SC_CLK_POL1  :=  1'b1;
    }
    else
    {
        SC_CLK_POL1  :=  1'bx;
        error("illegal setting for CP_CLK_POL1  :=  %s",CP_CLK_POL1);
    }

//initial config body1 end


//initial config body2 begin
    if (CP_CLK_POL2 == "FALSE")
    {
        SC_CLK_POL2  :=  1'b0;
    }
    else if(CP_CLK_POL2 == "TRUE")
    {
        SC_CLK_POL2  :=  1'b1;
    }
    else
    {
        SC_CLK_POL2  :=  1'bx;
        error("illegal setting for CP_CLK_POL2  :=  %s",CP_CLK_POL2);
    }

//initial config body2 end


//initial config body3 begin
    if (CP_CLK_POL3 == "FALSE")
    {
        SC_CLK_POL3  :=  1'b0;
    }
    else if(CP_CLK_POL3 == "TRUE")
    {
        SC_CLK_POL3  :=  1'b1;
    }
    else
    {
        SC_CLK_POL3  :=  1'bx;
        error("illegal setting for CP_CLK_POL3  :=  %s",CP_CLK_POL3);
    }

//initial config body3 end


//initial config body4 begin
    if (CP_DYN_CLKPOL == "FALSE")
    {
        SC_DYN_CLKPOL  :=  1'b0;
    }
    else if(CP_DYN_CLKPOL == "TRUE")
    {
        SC_DYN_CLKPOL  :=  1'b1;
    }
    else
    {
        SC_DYN_CLKPOL  :=  1'bx;
        error("illegal setting for CP_DYN_CLKPOL  :=  %s",CP_DYN_CLKPOL);
    }

//initial config body4 end


//initial config body5 begin
    if (CP_DYN_CLKDIVPOL == "FALSE")
    {
        SC_DYN_CLKDIVPOL  :=  1'b0;
    }
    else if(CP_DYN_CLKDIVPOL == "TRUE")
    {
        SC_DYN_CLKDIVPOL  :=  1'b1;
    }
    else
    {
        SC_DYN_CLKDIVPOL  :=  1'bx;
        error("illegal setting for CP_DYN_CLKDIVPOL  :=  %s",CP_DYN_CLKDIVPOL);
    }

//initial config body5 end


//initial config body6 begin
    if (CP_OCLKPOL == "FALSE")
    {
        SC_OCLKPOL  :=  1'b0;
    }
    else if(CP_OCLKPOL == "TRUE")
    {
        SC_OCLKPOL  :=  1'b1;
    }
    else
    {
        SC_OCLKPOL  :=  1'bx;
        error("illegal setting for CP_OCLKPOL  :=  %s",CP_OCLKPOL);
    }

//initial config body6 end


//initial config body7 begin
    if (CP_OCLKBPOL == "FALSE")
    {
        SC_OCLKBPOL  :=  1'b0;
    }
    else if(CP_OCLKBPOL == "TRUE")
    {
        SC_OCLKBPOL  :=  1'b1;
    }
    else
    {
        SC_OCLKBPOL  :=  1'bx;
        error("illegal setting for CP_OCLKBPOL  :=  %s",CP_OCLKBPOL);
    }

//initial config body7 end


//initial config body8 begin
    if (CP_ISR_POL == "FALSE")
    {
        SC_ISR_POL  :=  1'b0;
    }
    else if(CP_ISR_POL == "TRUE")
    {
        SC_ISR_POL  :=  1'b1;
    }
    else
    {
        SC_ISR_POL  :=  1'bx;
        error("illegal setting for CP_ISR_POL  :=  %s",CP_ISR_POL);
    }

//initial config body8 end


//initial config body9 begin
    if (CP_ISR_SYNC == "ASYNC")
    {
        SC_ISR_SYNC  :=  1'b0;
    }
    else if(CP_ISR_SYNC == "SYNC")
    {
        SC_ISR_SYNC  :=  1'b1;
    }
    else
    {
        SC_ISR_SYNC  :=  1'bx;
        error("illegal setting for CP_ISR_SYNC  :=  %s",CP_ISR_SYNC);
    }

//initial config body9 end


//initial config body10 begin
    if (CP_ISR_EN == "FALSE")
    {
        SC_ISR_EN  :=  1'b0;
    }
    else if(CP_ISR_EN == "TRUE")
    {
        SC_ISR_EN  :=  1'b1;
    }
    else
    {
        SC_ISR_EN  :=  1'b0;
        error("illegal setting for CP_ISR_EN  :=  %s",CP_ISR_EN);
    }

//initial config body10 end


//initial config body11 begin
    if (CP_SRVAL_Q0 == "RESET")
    {
        SC_SRVAL_Q[0]  :=  1'b0;
    }
    else if(CP_SRVAL_Q0 == "SET")
    {
        SC_SRVAL_Q[0]  :=  1'b1;
    }
    else
    {
        SC_SRVAL_Q[0]  :=  1'bx;
        error("illegal setting for CP_SRVAL_Q0  :=  %s",CP_SRVAL_Q0);
    }

//initial config body11 end


//initial config body12 begin
    if (CP_SRVAL_Q1 == "RESET")
    {
        SC_SRVAL_Q[1]  :=  1'b0;
    }
    else if(CP_SRVAL_Q1 == "SET")
    {
        SC_SRVAL_Q[1]  :=  1'b1;
    }
    else
    {
        SC_SRVAL_Q[1]  :=  1'bx;
        error("illegal setting for CP_SRVAL_Q1  :=  %s",CP_SRVAL_Q1);
    }

//initial config body12 end


//initial config body13 begin
    if(CP_SRVAL_Q2 == "RESET")
    {
        SC_SRVAL_Q[2]  :=  1'b0;
    }
    else if(CP_SRVAL_Q2 == "SET")
    {
        SC_SRVAL_Q[2]  :=  1'b1;
    }
    else
    {
        SC_SRVAL_Q[2]  :=  1'b0;
        error("illegal setting for CP_SRVAL_Q2  :=  %s",CP_SRVAL_Q2);
    }

//initial config body13 end


//initial config body14 begin
    if (CP_SRVAL_Q3 == "RESET")
    {
        SC_SRVAL_Q[3]  :=  1'b0;
    }
    else if(CP_SRVAL_Q3 == "SET")
    {
        SC_SRVAL_Q[3]  :=  1'b1;
    }
    else
    {
        SC_SRVAL_Q[3]  :=  1'bx;
        error("illegal setting for CP_SRVAL_Q3  :=  %s",CP_SRVAL_Q3);
    }

//initial config body14 end


//initial config body15 begin
    if(CP_DDRI_EN == "FALSE")
    {
        SC_DDRI_EN  :=  1'b0;
    }
    else if(CP_DDRI_EN == "TRUE")
    {
        SC_DDRI_EN  :=  1'b1;
    }
    else
    {
        SC_DDRI_EN  :=  1'bx;
        error("illegal setting for CP_DDRI_EN  :=  %s",CP_DDRI_EN);
    }

//initial config body15 end


//initial config body16 begin
    if (CP_IHSMEM_EN == "FALSE")
    {
        SC_IHSMEM_EN  :=  1'b0;
    }
    else if(CP_IHSMEM_EN == "TRUE")
    {
        SC_IHSMEM_EN  :=  1'b1;
    }
    else
    {
        SC_IHSMEM_EN  :=  1'bx;
        error("illegal setting for CP_IHSMEM_EN  :=  %s",CP_IHSMEM_EN);
    }

//initial config body16 end


//initial config body17 begin
    if (CP_LSMEM_EN == "FALSE")
    {
        SC_LSMEM_EN  :=  1'b0;
    }
    else if(CP_LSMEM_EN == "TRUE")
    {
        SC_LSMEM_EN  :=  1'b1;
    }
    else
    {
        SC_LSMEM_EN  :=  1'bx;
        error("illegal setting for CP_LSMEM_EN  :=  %s",CP_LSMEM_EN);
    }

//initial config body17 end


//initial config body18 begin
    if (CP_NETWORKING_EN == "FALSE")
    {
        SC_NETWORKING_EN  :=  1'b0;
    }
    else if(CP_NETWORKING_EN == "TRUE")
    {
        SC_NETWORKING_EN  :=  1'b1;
    }
    else
    {
        SC_NETWORKING_EN  :=  1'bx;
        error("illegal setting for CP_NETWORKING_EN  :=  %s",CP_NETWORKING_EN);
    }

//initial config body18 end


//initial config body19 begin
    if (CP_DES_DDREN == "FALSE")
    {
        SC_DES_DDREN  :=  1'b0;
    }
    else if(CP_DES_DDREN == "TRUE")
    {
        SC_DES_DDREN  :=  1'b1;
    }
    else
    {
        SC_DES_DDREN  :=  1'bx;
        error("illegal setting for CP_DES_DDREN  :=  %s",CP_DES_DDREN);
    }

//initial config body19 end


//initial config body20 begin
    if (CP_DES_SDREN == "FALSE")
    {
        SC_DES_SDREN  :=  1'b0;
    }
    else if(CP_DES_SDREN == "TRUE")
    {
        SC_DES_SDREN  :=  1'b1;
    }
    else
    {
        SC_DES_SDREN  :=  1'bx;
        error("illegal setting for CP_DES_SDREN  :=  %s",CP_DES_SDREN);
    }

//initial config body20 end


//initial config body21 begin
    if (CP_BITSLIP_EN == "FALSE")
    {
        SC_BITSLIP_EN  :=  1'b0;
    }
    else if(CP_BITSLIP_EN == "TRUE")
    {
        SC_BITSLIP_EN  :=  1'b1;
    }
    else
    {
        SC_BITSLIP_EN   :=  1'bx;
        error("illegal setting for CP_BITSLIP_EN  :=  %s",CP_BITSLIP_EN);
    }

//initial config body21 end


//initial config body22 begin
    if (CP_IDFFEN == "FALSE")
    {
        SC_IDFFEN  :=  1'b0;
    }
    else if(CP_IDFFEN == "TRUE")
    {
        SC_IDFFEN  :=  1'b1;
    }
    else
    {
        SC_IDFFEN   :=  1'bx;
        error("illegal setting for CP_IDFFEN  :=  %s",CP_IDFFEN);
    }

//initial config body22 end


//initial config body23 begin
    if (CP_ILTHEN == "FALSE")
    {
        SC_ILTHEN  :=  1'b0;
    }
    else if(CP_ILTHEN == "TRUE")
    {
        SC_ILTHEN  :=  1'b1;
    }
    else
    {
        SC_ILTHEN   :=  1'bx;
        error("illegal setting for CP_ILTHEN  :=  %s",CP_ILTHEN);
    }

//initial config body23 end


//initial config body24 begin
    if (CP_MASTER == "MASTER")
    {
        SC_MASTER  :=  1'b0;
    }
    else if(CP_MASTER == "SLAVE")
    {
        SC_MASTER  :=  1'b1;
    }
    else
    {
        SC_MASTER  :=  1'bx;
        error("illegal setting for CP_MASTER  :=  %s",CP_MASTER);
    }

//initial config body24 end


//initial config body25 begin
    if (CP_SAMEPIPELINE_EN == "FALSE")
    {
        SC_SAMEPIPELINE_EN  :=  1'b0;
    }
    else if(CP_SAMEPIPELINE_EN == "TRUE")
    {
        SC_SAMEPIPELINE_EN  :=  1'b1;
    }
    else
    {
        SC_SAMEPIPELINE_EN   :=  1'bx;
        error("illegal setting for CP_SAMEPIPELINE_EN  :=  %s",CP_SAMEPIPELINE_EN);
    }

//initial config body25 end


//initial config body26 begin
    if (CP_IOPPOSITE_EN == "FALSE")
    {
        SC_IOPPOSITE_EN  :=  1'b0;
    }
    else if(CP_IOPPOSITE_EN == "TRUE")
    {
        SC_IOPPOSITE_EN  :=  1'b1;
    }
    else
    {
        SC_IOPPOSITE_EN   :=  1'bx;
        error("illegal setting for CP_IOPPOSITE_EN  :=  %s",CP_IOPPOSITE_EN);
    }

//initial config body26 end


//initial config body27 begin
    if (CP_ISAME_EN == "FALSE")
    {
        SC_ISAME_EN  :=  1'b0;
    }
    else if(CP_ISAME_EN == "TRUE")
    {
        SC_ISAME_EN  :=  1'b1;
    }
    else
    {
        SC_ISAME_EN   :=  1'bx;
        error("illegal setting for CP_ISAME_EN  :=  %s",CP_ISAME_EN);
    }

//initial config body27 end


//initial config body28 begin
    if (CP_OVERSAMPLE_EN == "FALSE")
    {
        SC_OVERSAMPLE_EN  :=  1'b0;
    }
    else if(CP_OVERSAMPLE_EN == "TRUE")
    {
        SC_OVERSAMPLE_EN  :=  1'b1;
    }
    else
    {
        SC_OVERSAMPLE_EN   :=  1'bx;
        error("illegal setting for CP_OVERSAMEPLE_EN  :=  %s",CP_OVERSAMPLE_EN);
    }

//initial config body28 end


//initial config body29 begin
    if (CP_IFIFO_EN == "FALSE")
    {
        SC_IFIFO_EN  :=  1'b0;
    }
    else if(CP_IFIFO_EN == "TRUE")
    {
        SC_IFIFO_EN  :=  1'b1;
    }
    else
    {
        SC_IFIFO_EN   :=  1'bx;
        error("illegal setting for CP_IFIFO_EN  :=  %s",CP_IFIFO_EN);
    }

//initial config body29 end


//initial config body30 begin
    if (CP_IDLY_EN == "FALSE")
    {
        SC_IDLY_EN  :=  1'b0;
    }
    else if(CP_IDLY_EN == "TRUE")
    {
        SC_IDLY_EN  :=  1'b1;
    }
    else
    {
        SC_IDLY_EN   :=  1'bx;
        error("illegal setting for CP_IDLY_EN  :=  %s",CP_IDLY_EN);
    }

//initial config body30 end


//initial config body31 begin
    if (CP_IDYN_EN == "FALSE")
    {
        SC_IDYN_EN  :=  1'b0;
    }
    else if(CP_IDYN_EN == "TRUE")
    {
        SC_IDYN_EN  :=  1'b1;
    }
    else
    {
        SC_IDYN_EN   :=  1'bx;
        error("illegal setting for CP_IDYN_EN  :=  %s",CP_IDYN_EN);
    }

//initial config body31 end


//initial config body32 begin
    if (CP_D_POL0 == "FALSE")
    {
        SC_D_POL0  :=  1'b0;
    }
    else if(CP_D_POL0 == "TRUE")
    {
        SC_D_POL0  :=  1'b1;
    }
    else
    {
        SC_D_POL0  :=  1'bx;
        error("illegal setting for CP_D_POL0  :=  %s",CP_D_POL0);
    }

//initial config body32 end


//initial config body33 begin
    if (CP_D_POL1 == "FALSE")
    {
        SC_D_POL1  :=  1'b0;
    }
    else if(CP_D_POL1 == "TRUE")
    {
        SC_D_POL1  :=  1'b1;
    }
    else
    {
        SC_D_POL1  :=  1'bx;
        error("illegal setting for CP_D_POL1  :=  %s",CP_D_POL1);
    }

//initial config body33 end


//initial config body34 begin
    if (CP_ZHOLD_EN == "FALSE")
    {
        SC_ZHOLD_EN  :=  1'b0;
    }
    else if(CP_ZHOLD_EN == "TRUE")
    {
        SC_ZHOLD_EN   :=  1'b1;
    }
    else
    {
        SC_ZHOLD_EN  :=  1'bx;
        error("illegal setting for CP_ZHOLD_EN  :=  %s",CP_ZHOLD_EN);
    }

//initial config body34 end


//initial config body35 begin
    if (CP_TEST_EN0 == "FALSE")
    {
        SC_TEST_EN0  :=  1'b0;
    }
    else if(CP_TEST_EN0 == "TRUE")
    {
        SC_TEST_EN0   :=  1'b1;
    }
    else
    {
        SC_TEST_EN0  :=  1'bx;
        error("illegal setting for CP_TEST_EN0  :=  %s",CP_TEST_EN0);
    }

//initial config body35 end


//initial config body36 begin
    if (CP_TEST_EN1 == "FALSE")
    {
        SC_TEST_EN1  :=  1'b0;
    }
    else if(CP_TEST_EN1 == "TRUE")
    {
        SC_TEST_EN1   :=  1'b1;
    }
    else
    {
        SC_TEST_EN1  :=  1'bx;
        error("illegal setting for CP_TEST_EN1  :=  %s",CP_TEST_EN1);
    }

//initial config body36 end


//initial config body37 begin
    if (CP_OSR_POL == "FALSE")
    {
        SC_OSR_POL  :=  1'b0;
    }
    else if(CP_OSR_POL == "TRUE")
    {
        SC_OSR_POL  :=  1'b1;
    }
    else
    {
        SC_OSR_POL  :=  1'bx;
        error("illegal setting for CP_OSR_POL  :=  %s",CP_OSR_POL);
    }

//initial config body37 end


//initial config body38 begin
    if (CP_O_SYNC == "ASYNC")
    {
        SC_O_SYNC  :=  1'b0;
    }
    else if(CP_O_SYNC == "SYNC")
    {
        SC_O_SYNC  :=  1'b1;
    }
    else
    {
        SC_O_SYNC  :=  1'bx;
        error("illegal setting for CP_O_SYNC  :=  %s",CP_O_SYNC);
    }

//initial config body38 end


//initial config body39 begin
    if (CP_SRO_EN == "FALSE")
    {
        SC_SRO_EN  :=  1'b0;
    }
    else if(CP_SRO_EN == "TRUE")
    {
        SC_SRO_EN   :=  1'b1;
    }
    else
    {
        SC_SRO_EN  :=  1'bx;
        error("illegal setting for CP_O_SYNC  :=  %s",CP_SRO_EN);
    }

//initial config body39 end


//initial config body40 begin
    if (CP_T_SYNC == "ASYNC")
    {
        SC_T_SYNC  :=  1'b0;
    }
    else if(CP_T_SYNC == "SYNC")
    {
        SC_T_SYNC  :=  1'b1;
    }
    else
    {
        SC_T_SYNC  :=  1'bx;
        error("illegal setting for CP_O_SYNC  :=  %s",CP_T_SYNC);
    }

//initial config body40 end


//initial config body41 begin
    if (CP_SRT_EN == "FALSE")
    {
        SC_SRT_EN  :=  1'b0;
    }
    else if(CP_SRT_EN == "TRUE")
    {
        SC_SRT_EN   :=  1'b1;
    }
    else
    {
        SC_SRT_EN  :=  1'bx;
        error("illegal setting for CP_SRT_EN  :=  %s",CP_SRT_EN);
    }

//initial config body41 end


//initial config body42 begin
    if (CP_SRVAL_DQ0 == "RESET")
    {
        SC_SRVAL_DQ[0]  :=  1'b0;
    }
    else if(CP_SRVAL_DQ0 == "SET")
    {
        SC_SRVAL_DQ[0]  :=  1'b1;
    }
    else
    {
        SC_SRVAL_DQ[0]  :=  1'bx;
        error("illegal setting for CP_SRVAL_DQ0  :=  %s",CP_SRVAL_DQ0);
    }

//initial config body42 end


//initial config body43 begin
    if (CP_SRVAL_DQ1 == "RESET")
    {
        SC_SRVAL_DQ[1]  :=  1'b0;
    }
    else if(CP_SRVAL_DQ1 == "SET")
    {
        SC_SRVAL_DQ[1]  :=  1'b1;
    }
    else
    {
        SC_SRVAL_DQ[1]  :=  1'bx;
        error("illegal setting for CP_SRVAL_DQ1  :=  %s",CP_SRVAL_DQ1);
    }

//initial config body43 end


//initial config body44 begin
    if (CP_SRVAL_DQ2 == "RESET")
    {
        SC_SRVAL_DQ[2]  :=  1'b0;
    }
    else if(CP_SRVAL_DQ2 == "SET")
    {
        SC_SRVAL_DQ[2]  :=  1'b1;
    }
    else
    {
        SC_SRVAL_DQ[2]  :=  1'bx;
        error("illegal setting for CP_SRVAL_DQ2  :=  %s",CP_SRVAL_DQ2);
    }

//initial config body44 end


//initial config body45 begin
    if (CP_SRVAL_DQ3 == "RESET")
    {
        SC_SRVAL_DQ[3]  :=  1'b0;
    }
    else if(CP_SRVAL_DQ3 == "SET")
    {
        SC_SRVAL_DQ[3]  :=  1'b1;
    }
    else
    {
        SC_SRVAL_DQ[3]  :=  1'bx;
        error("illegal setting for CP_SRVAL_DQ3  :=  %s",CP_SRVAL_DQ3);
    }

//initial config body45 end


//initial config body46 begin
    if (CP_SRVAL_TQ0 == "RESET")
    {
        SC_SRVAL_TQ[0]  :=  1'b0;
    }
    else if(CP_SRVAL_TQ0 == "SET")
    {
        SC_SRVAL_TQ[0]  :=  1'b1;
    }
    else
    {
        SC_SRVAL_TQ[0]  :=  1'bx;
        error("illegal setting for CP_SRVAL_TQ0  :=  %s",CP_SRVAL_TQ0);
    }

//initial config body46 end


//initial config body47 begin
    if (CP_SRVAL_TQ1 == "RESET")
    {
        SC_SRVAL_TQ[1]  :=  1'b0;
    }
    else if(CP_SRVAL_TQ1 == "SET")
    {
        SC_SRVAL_TQ[1]  :=  1'b1;
    }
    else
    {
        SC_SRVAL_TQ[1]  :=  1'bx;
        error("illegal setting for CP_SRVAL_TQ1  :=  %s",CP_SRVAL_TQ1);
    }

//initial config body47 end


//initial config body48 begin
    if (CP_SRVAL_TQ2 == "RESET")
    {
        SC_SRVAL_TQ[2]  :=  1'b0;
    }
    else if(CP_SRVAL_TQ2 == "SET")
    {
        SC_SRVAL_TQ[2]  :=  1'b1;
    }
    else
    {
        SC_SRVAL_TQ[2]  :=  1'bx;
        error("illegal setting for CP_SRVAL_TQ2  :=  %s",CP_SRVAL_TQ2);
    }

//initial config body48 end


//initial config body49 begin
    if (CP_SRVAL_TQ3 == "RESET")
    {
        SC_SRVAL_TQ[3]  :=  1'b0;
    }
    else if(CP_SRVAL_TQ3 == "SET")
    {
        SC_SRVAL_TQ[3]  :=  1'b1;
    }
    else
    {
        SC_SRVAL_TQ[3]  :=  1'bx;
        error("illegal setting for CP_SRVAL_TQ3  :=  %s",CP_SRVAL_TQ3);
    }

//initial config body49 end


//initial config body50 begin
    if (CP_MIPI_EN == "FALSE")
    {
        SC_MIPI_EN  :=  1'b0;
    }
    else if(CP_MIPI_EN == "TRUE")
    {
        SC_MIPI_EN  :=  1'b1;
    }
    else
    {
        SC_MIPI_EN  :=  1'bx;
        error("illegal setting for CP_MIPI_EN  :=  %s",CP_MIPI_EN);
    }

//initial config body50 end


//initial config body51 begin
    if (CP_PDIFF == "FALSE")
    {
        SC_PDIFF  :=  1'b0;
    }
    else if(CP_PDIFF == "TRUE")
    {
        SC_PDIFF  :=  1'b1;
    }
    else
    {
        SC_PDIFF  :=  1'bx;
        error("illegal setting for CP_PDIFF  :=  %s",CP_PDIFF);
    }

//initial config body51 end


//initial config body52 begin
    if (CP_ODLY_EN == "FALSE")
    {
        SC_ODLY_EN  :=  1'b0;
    }
    else if(CP_ODLY_EN == "TRUE")
    {
        SC_ODLY_EN  :=  1'b1;
    }
    else
    {
        SC_ODLY_EN  :=  1'bx;
        error("illegal setting for CP_ODLY_EN  :=  %s",CP_ODLY_EN);
    }

//initial config body52 end


//initial config body53 begin
    if (CP_ODYN_EN == "FALSE")
    {
        SC_ODYN_EN  :=  1'b0;
    }
    else if(CP_ODYN_EN == "TRUE")
    {
        SC_ODYN_EN  :=  1'b1;
    }
    else
    {
        SC_ODYN_EN  :=  1'bx;
        error("illegal setting for CP_ODLY_EN  :=  %s",CP_ODYN_EN);
    }

//initial config body53 end


//initial config body54 begin
    if (CP_OSERDES_EN == "FALSE")
    {
        SC_OSERDES_EN  :=  1'b0;
    }
    else if(CP_OSERDES_EN == "TRUE")
    {
        SC_OSERDES_EN  :=  1'b1;
    }
    else
    {
        SC_OSERDES_EN  :=  1'bx;
        error("illegal setting for CP_OSERDES  :=  %s",CP_OSERDES_EN);
    }

//initial config body54 end


//initial config body55 begin
    if (CP_SER_SDREN == "FALSE")
    {
        SC_SER_SDREN  :=  1'b0;
    }
    else if(CP_SER_SDREN == "TRUE")
    {
        SC_SER_SDREN  :=  1'b1;
    }
    else
    {
        SC_SER_SDREN  :=  1'bx;
        error("illegal setting for CP_SER_SDREN  :=  %s",CP_SER_SDREN);
    }

//initial config body55 end


//initial config body56 begin
    if (CP_SER_DDREN == "FALSE")
    {
        SC_SER_DDREN  :=  1'b0;
    }
    else if(CP_SER_DDREN == "TRUE")
    {
        SC_SER_DDREN  :=  1'b1;
    }
    else
    {
        SC_SER_DDREN  :=  1'bx;
        error("illegal setting for CP_SER_DDREN  :=  %s",CP_SER_DDREN);
    }

//initial config body56 end


//initial config body57 begin
    if (CP_OHSMEM_EN == "FALSE")
    {
        SC_OHSMEM_EN  :=  1'b0;
    }
    else if(CP_OHSMEM_EN == "TRUE")
    {
        SC_OHSMEM_EN  :=  1'b1;
    }
    else
    {
        SC_OHSMEM_EN  :=  1'bx;
        error("illegal setting for CP_SER_DDREN  :=  %s",CP_OHSMEM_EN);
    }

//initial config body57 end


//initial config body58 begin
    if (CP_ODFFEN == "FALSE")
    {
        SC_ODFFEN  :=  1'b0;
    }
    else if(CP_ODFFEN == "TRUE")
    {
        SC_ODFFEN  :=  1'b1;
    }
    else
    {
        SC_ODFFEN  :=  1'bx;
        error("illegal setting for CP_ODFFEN  :=  %s",CP_ODFFEN);
    }

//initial config body58 end


//initial config body59 begin
    if (CP_OLTHEN == "FALSE")
    {
        SC_OLTHEN  :=  1'b0;
    }
    else if(CP_OLTHEN == "TRUE")
    {
        SC_OLTHEN  :=  1'b1;
    }
    else
    {
        SC_OLTHEN  :=  1'bx;
        error("illegal setting for CP_OLTHEN  :=  %s",CP_OLTHEN);
    }

//initial config body59 end


//initial config body60 begin
    if (CP_OPPOSITE_EN == "FALSE")
    {
        SC_OPPOSITE_EN  :=  1'b0;
    }
    else if(CP_OPPOSITE_EN == "TRUE")
    {
        SC_OPPOSITE_EN  :=  1'b1;
    }
    else
    {
        SC_OPPOSITE_EN  :=  1'bx;
        error("illegal setting for CP_OPPOSITE_EN  :=  %s",CP_OPPOSITE_EN);
    }

//initial config body60 end


//initial config body61 begin
    if (CP_TBYTE_EN == "FALSE")
    {
        SC_TBYTE_EN  :=  1'b0;
    }
    else if(CP_TBYTE_EN == "TRUE")
    {
        SC_TBYTE_EN  :=  1'b1;
    }
    else
    {
        SC_TBYTE_EN  :=  1'bx;
        error("illegal setting for CP_TBYTE_EN  :=  %s",CP_TBYTE_EN);
    }

//initial config body61 end


//initial config body62 begin
    if (CP_TRI_EN == "FALSE")
    {
        SC_TRI_EN  :=  1'b0;
    }
    else if(CP_TRI_EN == "TRUE")
    {
        SC_TRI_EN  :=  1'b1;
    }
    else
    {
        SC_TRI_EN  :=  1'bx;
        error("illegal setting for CP_TRI_EN  :=  %s",CP_TRI_EN);
    }

//initial config body62 end


//initial config body63 begin
    if (CP_OCASCADE_EN == "FALSE")
    {
        SC_OCASCADE_EN  :=  1'b0;
    }
    else if(CP_OCASCADE_EN == "TRUE")
    {
        SC_OCASCADE_EN  :=  1'b1;
    }
    else
    {
        SC_OCASCADE_EN  :=  1'bx;
        error("illegal setting for CP_OCASCADE_EN  :=  %s",CP_OCASCADE_EN);
    }

//initial config body63 end


//initial config body64 begin
    if (CP_CLK_POL4 == "FALSE")
    {
        SC_CLK_POL4  :=  1'b0;
    }
    else if(CP_CLK_POL4 == "TRUE")
    {
        SC_CLK_POL4  :=  1'b1;
    }
    else
    {
        SC_CLK_POL4   :=  1'bx;
        error("illegal setting for CP_CLK_POL4  :=  %s",CP_CLK_POL4);
    }

//initial config body64 end


//initial config body65 begin
    if (CP_CLK_POL5 == "FALSE")
    {
        SC_CLK_POL5  :=  1'b0;
    }
    else if(CP_CLK_POL5 == "TRUE")
    {
        SC_CLK_POL5  :=  1'b1;
    }
    else
    {
        SC_CLK_POL5   :=  1'bx;
        error("illegal setting for CP_CLK_POL5  :=  %s",CP_CLK_POL5);
    }

//initial config body65 end


//initial config body66 begin
    if (CP_CLK_POL6 == "FALSE")
    {
        SC_CLK_POL6  :=  1'b0;
    }
    else if(CP_CLK_POL6 == "TRUE")
    {
        SC_CLK_POL6  :=  1'b1;
    }
    else
    {
        SC_CLK_POL6   :=  1'bx;
        error("illegal setting for CP_CLK_POL6  :=  %s",CP_CLK_POL6);
    }

//initial config body66 end


//initial config body67 begin
    if (CP_UPD0_SHIFTEN == "FALSE")
    {
        SC_UPD0_SHIFTEN  :=  1'b0;
    }
    else if(CP_UPD0_SHIFTEN == "TRUE")
    {
        SC_UPD0_SHIFTEN  :=  1'b1;
    }
    else
    {
        SC_UPD0_SHIFTEN  :=  1'bx;
        error("illegal setting for CP_UPD0_SHIFTEN  :=  %s",CP_UPD0_SHIFTEN);
    }

//initial config body67 end


//initial config body68 begin
    if (CP_UPD1_SHIFTEN == "FALSE")
    {
        SC_UPD1_SHIFTEN  :=  1'b0;
    }
    else if(CP_UPD1_SHIFTEN == "TRUE")
    {
        SC_UPD1_SHIFTEN  :=  1'b1;
    }
    else
    {
        SC_UPD1_SHIFTEN  :=  1'bx;
        error("illegal setting for CP_UPD1_SHIFTEN  :=  %s",CP_UPD1_SHIFTEN);
    }

//initial config body68 end


//initial config body69 begin
    if (CP_ISERDES_MODE == "SDR1TO2")
    {
        SC_ISERDES_MODE  :=  4'b0101;
    }
    else if(CP_ISERDES_MODE == "SDR1TO3")
    {
        SC_ISERDES_MODE  :=  4'b0110;
    }
    else if(CP_ISERDES_MODE == "SDR1TO4")
    {
        SC_ISERDES_MODE  :=  4'b0000;
    }
    else if(CP_ISERDES_MODE == "SDR1TO5")
    {
        SC_ISERDES_MODE  :=  4'b0011;
    }
    else if(CP_ISERDES_MODE == "SDR1TO6")
    {
        SC_ISERDES_MODE  :=  4'b1000;
    }
    else if(CP_ISERDES_MODE == "SDR1TO7")
    {
        SC_ISERDES_MODE  :=  4'b0010;
    }
    else if(CP_ISERDES_MODE == "SDR1TO8")
    {
        SC_ISERDES_MODE  :=  4'b0001;
    }
    else if(CP_ISERDES_MODE == "DDR1TO4")
    {
        SC_ISERDES_MODE  :=  4'b0000;
    }
    else if(CP_ISERDES_MODE == "DDR1TO6")
    {
        SC_ISERDES_MODE  :=  4'b1000;
    }
    else if(CP_ISERDES_MODE == "DDR1TO8")
    {
        SC_ISERDES_MODE  :=  4'b0001;
    }
    else if(CP_ISERDES_MODE == "DDR1TO10")
    {
        SC_ISERDES_MODE  :=  4'b0100;
    }
    else if(CP_ISERDES_MODE == "DDR1TO14")
    {
        SC_ISERDES_MODE  :=  4'b0111;
    }
    else
    {
        SC_ISERDES_MODE  :=  4'bxxxx;
        error("illegal setting for CP_ISERDES_MODE  :=  %s",CP_ISERDES_MODE);
    }

//initial config body69 end


//initial config body70 begin
    if (CP_OSERDES_MODE == "SDR2TO1")
    {
        SC_OSERDES_MODE  :=  4'b0101;
    }
    else if(CP_OSERDES_MODE == "SDR3TO1")
    {
        SC_OSERDES_MODE  :=  4'b0110;
    }
    else if(CP_OSERDES_MODE == "SDR4TO1")
    {
        SC_OSERDES_MODE  :=  4'b0000;
    }
    else if(CP_OSERDES_MODE == "SDR5TO1")
    {
        SC_OSERDES_MODE  :=  4'b0011;
    }
    else if(CP_OSERDES_MODE == "SDR6TO1")
    {
        SC_OSERDES_MODE  :=  4'b1000;
    }
    else if(CP_OSERDES_MODE == "SDR7TO1")
    {
        SC_OSERDES_MODE  :=  4'b0010;
    }
    else if(CP_OSERDES_MODE == "SDR8TO1")
    {
        SC_OSERDES_MODE  :=  4'b0001;
    }
    else if(CP_OSERDES_MODE == "DDR4TO1")
    {
        SC_OSERDES_MODE  :=  4'b0000;
    }
    else if(CP_OSERDES_MODE == "DDR6TO1")
    {
        SC_OSERDES_MODE  :=  4'b1000;
    }
    else if(CP_OSERDES_MODE == "DDR8TO1")
    {
        SC_OSERDES_MODE  :=  4'b0001;
    }
    else if(CP_OSERDES_MODE == "DDR10TO1")
    {
        SC_OSERDES_MODE  :=  4'b0100;
    }
    else if(CP_OSERDES_MODE == "DDR14TO1")
    {
        SC_OSERDES_MODE  :=  4'b0111;
    }
    else
    {
        SC_OSERDES_MODE  :=  4'bxxxx;
        error("illegal setting for CP_OSERDES_MODE  :=  %s",CP_OSERDES_MODE);
    }

//initial config body70 end

};

//grid device configure body end


timing iolhr_tnl of IOLHR
{
    wire ntDI, ntDI_N, ntDI_MIPI;
    wire ntDI_FROM_SRB;
    wire ntOCLK, ntOCLKB, ntDESCLK, ntICLK, ntICLKB, ntBSCLK, ntICLKDIV;
    wire ntISR_IOLHR, ntOSR_IOLHR;
    wire ntT_BYTEIN, ntTERM_BYTEIN;
    wire ntDO_CAS_IN, ntTO_CAS_IN, ntTERM_CAS_IN;

    ntDI          <= DI;
    ntDI_N        <= DI_N;
    ntDI_MIPI     <= DI_MIPI;
    ntDI_FROM_SRB <= DI_FROM_SRB;
    ntOCLK        <= OCLK;
    ntOCLKB       <= OCLKB;
    ntDESCLK      <= DESCLK;
    ntICLK        <= ICLK;
    ntICLKB       <= ICLKB;
    ntICLKDIV     <= ICLKDIV;
    ntISR_IOLHR   <= ISR_IOLHR;
    ntOSR_IOLHR   <= OSR_IOLHR;
    ntT_BYTEIN    <= T_BYTEIN;
    ntTERM_BYTEIN <= TERM_BYTEIN;
    ntDO_CAS_IN   <= DO_CAS_IN;
    ntTO_CAS_IN   <= TO_CAS_IN;
    ntTERM_CAS_IN <= TERM_CAS_IN;
    INBUF_DYN_DIS_N_O <= INBUF_DYN_DIS_N_I;
    MIPI_SW_DYN_O <= MIPI_SW_DYN_I;

    //MUX2
    &wire ntDI_O0 = (CP_D_SEL0   == 1'b1)  ? ntDI      : ntDI_N;
    &wire ntDI_O1 = (CP_MIPI_EN == "TRUE") ? ntDI_MIPI : ntDI_O0;
    &wire ntDI_O2 = (CP_D_SEL0   == 1'b1)  ? ntDI_N    : ntDI;

    wire ntDLY_IDLY;
    if (CP_IDLY_EN == "TRUE" && 
       (CP_D_SEL5 == 2'b10 || CP_D_SEL5 == 2'b10 || CP_D_SEL4 == 2'b10))
    {
        operator V_IODELAY_E2 i_DLY
        parameter map (
            //LDO_CTRL => ,
            DELAY_STEP_SEL => (CP_IDYN_EN == "TRUE") ? "PORT" : "PARAMETER",
            DELAY_STEP_VALUE => CP_IDLY_SET
        )
        port map (
          //DI =>  ntM3_REG,
            DI  => (CP_D_SEL6 == 2'b00) ?   ntDI_O2       :
                  (CP_D_SEL6 == 2'b01) ?   ntDI_FROM_SRB :
                  (CP_D_SEL6 == 2'b10) ?   DO_CAS_OUT    :
                /*(CP_D_SEL6 == 2'b11) ?*/ 1'b0 ,
            DO  => ntDLY_IDLY,
            DELAY_SEL => IDLY_SEL,
            DELAY_STEP => IDLY_DYN_SET
            
        );
    }

    wire ntDLY_ZHOLD, ntDLY_ZHOLD_N;
    if (CP_ZHOLD_EN == "TRUE" &&
       (CP_D_SEL5 == 2'b00 || CP_D_SEL5 == 2'b00 || CP_D_SEL4 == 2'b00))
    {
        operator V_ZEROHOLDDELAY i_DLY_ZHOLD
        parameter map (
            ZHOLD_SET => (CP_ZHOLD_SET == 4'b0000) ? "NODELAY":
                         (CP_ZHOLD_SET == 4'b0001) ? "100ps"  :
                         (CP_ZHOLD_SET == 4'b0011) ? "200ps"  :
                         (CP_ZHOLD_SET == 4'b0010) ? "300ps"  :
                         (CP_ZHOLD_SET == 4'b0110) ? "400ps"  :
                         (CP_ZHOLD_SET == 4'b0111) ? "500ps"  :
                         (CP_ZHOLD_SET == 4'b0101) ? "600ps"  :
                         (CP_ZHOLD_SET == 4'b0100) ? "700ps"  :
                         (CP_ZHOLD_SET == 4'b1100) ? "800ps"  :
                         (CP_ZHOLD_SET == 4'b1101) ? "900ps"  :
                         (CP_ZHOLD_SET == 4'b1111) ? "1000ps" :
                         (CP_ZHOLD_SET == 4'b1110) ? "1100ps" :
                         (CP_ZHOLD_SET == 4'b1010) ? "1200ps" :
                         (CP_ZHOLD_SET == 4'b1011) ? "1300ps" :
                         (CP_ZHOLD_SET == 4'b1001) ? "1400ps" :
                       /*(CP_ZHOLD_SET == 4'b1000) ?*/ "1500ps"
        )
        port map (
            DI  => ntDI_O2,
            DO  => ntDLY_ZHOLD
        );
        if (CP_D_POL0 == "TRUE" || CP_D_POL1 == "TRUE")
        {
            operator V_INV i_DLY_ZHOLD_N
            port map (
                I  => ntDLY_ZHOLD,
                Z  => ntDLY_ZHOLD_N
            );
        }
    }
    &wire ntZHOLD_O0 = (CP_D_POL0 == "TRUE") ? ntDLY_ZHOLD_N : ntDLY_ZHOLD;
    &wire ntZHOLD_O1 = (CP_D_POL1 == "TRUE") ? ntDLY_ZHOLD_N : ntDLY_ZHOLD;

    //MUX4
  //&wire ntM3_REG   = (CP_D_SEL6 == 2'b00) ?   ntDI_O2       :
  //                   (CP_D_SEL6 == 2'b01) ?   ntDI_FROM_SRB :
  //                   (CP_D_SEL6 == 2'b10) ?   ntDO_CAS_OUT  :
  //                 /*(CP_D_SEL6 == 2'b11) ?*/ 1'b0          ;
    &wire ntM2_REG   = (CP_D_SEL4 == 2'b00) ?   ntZHOLD_O1    :
                       (CP_D_SEL4 == 2'b01) ?   ntDI_O2       :
                       (CP_D_SEL4 == 2'b10) ?   ntDLY_IDLY    :
                     /*(CP_D_SEL4 == 2'b11) ?*/ 1'b0          ;
    &wire ntM1_REG   = (CP_D_SEL5 == 2'b00) ?   ntZHOLD_O0    :
                       (CP_D_SEL5 == 2'b01) ?   ntDI_O2       :
                       (CP_D_SEL5 == 2'b10) ?   ntDLY_IDLY    :
                     /*(CP_D_SEL5 == 2'b11) ?*/ ntDI_O1       ;
    &wire ntM0_REG_P = (CP_D_SEL5 == 2'b00) ?   ntZHOLD_O0    :
                       (CP_D_SEL5 == 2'b01) ?   ntDI_O0       :
                       (CP_D_SEL5 == 2'b10) ?   ntDLY_IDLY    :
                     /*(CP_D_SEL5 == 2'b11) ?*/ ntDI_O1       ;
    wire ntM0_REG_N;
    if (CP_D_SEL5 != 2'b01)
    {
        operator V_INV i_M0_REGMUX_N
        port map (
            I  => ntM0_REG_P,
            Z  => ntM0_REG_N
        );
    }
    &wire ntM0_REG = (CP_D_SEL5 != 2'b01) ? ntM0_REG_N : ntM0_REG_P;  // WHY DIN1 DON't INVERT


    //MUX3
    wire ntM0_TMP, ntM1_TMP, ntM2_TMP;
    if (CP_TEST_EN1 == "TRUE" && CP_D_SEL1 == 1'b1)
    {
        wire ntM0MUX_DIN1;
        operator V_INV i_M0MUX_DIN1_N
        port map (
            I  => DO_CAS_OUT,
            Z  => ntM0MUX_DIN1
        );
        operator V_MUX2 i_M0MUX
        port map (
           I0   =>  ntM0_REG,
           I1   =>  ntM0MUX_DIN1,
           SEL  =>  TO_CAS_OUT,
           Z    =>  ntM0_TMP
        );
    }
    if (CP_TEST_EN1 == "TRUE" && CP_D_SEL2 == 1'b1)
    {
        operator V_MUX2 i_M1MUX
        port map (
           I0   =>  ntM1_REG,
           I1   =>  DO_CAS_OUT,
           SEL  =>  TO_CAS_OUT,
           Z    =>  ntM1_TMP
        );
    }
    if (CP_TEST_EN0 == "TRUE" && CP_D_SEL3 == 1'b1)
    {
        operator V_MUX2 i_M2MUX
        port map (
           I0   =>  ntM2_REG,
           I1   =>  DO_CAS_OUT,
           SEL  =>  TO_CAS_OUT,
           Z    =>  ntM2_TMP
        );
    }
    &wire ntM0 = (CP_TEST_EN1 == "TRUE" && CP_D_SEL1 == 1'b1) ? ntM0_TMP : ntM0_REG;
    &wire ntM1 = (CP_TEST_EN1 == "TRUE" && CP_D_SEL2 == 1'b1) ? ntM1_TMP : ntM1_REG;
    &wire ntM2 = (CP_TEST_EN0 == "TRUE" && CP_D_SEL3 == 1'b1) ? ntM2_TMP : ntM2_REG;
    DI_TO_CLKB <= ntM0;
    DI_TO_CLK  <= ntM1;

    wire ntISR_IOLHR_N, ntOSR_IOLHR_N;
    if (CP_ISR_POL == "TRUE")
    {
        operator V_INV i_ISR_N
        port map (
            I  => ntISR_IOLHR,
            Z  => ntISR_IOLHR_N
        );
    }
    if (CP_OSR_POL == "TRUE")
    {
        operator V_INV i_OSR_N
        port map (
            I  => ntOSR_IOLHR,
            Z  => ntOSR_IOLHR_N
        );
    }
    &wire ntISR = (CP_ISR_POL == "TRUE") ? ntISR_IOLHR_N : ntISR_IOLHR;
    &wire ntOSR = (CP_OSR_POL == "TRUE") ? ntOSR_IOLHR_N : ntOSR_IOLHR;
    &wire ntDI_TO_GEAR = ntM2;

    //IREG_IDDR
    
    string ISERDES_MODE = "DISABLE";
    if (CP_DDRI_EN == "TRUE")
    {
       if (CP_DES_DDREN == "TRUE" && CP_IHSMEM_EN == "TRUE" && CP_IFIFO_EN == "TRUE")
       {
           if (CP_ISERDES_MODE == "DDR1TO4" /* || CP_ISERDES_MODE == "SDR1TO4" */)
           {
               ISERDES_MODE = "HMDDR1TO4";
           }
           else if (CP_ISERDES_MODE == "DDR1TO8" /* || CP_ISERDES_MODE == "SDR1TO8" */)
           {
               ISERDES_MODE = "HMDDR1TO8";
           }
       }
       else if (CP_DES_DDREN == "TRUE" && CP_LSMEM_EN == "TRUE")
       {
           if (CP_ISERDES_MODE == "DDR1TO4" /* || CP_ISERDES_MODE == "SDR1TO4" */)
           {
               ISERDES_MODE = "LMDDR1TO4";
           }
           else if (CP_ISERDES_MODE == "DDR1TO8" /* || CP_ISERDES_MODE == "SDR1TO8" */)
           {
               ISERDES_MODE = "LMDDR1TO8";
           }
       }
       else if (CP_OVERSAMPLE_EN == "TRUE")
       {
           ISERDES_MODE = "OVERSAMPLE";
       }
       else if (CP_DES_SDREN == "TRUE" && CP_DES_DDREN == "FALSE"&& CP_NETWORKING_EN == "TRUE" &&
          (CP_ISERDES_MODE == "SDR1TO2" || CP_ISERDES_MODE == "SDR1TO3" || CP_ISERDES_MODE == "SDR1TO4" ||
           CP_ISERDES_MODE == "SDR1TO5" || CP_ISERDES_MODE == "SDR1TO6" || CP_ISERDES_MODE == "SDR1TO7" ||
           CP_ISERDES_MODE == "SDR1TO8"))
       {
           ISERDES_MODE = CP_ISERDES_MODE;
       }
       else if (CP_DES_SDREN == "FALSE" && CP_DES_DDREN == "TRUE" && CP_NETWORKING_EN == "TRUE" &&
          (CP_ISERDES_MODE == "DDR1TO4" || CP_ISERDES_MODE == "DDR1TO6" || CP_ISERDES_MODE == "DDR1TO8" ||
           CP_ISERDES_MODE == "DDR1TO10" || CP_ISERDES_MODE == "DDR1TO14"))
       {
           ISERDES_MODE = CP_ISERDES_MODE;
       }
    }
    else if (CP_DDRI_EN == "FALSE")
    {
        if (CP_DES_DDREN == "TRUE" && CP_IDFFEN == "FALSE" && CP_ILTHEN == "FALSE")
        {
            if (CP_SAMEPIPELINE_EN == "TRUE")
            {
                ISERDES_MODE = "DDR1TO2_SAME_PIPELINED";
            }
            else if (CP_ISAME_EN == "TRUE")
            {
                ISERDES_MODE = "DDR1TO2_SAME_EDGE";
            }
            else if (CP_IOPPOSITE_EN == "TRUE")
            {
                ISERDES_MODE = "DDR1TO2_OPPOSITE_EDGE";
            }
        }
        else if (CP_DES_DDREN == "FALSE" && CP_IDFFEN == "TRUE" && CP_ILTHEN == "FALSE")
        {
            ISERDES_MODE = "IDFF";
        }
        else if (CP_DES_DDREN == "FALSE" && CP_IDFFEN == "FALSE" && CP_ILTHEN == "TRUE")
        {
            ISERDES_MODE = "ILATCH";
        }
    }

    if (ISERDES_MODE != "DISABLE")
    {
        wire ntOCLK_POL, ntOCLKB_POL;
        if (CP_OCLKPOL == "TRUE")
        {
            operator V_INV OCLKPOL
            port map
            (
                I => OCLK,
                Z => ntOCLK_POL
            );
        }

        if (CP_OCLKBPOL == "TRUE")
        {
            operator V_INV OCLKBPOL
            port map
            (
                I => OCLKB,
                Z => ntOCLKB_POL
            );
        }

        wire ntDESCLK_POL;
        string CP_DESCLKPOL = "";
        if (/*CP_CLK_POL0 == "TRUE" && */CP_CLK_POL1 == "TRUE" && CP_CLK_POL2 == "TRUE")
        {
            CP_DESCLKPOL = "TRUE";
            operator V_INV DESCLKPOL
            port map
            (
                I => DESCLK,
                Z => ntDESCLK_POL
            );
        }
        else if (/*CP_CLK_POL0 == "FALSE" && */CP_CLK_POL1 == "FALSE" && CP_CLK_POL2 == "FALSE")
        {
            CP_DESCLKPOL = "FALSE";
        }

        wire ntICLK_POL, ntICLKB_POL;
        string CP_ICLKPOL = "FALSE";
        if (CP_CLK_POL0 == "TRUE")
        {
            CP_ICLKPOL = "TRUE";
            operator V_INV ICLKPOL
            port map
            (
                I => ICLK,
                Z => ntICLK_POL
            );
            operator V_INV ICLKBPOL
            port map
            (
                I => ICLKB,
                Z => ntICLKB_POL
            );
        }

        wire ntICLKDIV_POL;
        string CP_ICLKDIVPOL = "FALSE";
        if (CP_CLK_POL3 == "TRUE")
        {
            CP_ICLKDIVPOL = "TRUE";
            operator V_INV ICLKDIVPOL
            port map
            (
                I => ICLKDIV,
                Z => ntICLKDIV_POL
            );
        }

        operator V_ISERDES_E2 ISERDES
        parameter map
        (
            ISERDES_MODE    =>  ISERDES_MODE,
            GRS_EN          => (CP_GRS_DIS == 1'b0) ? "TRUE" : "FALSE",
            CASCADE_MODE    =>  CP_MASTER,
            BITSLIP_EN      =>  CP_BITSLIP_EN,
            NUM_ICE         => (CP_NUM_ICE == 1'b0) ? 0 : 1,
            GRS_TYPE_Q0     => (CP_INIT_Q0 == 1'b0) ? "RESET" : "SET",
            GRS_TYPE_Q1     => (CP_INIT_Q1 == 1'b0) ? "RESET" : "SET",
            GRS_TYPE_Q2     => (CP_INIT_Q2 == 1'b0) ? "RESET" : "SET",
            GRS_TYPE_Q3     => (CP_INIT_Q3 == 1'b0) ? "RESET" : "SET",
            LRS_TYPE_Q0     => (CP_ISR_SYNC == "ASYNC" && CP_SRVAL_Q0 == "RESET") ? "ASYNC_RESET" :
                               (CP_ISR_SYNC == "ASYNC" && CP_SRVAL_Q0 == "SET")   ? "ASYNC_SET"   :
                               (CP_ISR_SYNC == "SYNC"  && CP_SRVAL_Q0 == "RESET") ? "SYNC_RESET"  :
                               (CP_ISR_SYNC == "SYNC"  && CP_SRVAL_Q0 == "SET")   ? "SYNC_SET"    : "",
            LRS_TYPE_Q1     => (CP_ISR_SYNC == "ASYNC" && CP_SRVAL_Q1 == "RESET") ? "ASYNC_RESET" :
                               (CP_ISR_SYNC == "ASYNC" && CP_SRVAL_Q1 == "SET")   ? "ASYNC_SET"   :
                               (CP_ISR_SYNC == "SYNC"  && CP_SRVAL_Q1 == "RESET") ? "SYNC_RESET"  :
                               (CP_ISR_SYNC == "SYNC"  && CP_SRVAL_Q1 == "SET")   ? "SYNC_SET"    : "",
            LRS_TYPE_Q2     => (CP_ISR_SYNC == "ASYNC" && CP_SRVAL_Q2 == "RESET") ? "ASYNC_RESET" :
                               (CP_ISR_SYNC == "ASYNC" && CP_SRVAL_Q2 == "SET")   ? "ASYNC_SET"   :
                               (CP_ISR_SYNC == "SYNC"  && CP_SRVAL_Q2 == "RESET") ? "SYNC_RESET"  :
                               (CP_ISR_SYNC == "SYNC"  && CP_SRVAL_Q2 == "SET")   ? "SYNC_SET"    : "",
            LRS_TYPE_Q3     => (CP_ISR_SYNC == "ASYNC" && CP_SRVAL_Q3 == "RESET") ? "ASYNC_RESET" :
                               (CP_ISR_SYNC == "ASYNC" && CP_SRVAL_Q3 == "SET")   ? "ASYNC_SET"   :
                               (CP_ISR_SYNC == "SYNC"  && CP_SRVAL_Q3 == "RESET") ? "SYNC_RESET"  :
                               (CP_ISR_SYNC == "SYNC"  && CP_SRVAL_Q3 == "SET")   ? "SYNC_SET"    : ""
        )
        port map
        (
            RST         => (CP_ISR_EN == "TRUE") ? ntISR : 1'b0,
            ICE0        =>  ICE0,
            ICE1        =>  ICE1,
            DESCLK      => (CP_DESCLKPOL  == "TRUE" ) ? ntDESCLK_POL : 
                           (CP_DESCLKPOL  == "FALSE") ? DESCLK : 1'b0,
            ICLK        => (CP_ICLKPOL    == "TRUE" ) ? ntICLK_POL :
                           (CP_ICLKPOL    == "FALSE") ? ICLK : 1'b0,
            //ICLKB       => (CP_ICLKPOL    == "TRUE" ) ? ntICLKB_POL :
            //               (CP_ICLKPOL    == "FALSE") ? ICLKB : 1'b0,
            OCLK        => (CP_OCLKPOL    == "TRUE" ) ? ntOCLK_POL : 
                           (CP_OCLKPOL    == "FALSE") ? OCLK : 1'b0,
            //OCLKB       => (CP_OCLKBPOL   == "TRUE" ) ? ntOCLKB_POL :
            //               (CP_OCLKBPOL   == "FALSE") ? OCLKB : 1'b0,
            ICLKDIV     => (CP_ICLKDIVPOL == "TRUE" ) ? ntICLKDIV_POL :
                           (CP_ICLKDIVPOL == "FALSE") ? ICLKDIV : 1'b0,
            DI          =>  ntDI_TO_GEAR,
            BITSLIP     =>  BITSLIP,
            ISHIFTIN0   =>  ISHIFTIN0,
            ISHIFTIN1   =>  ISHIFTIN1,
            IFIFO_WADDR =>  IFIFO_WADDR,
            IFIFO_RADDR =>  IFIFO_RADDR,
            DO          =>  RX_DATA,
            ISHIFTOUT0  =>  ISHIFTOUT0,
            ISHIFTOUT1  =>  ISHIFTOUT1
        );
    }

    wire ntDO_DD, ntDO_SDR, ntDO_DDR, ntTO_DD, ntTO_SDR, ntTO_DDR;
    operator V_BUF i_DO_DD
    port map (
       I   =>  TX_DATA[0],
       Z   =>  ntDO_DD
    );
    operator V_BUF i_TO_DD
    port map (
       I   =>  TS_CTRL[0],
       Z   =>  ntTO_DD
    );

    string OSERDES_MODE = "DISABLE";
    if (CP_OSERDES_EN == "TRUE")
    {
        if (CP_DQMODE == 2'b01 /*&& CP_TQMODE == 2'b01*/ && CP_SER_SDREN == "TRUE" && CP_OHSMEM_EN == "TRUE")
        {
            if (CP_OSERDES_MODE == "DDR4TO1" /*|| CP_OSERDES_MODE == "SDR4TO1" */)
            {
                OSERDES_MODE = "HMSDR4TO1";
            }
            else if (CP_OSERDES_MODE == "DDR8TO1" /*|| CP_OSERDES_MODE == "SDR8TO1" */)
            {
                OSERDES_MODE = "HMSDR8TO1";
            }
        }
        else if (CP_DQMODE == 2'b01 /*&& CP_TQMODE == 2'b01*/ && CP_SER_SDREN == "TRUE" &&
           (CP_OSERDES_MODE == "SDR2TO1" || CP_OSERDES_MODE == "SDR3TO1" || CP_OSERDES_MODE == "SDR4TO1" || 
            CP_OSERDES_MODE == "SDR5TO1" || CP_OSERDES_MODE == "SDR6TO1" || CP_OSERDES_MODE == "SDR7TO1" || 
            CP_OSERDES_MODE == "SDR8TO1"))
        {
            OSERDES_MODE = CP_OSERDES_MODE;
        }
        else if (CP_DQMODE == 2'b10 /*&& CP_TQMODE == 2'b10*/ && CP_SER_DDREN == "TRUE" &&
           (CP_OSERDES_MODE == "DDR4TO1" || CP_OSERDES_MODE == "DDR6TO1" || CP_OSERDES_MODE == "DDR8TO1" || 
            CP_OSERDES_MODE == "DDR10TO1" || CP_OSERDES_MODE == "DDR14TO1"))
        {
            OSERDES_MODE = CP_OSERDES_MODE;
        }
    }
    else if (CP_OSERDES_EN == "FALSE")
    {
        if (CP_DQMODE == 2'b01 /*&& CP_TQMODE == 2'b01*/ && CP_ODFFEN == "TRUE")
        {
            OSERDES_MODE = "ODFF";
        }
        else if (CP_DQMODE == 2'b01 /*&& CP_TQMODE == 2'b01*/ && CP_OLTHEN == "TRUE")
        {
            OSERDES_MODE = "OLATCH";
        }
        else if (CP_DQMODE == 2'b10 /*&& CP_TQMODE == 2'b10*/ && CP_SER_DDREN == "TRUE" && CP_OPPOSITE_EN == "FALSE")
        {
            OSERDES_MODE = CP_OPPOSITE_EN == "FALSE" ? "DDR2TO1_SAME_EDGE" : "DDR2TO1_OPPOSITE_EDGE";
        }
    }

    if (OSERDES_MODE != "DISABLE" && (CP_MIPI_EN == "TRUE" || CP_DQMODE == 2'b01 || CP_DQMODE == 2'b10))
    {
        operator V_OSERDES_E2 OSERDES
        parameter map
        (
            GRS_EN        =>     (CP_GRS_DIS == 1'b0) ? "TRUE" : "FALSE",
            OSERDES_MODE  =>         OSERDES_MODE,
            UPD0_SHIFT_EN =>      CP_UPD0_SHIFTEN,
            UPD1_SHIFT_EN =>      CP_UPD1_SHIFTEN,
            INIT_SET      =>      CP_INIT_SET,
            GRS_TYPE_DQ   =>     (CP_INIT_DQ == 1'b0) ? "RESET" : "SET",
            LRS_TYPE_DQ0  =>     (CP_O_SYNC == "ASYNC" && CP_SRVAL_DQ0 == "RESET") ? "ASYNC_RESET" :
                                 (CP_O_SYNC == "ASYNC" && CP_SRVAL_DQ0 == "SET")   ? "ASYNC_SET"   :
                                 (CP_O_SYNC == "SYNC"  && CP_SRVAL_DQ0 == "RESET")  ? "SYNC_RESET"  :
                                 (CP_O_SYNC == "SYNC"  && CP_SRVAL_DQ0 == "SET")   ? "SYNC_SET"    : "",
            LRS_TYPE_DQ1  =>     (CP_O_SYNC == "ASYNC" && CP_SRVAL_DQ1 == "RESET") ? "ASYNC_RESET" :
                                 (CP_O_SYNC == "ASYNC" && CP_SRVAL_DQ1 == "SET")   ? "ASYNC_SET"   :
                                 (CP_O_SYNC == "SYNC"  && CP_SRVAL_DQ1 == "RESET")  ? "SYNC_RESET"  :
                                 (CP_O_SYNC == "SYNC"  && CP_SRVAL_DQ1 == "SET")   ? "SYNC_SET"    : "",
            LRS_TYPE_DQ2  =>     (CP_O_SYNC == "ASYNC" && CP_SRVAL_DQ2 == "RESET") ? "ASYNC_RESET" :
                                 (CP_O_SYNC == "ASYNC" && CP_SRVAL_DQ2 == "SET")   ? "ASYNC_SET"   :
                                 (CP_O_SYNC == "SYNC"  && CP_SRVAL_DQ2 == "RESET")  ? "SYNC_RESET"  :
                                 (CP_O_SYNC == "SYNC"  && CP_SRVAL_DQ2 == "SET")   ? "SYNC_SET"    : "",
            LRS_TYPE_DQ3  =>     (CP_O_SYNC == "ASYNC" && CP_SRVAL_DQ3 == "RESET") ? "ASYNC_RESET" :
                                 (CP_O_SYNC == "ASYNC" && CP_SRVAL_DQ3 == "SET")   ? "ASYNC_SET"   :
                                 (CP_O_SYNC == "SYNC"  && CP_SRVAL_DQ3 == "RESET")  ? "SYNC_RESET"  :
                                 (CP_O_SYNC == "SYNC"  && CP_SRVAL_DQ3 == "SET")   ? "SYNC_SET"    : "",
            GRS_TYPE_TQ   =>     (CP_INIT_TQ == 1'b0) ? "RESET" : "SET",// "RESET",
            LRS_TYPE_TQ0  =>     (CP_T_SYNC == "ASYNC" && CP_SRVAL_TQ0 == "RESET") ? "ASYNC_RESET" :
                                 (CP_T_SYNC == "ASYNC" && CP_SRVAL_TQ0 == "SET")   ? "ASYNC_SET"   :
                                 (CP_T_SYNC == "SYNC"  && CP_SRVAL_TQ0 == "RESET")  ? "SYNC_RESET"  :
                                 (CP_T_SYNC == "SYNC"  && CP_SRVAL_TQ0 == "SET")   ? "SYNC_SET"    : "",
            LRS_TYPE_TQ1  =>     (CP_T_SYNC == "ASYNC" && CP_SRVAL_TQ1 == "RESET") ? "ASYNC_RESET" :
                                 (CP_T_SYNC == "ASYNC" && CP_SRVAL_TQ1 == "SET")   ? "ASYNC_SET"   :
                                 (CP_T_SYNC == "SYNC"  && CP_SRVAL_TQ1 == "RESET")  ? "SYNC_RESET"  :
                                 (CP_T_SYNC == "SYNC"  && CP_SRVAL_TQ1 == "SET")   ? "SYNC_SET"    : "",
            LRS_TYPE_TQ2  =>     (CP_T_SYNC == "ASYNC" && CP_SRVAL_TQ2 == "RESET") ? "ASYNC_RESET" :
                                 (CP_T_SYNC == "ASYNC" && CP_SRVAL_TQ2 == "SET")   ? "ASYNC_SET"   :
                                 (CP_T_SYNC == "SYNC"  && CP_SRVAL_TQ2 == "RESET")  ? "SYNC_RESET"  :
                                 (CP_T_SYNC == "SYNC"  && CP_SRVAL_TQ2 == "SET")   ? "SYNC_SET"    : "",
            LRS_TYPE_TQ3  =>     (CP_T_SYNC == "ASYNC" && CP_SRVAL_TQ3 == "RESET") ? "ASYNC_RESET" :
                                 (CP_T_SYNC == "ASYNC" && CP_SRVAL_TQ3 == "SET")   ? "ASYNC_SET"   :
                                 (CP_T_SYNC == "SYNC"  && CP_SRVAL_TQ3 == "RESET")  ? "SYNC_RESET"  :
                                 (CP_T_SYNC == "SYNC"  && CP_SRVAL_TQ3 == "SET")   ? "SYNC_SET"    : "",
            TRI_EN        =>      CP_TRI_EN,
            TBYTE_EN      =>      CP_TBYTE_EN,
            MIPI_EN       =>      CP_MIPI_EN,
            OCASCADE_EN   =>      CP_OCASCADE_EN,
            TSERDES_EN    =>     "FALSE"
        )
        port map
        (
            RST        => (CP_SRO_EN == "TRUE") ? ntOSR : 1'b0,
            OCE        =>  OCE,
            TCE        =>  TCE,
            OCLKDIV    => (CP_CLK_POL4 == "TRUE") ? OCLKDIVB : OCLKDIV,
            //OCLKDIVB   => (CP_CLK_POL4 == "TRUE") ? OCLKDIV : OCLKDIVB,
            SERCLK     => (CP_CLK_POL5 == "TRUE") ? SERCLKB : SERCLK,
            //SERCLKB    => (CP_CLK_POL5 == "TRUE") ? SERCLK : SERCLKB,
            OCLK       => (CP_CLK_POL6 == "TRUE") ? OCLKB : OCLK,
            //OCLKB      => (CP_CLK_POL6 == "TRUE") ? OCLK : OCLKB,
            MIPI_CTRL  =>  MIPI_SW_DYN_I,
            UPD0_SHIFT =>  UPD0_SHIFT,
            UPD1_SHIFT =>  UPD1_SHIFT,
            OSHIFTIN0  =>  OSHIFTIN0,
            OSHIFTIN1  =>  OSHIFTIN1,
            DI         =>  TX_DATA,
            TI         =>  TS_CTRL,
            TBYTE_IN   =>  T_BYTEIN,
            OSHIFTOUT0 =>  OSHIFTOUT0,
            OSHIFTOUT1 =>  OSHIFTOUT1,
            TQ         =>  ntTO_DDR,
            DO         =>  ntDO_DDR
        );
    }
    else if (CP_TQMODE == 2'b01)
    {
        if(CP_T_SYNC == "SYNC")
        {
            operator V_FFSYN TSFF
            parameter map 
            (
                GRS_EN    =>  (CP_GRS_DIS == 1'b0) ? "TRUE" : "FALSE",
                SET_RESET =>   CP_SRVAL_TQ0,
                LRS_EN    =>   CP_SRT_EN
            )
            port map 
            (
               Q  =>  ntTO_DDR,
               D  =>  TS_CTRL[0],
               SR =>  ntOSR, 
               CK => (CP_CLK_POL6 == "TRUE") ? OCLKB : OCLK,
               CE =>  TCE
            ); 
        }
        else if(CP_T_SYNC == "ASYNC")
        {
            operator V_FFASYN TSFF
            parameter map 
            (
                GRS_EN    =>  (CP_GRS_DIS == 1'b0) ? "TRUE" : "FALSE",
                SET_RESET =>   CP_SRVAL_TQ0,
                LRS_EN    =>   CP_SRT_EN
            )
            port map 
            (
               Q  =>  ntTO_DDR,
               D  =>  TS_CTRL[0], 
               SR =>  ntOSR, 
               CK => (CP_CLK_POL6 == "TRUE") ? OCLKB : OCLK,
               CE =>  TCE
            ); 
        } 
    }
    else
    {
        // ntDO_SDR
        // ntTO_SDR
    }

    wire ntOFB_TMP;
    if (CP_MIPI_EN == "TRUE")
    {
        operator V_MUX2 i_MIPIOUT_MUX
        port map (
           I0   =>  ntDO_DD,
           I1   =>  ntDO_DDR,
           SEL  =>  MIPI_SW_DYN_I,
           Z    =>  ntOFB_TMP
        );
    }

    &wire ntOFB = (CP_MIPI_EN == "TRUE") ? ntOFB_TMP :
                  (CP_DQMODE == 2'b00) ? ntDO_DD  :
                  (CP_DQMODE == 2'b01) ? ntDO_DDR : // ntDO_SDR :
                  (CP_DQMODE == 2'b10) ? ntDO_DDR :
                /*(CP_DQMODE == 2'b11) ?*/ 1'b0 ;
    OFB <= ntOFB;

    &wire ntTFB = (CP_TBYTE_EN == "TRUE") ? ntT_BYTEIN : 
                  (CP_TQMODE == 2'b00) ? ntTO_DD  :
                  (CP_TQMODE == 2'b01) ? ntTO_DDR : //ntTO_SDR :
                  (CP_TQMODE == 2'b10) ? ntTO_DDR :
                /*(CP_TQMODE == 2'b11) ?*/ 1'b0 ;
    TO_CAS_OUT <= ntTFB;

    &wire ntTERMFB = (CP_TBYTE_EN == "TRUE") ? ntTERM_BYTEIN : 
                  (CP_TQMODE == 2'b00) ? ntTO_DD  :
                  (CP_TQMODE == 2'b01) ? ntTO_SDR :
                  (CP_TQMODE == 2'b10) ? ntTO_DDR :
                /*(CP_TQMODE == 2'b11) ?*/ 1'b0 ;
    TERM_CAS_OUT <= ntTERMFB;

    &wire ntTO = (CP_PDIFF == "TRUE") ? ntTO_CAS_IN : ntTFB;
    &wire ntTERM = (CP_PDIFF == "TRUE") ? ntTERM_CAS_IN : ntTERMFB;
    TERM <= ntTERM;

    wire ntODLY;
    if (CP_ODLY_EN == "TRUE")
    {
        operator V_IODELAY_E2 i_ODLY
        parameter map (
            //LDO_CTRL => ,
            DELAY_STEP_SEL => (CP_ODYN_EN == "TRUE") ? "PORT" : "PARAMETER",
            DELAY_STEP_VALUE => CP_ODLY_SET
        )
        port map (
            DI    =>  ntOFB,
            DO    =>  ntODLY,
            DELAY_SEL => ODLY_SEL,
            DELAY_STEP => ODLY_DYN_SET
        );
    }
    &wire ntODLY_MUX = (CP_ODLY_EN == "TRUE") ? ntODLY : ntOFB;
    DO_CAS_OUT <= ntODLY_MUX;

    wire ntDO_CAS_IN_N;
    if (CP_PDIFF == "TRUE")
    {
        operator V_INV i_DO_CAS_IN_N
        port map (
           I    =>  ntDO_CAS_IN,
           Z    =>  ntDO_CAS_IN_N
        );
    }
    &wire ntDO = (CP_PDIFF == "TRUE") ? ntDO_CAS_IN_N : ntODLY_MUX;

    if (CP_TRI_EN == "FALSE" || 
       (CP_TBYTE_EN == "FALSE" && CP_TQMODE == 2'b11 && CP_PDIFF == "FALSE"))
    {
        // ntTO == 1'b0
        //DO_P <= ntDO;
        //DO_N <= ntDO;
        DO_P <= ntDO;
        DO_N <= 1'b0;
    }
    else
    {
        //operator V_MUX2 i_DO_P
        //port map (
        //   I0   =>  ntDO,
        //   I1   =>  1'b0,
        //   SEL  =>  ntTO,
        //   Z    =>  DO_P
        //);
        //operator V_MUX2 i_DO_N
        //port map (
        //   I0   =>  ntDO,
        //   I1   =>  1'b1,
        //   SEL  =>  ntTO,
        //   Z    =>  DO_N
        //);
        DO_P <= ntDO;
        DO_N <= ntTO;
    }
};
